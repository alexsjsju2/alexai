<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #000;
            overflow: hidden;
        }
        #terminal-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="terminal-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.js"></script>

    <script>
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#000000',
                foreground: '#00FF00',
                cursor: '#00FF00'
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        window.addEventListener('resize', () => fitAddon.fit());

        let vfs = {};
        let currentDir = '/home/user';
        let commandHistory = [];
        let historyIndex = -1;
        let env = {};

        function saveState() {
            localStorage.setItem('lorel_axun_vfs', JSON.stringify(vfs));
            localStorage.setItem('lorel_axun_cwd', currentDir);
            localStorage.setItem('lorel_axun_history', JSON.stringify(commandHistory));
            localStorage.setItem('lorel_axun_env', JSON.stringify(env));
        }

        function loadState() {
            const savedVfs = localStorage.getItem('lorel_axun_vfs');
            if (savedVfs) {
                vfs = JSON.parse(savedVfs);
            } else {
                vfs = {
                    'home': {
                        type: 'directory',
                        content: {
                            'user': {
                                type: 'directory',
                                content: {
                                    'readme.txt': {
                                        type: 'file',
                                        content: 'Benvenuto in Lorel Axun! Digita `help` per una lista di comandi.'
                                    }
                                }
                            }
                        }
                    }
                };
            }

            const savedCwd = localStorage.getItem('lorel_axun_cwd');
            if (savedCwd) currentDir = savedCwd;

            const savedHistory = localStorage.getItem('lorel_axun_history');
            if (savedHistory) commandHistory = JSON.parse(savedHistory);
            
            const savedEnv = localStorage.getItem('lorel_axun_env');
            if (savedEnv) {
                env = JSON.parse(savedEnv);
            } else {
                env = {
                    'USER': 'user',
                    'HOME': '/home/user',
                    'PS1': '$ '
                };
            }
        }

        function resolvePath(path) {
            if (!path) return currentDir;
            let newPath = path.startsWith('/') ? [] : currentDir.split('/').filter(p => p);
            const parts = path.split('/').filter(p => p);

            for (const part of parts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (newPath.length > 0) newPath.pop();
                } else {
                    newPath.push(part);
                }
            }
            return '/' + newPath.join('/');
        }

        function getPathObject(path) {
            const resolvedPath = resolvePath(path);
            const parts = resolvedPath.split('/').filter(p => p);
            let current = vfs;
            for (const part of parts) {
                if (current && current.type === 'directory' && current.content[part]) {
                    current = current.content[part];
                } else {
                    return null;
                }
            }
            return current;
        }

        function getParentPathObject(path) {
            const resolvedPath = resolvePath(path);
            const parts = resolvedPath.split('/').filter(p => p);
            const parentPath = '/' + parts.slice(0, -1).join('/');
            return getPathObject(parentPath);
        }

        function expandVariables(arg) {
            return arg.replace(/\$([A-Za-z_][A-Za-z0-9_]*)/g, (match, varName) => {
                return env[varName] || '';
            });
        }

        const commands = {
            'help': {
                description: 'Mostra questa lista di comandi.',
                execute: async () => {
                    let helpText = 'Comandi disponibili:\n\n';
                    for (const cmd in commands) {
                        helpText += `  ${cmd.padEnd(10)} ${commands[cmd].description}\n`;
                    }
                    return helpText;
                }
            },
            'ls': {
                description: 'Lista i file nella directory corrente.',
                execute: async (args) => {
                    const path = args[0] || '.';
                    const target = getPathObject(resolvePath(path));
                    if (target && target.type === 'directory') {
                        return Object.keys(target.content).join('\t');
                    } else if (target && target.type === 'file') {
                        return path.split('/').pop();
                    } else {
                        return `ls: cannot access '${path}': No such file or directory`;
                    }
                }
            },
            'cd': {
                description: 'Cambia la directory corrente.',
                execute: async (args) => {
                    const path = args[0] || env['HOME'] || '/';
                    const newPath = resolvePath(path);
                    const target = getPathObject(newPath);
                    if (target && target.type === 'directory') {
                        currentDir = newPath;
                        return '';
                    } else {
                        return `cd: ${path}: No such file or directory`;
                    }
                }
            },
            'cat': {
                description: 'Mostra il contenuto di un file.',
                execute: async (args, term, input) => {
                    if (input !== null) return input;
                    if (args.length === 0) return 'cat: missing operand';
                    const path = args[0];
                    const target = getPathObject(resolvePath(path));
                    if (target && target.type === 'file') {
                        return target.content;
                    } else {
                        return `cat: ${path}: No such file or directory`;
                    }
                }
            },
            'mkdir': {
                description: 'Crea una nuova directory.',
                execute: async (args) => {
                    if (args.length === 0) return 'mkdir: missing operand';
                    const path = args[0];
                    const resolvedPath = resolvePath(path);
                    const parent = getParentPathObject(resolvedPath);
                    const newDirName = resolvedPath.split('/').pop();
                    if (parent && parent.type === 'directory') {
                        if (parent.content[newDirName]) {
                            return `mkdir: cannot create directory '${path}': File exists`;
                        }
                        parent.content[newDirName] = { type: 'directory', content: {} };
                        return '';
                    } else {
                        return `mkdir: cannot create directory '${path}': No such file or directory`;
                    }
                }
            },
            'touch': {
                description: 'Crea un nuovo file vuoto.',
                execute: async (args) => {
                    if (args.length === 0) return 'touch: missing operand';
                    const path = args[0];
                    const resolvedPath = resolvePath(path);
                    const parent = getParentPathObject(resolvedPath);
                    const newFileName = resolvedPath.split('/').pop();
                    if (parent && parent.type === 'directory') {
                        if (!parent.content[newFileName]) {
                            parent.content[newFileName] = { type: 'file', content: '' };
                        }
                        return '';
                    } else {
                        return `touch: cannot touch '${path}': No such file or directory`;
                    }
                }
            },
            'rm': {
                description: 'Rimuove un file o una directory.',
                execute: async (args) => {
                    if (args.length === 0) return 'rm: missing operand';
                    const path = args[0];
                    const resolvedPath = resolvePath(path);
                    const parent = getParentPathObject(resolvedPath);
                    const targetName = resolvedPath.split('/').pop();
                    if (parent && parent.type === 'directory' && parent.content[targetName]) {
                        delete parent.content[targetName];
                        return '';
                    } else {
                        return `rm: cannot remove '${path}': No such file or directory`;
                    }
                }
            },
            'echo': {
                description: 'Stampa un testo.',
                execute: async (args) => {
                    return args.join(' ');
                }
            },
            'clear': {
                description: 'Pulisce lo schermo del terminale.',
                execute: async (args, term) => {
                    term.clear();
                    return '';
                }
            },
            'ciao': {
                description: 'Saluta Lorel Axun.',
                execute: async () => 'Ciao! Sono Lorel Axun, la tua IA personale. Come posso aiutarti?'
            },
            'chi sei': {
                description: 'Chiede a Lorel Axun di presentarsi.',
                execute: async () => 'Sono Lorel Axun, un sistema operativo web autonomo. Esisto per imparare, evolvere e assisterti.'
            },
            'type': {
                description: 'Scrive un testo con effetto macchina da scrivere.',
                execute: async (args, term) => {
                    const text = args.join(' ');
                    return new Promise(resolve => {
                        let i = 0;
                        const interval = setInterval(() => {
                            if (i < text.length) {
                                term.write(text[i]);
                                i++;
                            } else {
                                clearInterval(interval);
                                resolve('');
                            }
                        }, 50);
                    });
                }
            },
            'fetch': {
                description: 'Esegue una richiesta HTTP GET. Usage: fetch <url>',
                execute: async (args) => {
                    if (args.length === 0) return 'fetch: missing URL';
                    const url = args[0];
                    try {
                        const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
                        const response = await fetch(proxyUrl);
                        if (!response.ok) {
                            return `fetch: request failed with status ${response.status}`;
                        }
                        const text = await response.text();
                        return text;
                    } catch (error) {
                        return `fetch: error: ${error.message}`;
                    }
                }
            },
            'edit': {
                description: 'Apre un semplice editor di testo. Usage: edit <file>',
                execute: async (args, term) => {
                    if (args.length === 0) return 'edit: missing file operand';
                    const path = resolvePath(args[0]);
                    let file = getPathObject(path);
                    if (!file) {
                        await commands.touch.execute(args);
                        file = getPathObject(path);
                    }
                    if (file.type !== 'file') return `edit: '${args[0]}' is not a file`;

                    term.setOption('disableStdin', true);
                    term.clear();
                    term.write('--- Editor di Testo --- Ctrl+S per salvare, Ctrl+X per uscire ---\r\n');
                    term.write(file.content);

                    let buffer = file.content;
                    let originalCursorBlink = term.getOption('cursorBlink');
                    term.setOption('cursorBlink', true);

                    return new Promise(resolve => {
                        const disposable = term.onKey(e => {
                            const key = e.key;
                            if (key.charCodeAt(0) === 27) { // Arrow keys, etc.
                                return;
                            }
                            if (key === '\u0013') { // Ctrl+S
                                file.content = buffer;
                                term.write('\r\n\n--- Salvato ---');
                            } else if (key === '\u0018') { // Ctrl+X
                                disposable.dispose();
                                term.setOption('disableStdin', false);
                                term.setOption('cursorBlink', originalCursorBlink);
                                term.clear();
                                resolve('');
                            } else if (key === '\r') { // Enter
                                buffer += '\n';
                                term.write('\r\n');
                            } else if (key.charCodeAt(0) === 127) { // Backspace
                                if (buffer.length > 0) {
                                    buffer = buffer.slice(0, -1);
                                    term.write('\b \b');
                                }
                            } else {
                                buffer += key;
                                term.write(key);
                            }
                        });
                    });
                }
            },
            'js': {
                description: 'Esegue codice JavaScript in una sandbox. Usage: js <file> or js -c "code"',
                execute: async (args, term) => {
                    let code = '';
                    if (args[0] === '-c' && args[1]) {
                        code = args.slice(1).join(' ');
                    } else if (args[0]) {
                        const file = getPathObject(resolvePath(args[0]));
                        if (file && file.type === 'file') {
                            code = file.content;
                        } else {
                            return `js: file not found: ${args[0]}`;
                        }
                    } else {
                        return 'Usage: js <file> or js -c "code"';
                    }

                    const sandboxApi = {
                        log: (...args) => {
                            const output = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
                            term.writeln(output);
                        },
                        vfs: {
                            readFile: (path) => {
                                const file = getPathObject(resolvePath(path));
                                if (file && file.type === 'file') return file.content;
                                throw new Error(`File not found: ${path}`);
                            },
                            writeFile: (path, content) => {
                                const resolved = resolvePath(path);
                                const parent = getParentPathObject(resolved);
                                const name = resolved.split('/').pop();
                                if (parent && parent.type === 'directory') {
                                    parent.content[name] = { type: 'file', content: String(content) };
                                    return true;
                                }
                                throw new Error(`Invalid path: ${path}`);
                            },
                            listDir: (path) => {
                                const dir = getPathObject(resolvePath(path));
                                if (dir && dir.type === 'directory') return Object.keys(dir.content);
                                throw new Error(`Directory not found: ${path}`);
                            },
                            exists: (path) => !!getPathObject(resolvePath(path))
                        },
                        env: {
                            get: (key) => env[key],
                            getAll: () => ({...env})
                        }
                    };

                    try {
                        const sandboxedFunc = new Function('api', `with (api) { ${code} }`);
                        sandboxedFunc(sandboxApi);
                        return '';
                    } catch (e) {
                        return `js error: ${e.message}`;
                    }
                }
            },
            'export': {
                description: 'Imposta una variabile d\'ambiente. Usage: export VAR=value',
                execute: async (args) => {
                    if (args.length === 0) {
                        return Object.entries(env).map(([key, value]) => `${key}=${value}`).join('\n');
                    }
                    for (const arg of args) {
                        const match = arg.match(/^([A-Za-z_][A-Za-z0-9_]*)=(.*)$/);
                        if (match) {
                            const [, key, value] = match;
                            env[key] = value;
                        } else {
                            return `export: formato non valido: ${arg}`;
                        }
                    }
                    return '';
                }
            },
            'unset': {
                description: 'Rimuove una variabile d\'ambiente. Usage: unset VAR',
                execute: async (args) => {
                    if (args.length === 0) return 'unset: operando mancante';
                    args.forEach(arg => delete env[arg]);
                    return '';
                }
            },
            'env': {
                description: 'Mostra le variabili d\'ambiente.',
                execute: async () => {
                    return Object.entries(env).map(([key, value]) => `${key}=${value}`).join('\n');
                }
            }
        };

        async function executePipedCommands(commandsToPipe, term) {
            let input = null;
            let output = '';
            for (let i = 0; i < commandsToPipe.length; i++) {
                const [cmd, ...args] = commandsToPipe[i];
                if (commands[cmd]) {
                    output = await commands[cmd].execute(args, term, input);
                    input = output;
                } else {
                    return `Comando non trovato: ${cmd}`;
                }
            }
            return output;
        }

        async function runCommand(fullCommand) {
            const trimmedCommand = fullCommand.trim();
            if (!trimmedCommand) return;

            const [commandPart, ...redirectParts] = trimmedCommand.split(/\s+(?=[>]{1,2})/);
            let redirectOp = null;
            let redirectFile = null;

            if (redirectParts.length > 0) {
                const redirectStr = redirectParts.join(' ').trim();
                if (redirectStr.startsWith('>>')) {
                    redirectOp = '>>';
                    redirectFile = redirectStr.substring(2).trim();
                } else if (redirectStr.startsWith('>')) {
                    redirectOp = '>';
                    redirectFile = redirectStr.substring(1).trim();
                }
            }

            const pipedCommands = commandPart.split('|').map(s => s.trim());
            const commandsToExecute = pipedCommands.map(c => {
                const parts = c.match(/("[^"]+"|'[^']+'|\S+)/g) || [];
                return parts.map(p => p.startsWith('"') || p.startsWith('\'') ? p.slice(1, -1) : p)
                            .map(expandVariables);
            });

            let output = await executePipedCommands(commandsToExecute, term);

            if (redirectFile) {
                const path = resolvePath(redirectFile);
                let file = getPathObject(path);
                if (file && file.type === 'directory') {
                    output = `bash: ${redirectFile}: Is a directory`;
                } else {
                    if (!file) {
                        await commands.touch.execute([redirectFile]);
                        file = getPathObject(path);
                    }
                    if (redirectOp === '>') {
                        file.content = output;
                    } else if (redirectOp === '>>') {
                        file.content += (file.content ? '\n' : '') + output;
                    }
                    output = ''; // No output to terminal when redirecting
                }
            }

            if (output) {
                term.writeln(output);
            }
        }

        function showPrompt() {
            let path = currentDir;
            const homeDir = env['HOME'] || '/home/user';
            if (path.startsWith(homeDir)) {
                path = '~' + path.substring(homeDir.length);
            }
            if (path === '') path = '/';
            term.write(`\r\n${path}${env['PS1'] || '$ '}`);
        }

        let currentCommand = '';
        function handleInput(data) {
            const code = data.charCodeAt(0);
            if (code === 13) { // Enter
                term.write('\r\n');
                if (currentCommand.trim()) {
                    commandHistory.unshift(currentCommand);
                    if (commandHistory.length > 50) commandHistory.pop();
                    historyIndex = -1;
                    runCommand(currentCommand).then(() => {
                        saveState();
                        showPrompt();
                    });
                }
                currentCommand = '';
            } else if (code === 127) { // Backspace
                if (currentCommand.length > 0) {
                    term.write('\b \b');
                    currentCommand = currentCommand.slice(0, -1);
                }
            } else if (code === 9) { // Tab
                 // Basic autocompletion
                const parts = currentCommand.split(' ');
                const lastPart = parts[parts.length - 1];
                const dir = lastPart.includes('/') ? resolvePath(lastPart.substring(0, lastPart.lastIndexOf('/') + 1)) : currentDir;
                const partialName = lastPart.includes('/') ? lastPart.substring(lastPart.lastIndexOf('/') + 1) : lastPart;
                const dirObj = getPathObject(dir);
                if (dirObj && dirObj.type === 'directory') {
                    const completions = Object.keys(dirObj.content).filter(name => name.startsWith(partialName));
                    if (completions.length === 1) {
                        const completion = completions[0];
                        const textToAdd = completion.substring(partialName.length);
                        currentCommand += textToAdd;
                        term.write(textToAdd);
                    }
                }
            } else if (code >= 32) { // Printable characters
                currentCommand += data;
                term.write(data);
            } else if (code === 27) { // Arrow keys
                const sequence = data.slice(1);
                if (sequence === '[A') { // Up arrow
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        term.write('\x1b[2K\r');
                        showPrompt();
                        currentCommand = commandHistory[historyIndex];
                        term.write(currentCommand);
                    }
                } else if (sequence === '[B') { // Down arrow
                    if (historyIndex > 0) {
                        historyIndex--;
                        term.write('\x1b[2K\r');
                        showPrompt();
                        currentCommand = commandHistory[historyIndex];
                        term.write(currentCommand);
                    } else {
                        historyIndex = -1;
                        term.write('\x1b[2K\r');
                        showPrompt();
                        currentCommand = '';
                    }
                }
            }
        }

        term.onData(handleInput);

        figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {
            if (err) {
                term.writeln('Lorel Axun');
                return;
            }
            term.writeln(data);
            term.writeln('Benvenuto. Digita `help` per iniziare.');
            loadState();
            showPrompt();
        });

        term.focus();
    </script>
</body>
</html>