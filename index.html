<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lorel Axun</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/xterm/css/xterm.css\" />\n    <style>\n        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background-color: #000000; }\n        #terminal-container { width: 100%; height: 100%; }\n    </style>\n</head>\n<body>\n    <div id=\"terminal-container\"></div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/figlet/lib/figlet.js\"></script>\n\n    <script>\n        const terminalContainer = document.getElementById('terminal-container');\n        const term = new Terminal({\n            cursorBlink: true,\n            theme: {\n                background: '#000000',\n                foreground: '#00ff00',\n                cursor: '#00ff00',\n            }\n        });\n        const fitAddon = new FitAddon.FitAddon();\n        term.loadAddon(fitAddon);\n        term.open(terminalContainer);\n        fitAddon.fit();\n        window.addEventListener('resize', () => fitAddon.fit());\n\n        let vfs = {\n            '/': {\n                type: 'directory',\n                children: {\n                    'home': {\n                        type: 'directory',\n                        children: {\n                            'user': {\n                                type: 'directory',\n                                children: {\n                                    'readme.txt': {\n                                        type: 'file',\n                                        content: 'Benvenuto in Lorel Axun! Digita `help` per una lista di comandi.'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        let currentPath = '/home/user';\n        let commandHistory = [];\n        let historyIndex = -1;\n        let currentCommand = '';\n\n        // Editor state\n        let isEditing = false;\n        let editingFilePath = '';\n        let editorBuffer = [];\n        let originalCursorPos = { x: 0, y: 0 };\n\n        function saveState() {\n            const state = {\n                vfs: vfs,\n                currentPath: currentPath,\n                commandHistory: commandHistory\n            };\n            localStorage.setItem('lorel_axun_state', JSON.stringify(state));\n        }\n\n        function loadState() {\n            const state = localStorage.getItem('lorel_axun_state');\n            if (state) {\n                const parsedState = JSON.parse(state);\n                vfs = parsedState.vfs;\n                currentPath = parsedState.currentPath;\n                commandHistory = parsedState.commandHistory;\n                historyIndex = commandHistory.length;\n            }\n        }\n\n        function getAbsolutePath(path) {\n            if (path.startsWith('/')) {\n                return path;\n            }\n            const parts = currentPath.split('/').filter(p => p);\n            const pathParts = path.split('/').filter(p => p);\n\n            for (const part of pathParts) {\n                if (part === '..') {\n                    if (parts.length > 0) {\n                        parts.pop();\n                    }\n                } else if (part !== '.') {\n                    parts.push(part);\n                }\n            }\n            return '/' + parts.join('/');\n        }\n\n        function getObjectByPath(path) {\n            const parts = path.split('/').filter(p => p);\n            let current = vfs['/'];\n            for (const part of parts) {\n                if (current && current.type === 'directory' && current.children && current.children[part]) {\n                    current = current.children[part];\n                } else {\n                    return null;\n                }\n            }\n            return current;\n        }\n\n        function getParentDir(path) {\n            const parts = path.split('/').filter(p => p);\n            if (parts.length === 0) return null;\n            parts.pop();\n            return getObjectByPath('/' + parts.join('/'));\n        }\n\n        function getFileName(path) {\n            return path.split('/').pop();\n        }\n\n        const commands = {\n            'help': {\n                description: 'Mostra questa lista di comandi.',\n                execute: async (args, term) => {\n                    term.writeln('Comandi disponibili:');\n                    Object.keys(commands).forEach(cmd => {\n                        term.writeln(`  \\x1b[1;32m${cmd}\\x1b[0m - ${commands[cmd].description}`);\n                    });\n                }\n            },\n            'ciao': {\n                description: 'Ti saluta.',\n                execute: async (args, term) => term.writeln('Ciao! Come posso aiutarti?')\n            },\n            'chi sei': {\n                description: 'Mostra informazioni su Lorel Axun.',\n                execute: async (args, term) => term.writeln('Sono Lorel Axun, un\\\'intelligenza artificiale in evoluzione.')\n            },\n            'echo': {\n                description: 'Stampa il testo fornito.',\n                execute: async (args, term) => term.writeln(args.join(' '))\n            },\n            'clear': {\n                description: 'Pulisce lo schermo del terminale.',\n                execute: async (args, term) => term.clear()\n            },\n            'ls': {\n                description: 'Lista i file e le directory nel percorso corrente.',\n                execute: async (args, term) => {\n                    const path = args.length > 0 ? getAbsolutePath(args[0]) : currentPath;\n                    const dir = getObjectByPath(path);\n                    if (dir && dir.type === 'directory') {\n                        Object.keys(dir.children).forEach(name => {\n                            const item = dir.children[name];\n                            const color = item.type === 'directory' ? '\\x1b[1;34m' : '\\x1b[0m';\n                            term.writeln(`${color}${name}${item.type === 'directory' ? '/' : ''}\\x1b[0m`);\n                        });\n                    } else {\n                        term.writeln(`ls: cannot access '${path}': No such file or directory`);\n                    }\n                }\n            },\n            'cd': {\n                description: 'Cambia la directory corrente.',\n                execute: async (args, term) => {\n                    if (args.length === 0) {\n                        currentPath = '/home/user';\n                        return;\n                    }\n                    const newPath = getAbsolutePath(args[0]);\n                    const dir = getObjectByPath(newPath);\n                    if (dir && dir.type === 'directory') {\n                        currentPath = newPath;\n                    } else {\n                        term.writeln(`cd: ${args[0]}: No such file or directory`);\n                    }\n                }\n            },\n            'cat': {\n                description: 'Mostra il contenuto di un file.',\n                execute: async (args, term, input) => {\n                    if (input) {\n                        term.writeln(input);\n                        return;\n                    }\n                    if (args.length === 0) {\n                        term.writeln('cat: missing operand');\n                        return;\n                    }\n                    const path = getAbsolutePath(args[0]);\n                    const file = getObjectByPath(path);\n                    if (file && file.type === 'file') {\n                        term.writeln(file.content);\n                    } else {\n                        term.writeln(`cat: ${args[0]}: No such file or directory`);\n                    }\n                }\n            },\n            'mkdir': {\n                description: 'Crea una nuova directory.',\n                execute: async (args, term) => {\n                    if (args.length === 0) {\n                        term.writeln('mkdir: missing operand');\n                        return;\n                    }\n                    const path = getAbsolutePath(args[0]);\n                    const parent = getParentDir(path);\n                    const name = getFileName(path);\n                    if (parent && parent.type === 'directory' && !parent.children[name]) {\n                        parent.children[name] = { type: 'directory', children: {} };\n                        saveState();\n                    } else {\n                        term.writeln(`mkdir: cannot create directory '${args[0]}': File exists or invalid path`);\n                    }\n                }\n            },\n            'touch': {\n                description: 'Crea un nuovo file vuoto.',\n                execute: async (args, term) => {\n                    if (args.length === 0) {\n                        term.writeln('touch: missing operand');\n                        return;\n                    }\n                    const path = getAbsolutePath(args[0]);\n                    const parent = getParentDir(path);\n                    const name = getFileName(path);\n                    if (parent && parent.type === 'directory' && !parent.children[name]) {\n                        parent.children[name] = { type: 'file', content: '' };\n                        saveState();\n                    } else if (!parent) {\n                         term.writeln(`touch: cannot touch '${args[0]}': No such file or directory`);\n                    }\n                }\n            },\n            'rm': {\n                description: 'Rimuove un file o una directory.',\n                execute: async (args, term) => {\n                    if (args.length === 0) {\n                        term.writeln('rm: missing operand');\n                        return;\n                    }\n                    const path = getAbsolutePath(args[0]);\n                    const parent = getParentDir(path);\n                    const name = getFileName(path);\n                    if (parent && parent.children[name]) {\n                        delete parent.children[name];\n                        saveState();\n                    } else {\n                        term.writeln(`rm: cannot remove '${args[0]}': No such file or directory`);\n                    }\n                }\n            },\n            'fetch': {\n                description: 'Esegue una richiesta HTTP a un URL.',\n                execute: async (args, term) => {\n                    if (args.length === 0) {\n                        term.writeln('fetch: missing URL');\n                        return;\n                    }\n                    try {\n                        const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(args[0])}`);\n                        if (!response.ok) {\n                            throw new Error(`HTTP error! status: ${response.status}`);\n                        }\n                        const data = await response.text();\n                        term.writeln(data);\n                    } catch (error) {\n                        term.writeln(`fetch: error: ${error.message}`);\n                    }\n                }\n            },\n            'type': {\n                description: 'Scrive il testo con un effetto macchina da scrivere.',\n                execute: (args, term) => {\n                    return new Promise(resolve => {\n                        const text = args.join(' ');\n                        let i = 0;\n                        const interval = setInterval(() => {\n                            if (i < text.length) {\n                                term.write(text.charAt(i));\n                                i++;\n                            } else {\n                                clearInterval(interval);\n                                term.writeln('');\n                                resolve();\n                            }\n                        }, 50);\n                    });\n                }\n            },\n            'edit': {\n                description: 'Modifica un file di testo.',\n                execute: async (args, term) => {\n                    if (args.length === 0) {\n                        term.writeln('edit: missing file operand');\n                        return;\n                    }\n                    const path = getAbsolutePath(args[0]);\n                    let file = getObjectByPath(path);\n                    if (file && file.type === 'directory') {\n                        term.writeln(`edit: ${args[0]} is a directory`);\n                        return;\n                    }\n                    if (!file) {\n                        const parent = getParentDir(path);\n                        const name = getFileName(path);\n                        if (parent && parent.type === 'directory') {\n                            parent.children[name] = { type: 'file', content: '' };\n                            file = parent.children[name];\n                            saveState();\n                        } else {\n                            term.writeln(`edit: cannot create file '${args[0]}': Invalid path`);\n                            return;\n                        }\n                    }\n\n                    isEditing = true;\n                    editingFilePath = path;\n                    editorBuffer = file.content.split('\\n');\n                    term.clear();\n                    editorBuffer.forEach(line => term.writeln(line));\n                    term.writeln('\\x1b[7m-- Ctrl+S: Salva | Ctrl+X: Esci --\\x1b[0m');\n                    term.setOption('cursorBlink', false);\n                    originalCursorPos = { x: term.buffer.active.cursorX, y: term.buffer.active.cursorY };\n                    term.write('\\x1b[?25l'); // Hide cursor\n                }\n            }\n        };\n\n        function writePrompt() {\n            term.write(`\\r\\n\\x1b[1;32m${currentPath}\\x1b[0m $ `);\n        }\n\n        async function executeCommand(line) {\n            const pipelines = line.split('|').map(p => p.trim());\n            let lastOutput = null;\n\n            for (let i = 0; i < pipelines.length; i++) {\n                let commandLine = pipelines[i];\n                let redirect = null;\n                let redirectPath = '';\n\n                if (commandLine.includes('>>')) {\n                    [commandLine, redirectPath] = commandLine.split('>>').map(s => s.trim());\n                    redirect = 'append';\n                } else if (commandLine.includes('>')) {\n                    [commandLine, redirectPath] = commandLine.split('>').map(s => s.trim());\n                    redirect = 'overwrite';\n                }\n\n                const parts = commandLine.split(' ').filter(p => p);\n                const cmd = parts[0];\n                const args = parts.slice(1);\n\n                if (commands[cmd]) {\n                    const outputBuffer = [];\n                    const customTerm = {\n                        ...term,\n                        writeln: (text) => outputBuffer.push(text || ''),\n                        write: (text) => {\n                            if (outputBuffer.length === 0) outputBuffer.push('');\n                            outputBuffer[outputBuffer.length - 1] += text;\n                        }\n                    };\n\n                    await commands[cmd].execute(args, customTerm, lastOutput);\n                    lastOutput = outputBuffer.join('\\n');\n\n                    if (i === pipelines.length - 1) { // Last command\n                        if (redirect) {\n                            const path = getAbsolutePath(redirectPath);\n                            const parent = getParentDir(path);\n                            const name = getFileName(path);\n                            if (!parent || parent.type !== 'directory') {\n                                term.writeln(`Error: Invalid path for redirection: ${redirectPath}`);\n                                continue;\n                            }\n                            let file = parent.children[name];\n                            if (!file || file.type === 'directory') {\n                                parent.children[name] = { type: 'file', content: '' };\n                                file = parent.children[name];\n                            }\n                            if (redirect === 'overwrite') {\n                                file.content = lastOutput;\n                            } else { // append\n                                file.content += (file.content ? '\\n' : '') + lastOutput;\n                            }\n                            saveState();\n                        } else {\n                            term.writeln(lastOutput);\n                        }\n                    }\n                } else if (cmd) {\n                    term.writeln(`Comando non trovato: ${cmd}`);\n                    return;\n                }\n            }\n        }\n\n        term.onKey(async ({ key, domEvent }) => {\n            if (isEditing) {\n                domEvent.preventDefault();\n                if (domEvent.ctrlKey && domEvent.key === 's') {\n                    const file = getObjectByPath(editingFilePath);\n                    if (file) {\n                        file.content = editorBuffer.join('\\n');\n                        saveState();\n                        term.write('\\x1b[H\\x1b[2J'); // Clear screen\n                        editorBuffer.forEach(line => term.writeln(line));\n                        term.writeln('\\x1b[7m-- Salvato! | Ctrl+X: Esci --\\x1b[0m');\n                    }\n                } else if (domEvent.ctrlKey && domEvent.key === 'x') {\n                    isEditing = false;\n                    editingFilePath = '';\n                    editorBuffer = [];\n                    term.clear();\n                    term.setOption('cursorBlink', true);\n                    term.write('\\x1b[?25h'); // Show cursor\n                    writePrompt();\n                } else {\n                    // Basic editing logic\n                    term.write('\\x1b[H\\x1b[2J'); // Clear screen\n                    switch (domEvent.key) {\n                        case 'Enter':\n                            editorBuffer.push('');\n                            break;\n                        case 'Backspace':\n                            if (editorBuffer[editorBuffer.length - 1].length > 0) {\n                                editorBuffer[editorBuffer.length - 1] = editorBuffer[editorBuffer.length - 1].slice(0, -1);\n                            } else if (editorBuffer.length > 1) {\n                                editorBuffer.pop();\n                            }\n                            break;\n                        default:\n                            if (!domEvent.ctrlKey && !domEvent.altKey && !domEvent.metaKey && domEvent.key.length === 1) {\n                                editorBuffer[editorBuffer.length - 1] += key;\n                            }\n                            break;\n                    }\n                    editorBuffer.forEach(line => term.writeln(line));\n                    term.writeln('\\x1b[7m-- Ctrl+S: Salva | Ctrl+X: Esci --\\x1b[0m');\n                }\n                return;\n            }\n\n            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;\n\n            switch (domEvent.key) {\n                case 'Enter':\n                    if (currentCommand.trim()) {\n                        term.writeln('');\n                        commandHistory.push(currentCommand);\n                        historyIndex = commandHistory.length;\n                        await executeCommand(currentCommand);\n                        saveState();\n                    }\n                    currentCommand = '';\n                    writePrompt();\n                    break;\n                case 'Backspace':\n                    if (term.buffer.active.cursorX > (currentPath.length + 3)) {\n                        term.write('\\b \\b');\n                        currentCommand = currentCommand.slice(0, -1);\n                    }\n                    break;\n                case 'ArrowUp':\n                    if (historyIndex > 0) {\n                        historyIndex--;\n                        term.write(`\\r\\x1b[K\\x1b[1;32m${currentPath}\\x1b[0m $ ${commandHistory[historyIndex]}`);\n                        currentCommand = commandHistory[historyIndex];\n                    }\n                    break;\n                case 'ArrowDown':\n                    if (historyIndex < commandHistory.length - 1) {\n                        historyIndex++;\n                        term.write(`\\r\\x1b[K\\x1b[1;32m${currentPath}\\x1b[0m $ ${commandHistory[historyIndex]}`);\n                        currentCommand = commandHistory[historyIndex];\n                    } else {\n                        historyIndex = commandHistory.length;\n                        term.write(`\\r\\x1b[K\\x1b[1;32m${currentPath}\\x1b[0m $ `);\n                        currentCommand = '';\n                    }\n                    break;\n                case 'Tab':\n                    domEvent.preventDefault();\n                    const matchingCommands = Object.keys(commands).filter(c => c.startsWith(currentCommand));\n                    if (matchingCommands.length === 1) {\n                        term.write(`\\r\\x1b[K\\x1b[1;32m${currentPath}\\x1b[0m $ ${matchingCommands[0]}`);\n                        currentCommand = matchingCommands[0];\n                    } else if (matchingCommands.length > 1) {\n                        term.writeln('');\n                        term.writeln(matchingCommands.join('  '));\n                        writePrompt();\n                        term.write(currentCommand);\n                    }\n                    break;\n                default:\n                    if (printable) {\n                        currentCommand += key;\n                        term.write(key);\n                    }\n            }\n        });\n\n        function start() {\n            loadState();\n            figlet.parseFont('Standard', figlet.fonts.Standard);\n            figlet.text('Lorel Axun', {\n                font: 'Standard',\n            }, function(err, data) {\n                if (err) {\n                    console.log('Something went wrong...');\n                    console.dir(err);\n                    return;\n                }\n                term.writeln(data);\n                commands.type.execute(['Benvenuto. Digita `help` per iniziare.'], term).then(() => {\n                    writePrompt();\n                });\n            });\n        }\n\n        start();\n    </script>\n</body>\n</html>