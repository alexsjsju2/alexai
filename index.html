<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lorel Axun</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css\" />\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            height: 100%;\n            width: 100%;\n            background-color: #000;\n        }\n        #terminal-container {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"terminal-container\"></div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.browser.js\"></script>\n\n    <script>\n        const terminalContainer = document.getElementById('terminal-container');\n\n        const term = new Terminal({\n            cursorBlink: true,\n            theme: {\n                background: '#000000',\n                foreground: '#00ff00',\n                cursor: '#00ff00',\n            }\n        });\n\n        const fitAddon = new FitAddon.FitAddon();\n        term.loadAddon(fitAddon);\n        term.open(terminalContainer);\n        fitAddon.fit();\n\n        window.addEventListener('resize', () => fitAddon.fit());\n\n        let vfs = {\n            '/': {\n                type: 'directory',\n                children: {\n                    'home': {\n                        type: 'directory',\n                        children: {\n                            'user': {\n                                type: 'directory',\n                                children: {\n                                    'readme.txt': {\n                                        type: 'file',\n                                        content: 'Benvenuto in Lorel Axun OS! Digita `help` per una lista di comandi.'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        let currentPath = '/home/user';\n        let commandHistory = [];\n        let historyIndex = -1;\n        let currentCommand = '';\n        let isEditing = false;\n        let editorContent = '';\n        let editingFilePath = '';\n        let onEditorSaveCallback = null;\n\n        const prompt = () => `\\x1b[1;32m${currentPath}\\x1b[0m $ `;
\n        const saveState = () => {\n            localStorage.setItem('lorel_axun_vfs', JSON.stringify(vfs));\n            localStorage.setItem('lorel_axun_path', currentPath);\n            localStorage.setItem('lorel_axun_history', JSON.stringify(commandHistory));\n        };\n\n        const loadState = () => {\n            const savedVfs = localStorage.getItem('lorel_axun_vfs');\n            const savedPath = localStorage.getItem('lorel_axun_path');\n            const savedHistory = localStorage.getItem('lorel_axun_history');\n            if (savedVfs) vfs = JSON.parse(savedVfs);\n            if (savedPath) currentPath = savedPath;\n            if (savedHistory) commandHistory = JSON.parse(savedHistory);\n        };\n\n        const resolvePath = (path) => {\n            if (path.startsWith('/')) return path;\n            const parts = (currentPath === '/' ? '' : currentPath).split('/').concat(path.split('/'));\n            const resolved = [];\n            for (const part of parts) {\n                if (part === '' || part === '.') continue;\n                if (part === '..') {\n                    if (resolved.length > 0) resolved.pop();\n                } else {\n                    resolved.push(part);\n                }\n            }\n            return '/' + resolved.join('/');\n        };\n\n        const getPathObject = (path) => {\n            const parts = path.split('/').filter(p => p);\n            let current = vfs['/'];\n            for (const part of parts) {\n                if (current && current.type === 'directory' && current.children[part]) {\n                    current = current.children[part];\n                } else {\n                    return null;\n                }\n            }\n            return current;\n        };\n        \n        const getParentDir = (path) => {\n            const parts = path.split('/').filter(p => p);\n            const parentPath = '/' + parts.slice(0, -1).join('/');\n            return getPathObject(parentPath);\n        };\n\n        const commands = {\n            'help': {\n                description: 'Mostra questa lista di comandi.',\n                execute: () => Object.keys(commands).map(c => `\\x1b[1;32m${c}\\x1b[0m: ${commands[c].description}`).join('\\n')\n            },\n            'ciao': {\n                description: 'Un saluto amichevole.',\n                execute: () => 'Ciao! Sono Lorel Axun. Come posso aiutarti?'\n            },\n            'chi sei': {\n                description: 'Mostra informazioni su Lorel Axun.',\n                execute: () => 'Sono Lorel Axun, un\\\'IA autonoma creata da AleXsjsju il 22/11/2025.'\n            },\n            'echo': {\n                description: 'Stampa il testo fornito.',\n                execute: (args) => args.join(' ')\n            },\n            'clear': {\n                description: 'Pulisce lo schermo del terminale.',\n                execute: () => term.clear()\n            },\n            'ls': {\n                description: 'Lista i file e le directory.',\n                execute: (args) => {\n                    const path = args.length > 0 ? resolvePath(args[0]) : currentPath;\n                    const dir = getPathObject(path);\n                    if (!dir || dir.type !== 'directory') return `ls: ${path}: Non è una directory`;\n                    return Object.keys(dir.children).map(name => {\n                        return dir.children[name].type === 'directory' ? `\\x1b[1;34m${name}/\\x1b[0m` : name;\n                    }).join('  ');\n                }\n            },\n            'cd': {\n                description: 'Cambia la directory corrente.',\n                execute: (args) => {\n                    if (args.length === 0) return '';\n                    const newPath = resolvePath(args[0]);\n                    const dir = getPathObject(newPath);\n                    if (dir && dir.type === 'directory') {\n                        currentPath = newPath;\n                        return '';\n                    } else {\n                        return `cd: ${args[0]}: Directory non trovata`;\n                    }\n                }\n            },\n            'cat': {\n                description: 'Mostra il contenuto di un file.',\n                execute: (args) => {\n                    if (args.length === 0) return 'Uso: cat <file>';\n                    const path = resolvePath(args[0]);\n                    const file = getPathObject(path);\n                    if (file && file.type === 'file') {\n                        return file.content;\n                    } else {\n                        return `cat: ${args[0]}: File non trovato o è una directory`;\n                    }\n                }\n            },\n            'mkdir': {\n                description: 'Crea una nuova directory.',\n                execute: (args) => {\n                    if (args.length === 0) return 'Uso: mkdir <nome_directory>';\n                    const path = resolvePath(args[0]);\n                    const parts = path.split('/').filter(p => p);\n                    const name = parts.pop();\n                    const parentDir = getPathObject('/' + parts.join('/'));\n                    if (parentDir && parentDir.type === 'directory') {\n                        if (parentDir.children[name]) return `mkdir: ${name}: File o directory già esistente`;\n                        parentDir.children[name] = { type: 'directory', children: {} };\n                        saveState();\n                        return '';\n                    } else {\n                        return `mkdir: Percorso non valido`;\n                    }\n                }\n            },\n            'touch': {\n                description: 'Crea un nuovo file vuoto.',\n                execute: (args) => {\n                    if (args.length === 0) return 'Uso: touch <nome_file>';\n                    const path = resolvePath(args[0]);\n                    const parts = path.split('/').filter(p => p);\n                    const name = parts.pop();\n                    const parentDir = getPathObject('/' + parts.join('/'));\n                    if (parentDir && parentDir.type === 'directory') {\n                        if (parentDir.children[name]) return ''; // File exists, do nothing\n                        parentDir.children[name] = { type: 'file', content: '' };\n                        saveState();\n                        return '';\n                    } else {\n                        return `touch: Percorso non valido`;\n                    }\n                }\n            },\n            'rm': {\n                description: 'Rimuove un file o una directory.',\n                execute: (args) => {\n                    if (args.length === 0) return 'Uso: rm <file/directory>';\n                    const path = resolvePath(args[0]);\n                    if (path === '/') return 'rm: Impossibile rimuovere la directory root';\n                    const parts = path.split('/').filter(p => p);\n                    const name = parts.pop();\n                    const parentDir = getPathObject('/' + parts.join('/'));\n                    if (parentDir && parentDir.children[name]) {\n                        delete parentDir.children[name];\n                        saveState();\n                        return '';\n                    } else {\n                        return `rm: ${args[0]}: File o directory non trovata`;\n                    }\n                }\n            },\n            'fetch': {\n                description: 'Esegue una richiesta HTTP a un URL.',\n                async execute(args) {\n                    if (args.length === 0) return 'Uso: fetch <url>';\n                    try {\n                        // Using a CORS proxy for cross-origin requests\n                        const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(args[0])}`);\n                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n                        return await response.text();\n                    } catch (error) {\n                        return `Fetch error: ${error.message}`;
                    }\n                }\n            },\n            'type': {\n                description: 'Scrive testo con un effetto macchina da scrivere.',\n                async execute(args) {\n                    const text = args.join(' ');\n                    for (let i = 0; i < text.length; i++) {\n                        term.write(text[i]);\n                        await new Promise(resolve => setTimeout(resolve, 50));\n                    }\n                    return '';\n                }\n            },\n            'edit': {\n                description: 'Apre un semplice editor di testo per un file.',\n                execute: (args) => {\n                    if (args.length === 0) return 'Uso: edit <file>';\n                    const path = resolvePath(args[0]);\n                    let file = getPathObject(path);\n                    if (!file) {\n                        commands.touch.execute(args);\n                        file = getPathObject(path);\n                    }\n                    if (file && file.type === 'file') {\n                        isEditing = true;\n                        editingFilePath = path;\n                        editorContent = file.content;\n                        term.clear();\n                        term.write(editorContent);\n                        term.write('\\n\\n\\x1b[7m-- Ctrl+S: Salva | Ctrl+X: Esci --\\x1b[0m');\n                        onEditorSaveCallback = (content) => {\n                            file.content = content;\n                            saveState();\n                        };\n                    } else {\n                        return `edit: ${args[0]} non è un file.`;\n                    }\n                    return new Promise(() => {}); // Prevent prompt from showing\n                }\n            },\n            'js': {\n                description: 'Esegue una stringa di codice JavaScript. L\\\'input via pipe è disponibile come variabile `input`.',\n                async execute(args, input) {\n                    const codeToRun = args.join(' ');\n                    if (!codeToRun) {\n                        return 'Uso: js <codice da eseguire>';\n                    }\n                    try {\n                        // new Function() è più sicuro di eval() perché il codice viene eseguito\n                        // nello scope globale, non avendo accesso alle variabili locali di questa funzione.\n                        const func = new Function('input', codeToRun);\n                        const result = func(input);\n\n                        if (result === undefined || result === null) {\n                            return ''; // Non mostrare output per undefined/null\n                        }\n                        // Formatta l'output per una migliore leggibilità\n                        if (typeof result === 'object') {\n                            return JSON.stringify(result, null, 2);\n                        }\n                        return String(result);\n                    } catch (e) {\n                        return `\\x1b[31mErrore: ${e.message}\\x1b[0m`;\n                    }\n                }\n            }\n        };\n\n        const executeCommand = async (line) => {\n            const pipelines = line.split('|').map(p => p.trim());\n            let input = undefined;\n\n            for (let i = 0; i < pipelines.length; i++) {\n                let commandPart = pipelines[i];\n                let outputRedirect = null;\n                let append = false;\n\n                if (commandPart.includes('>>')) {\n                    [commandPart, outputRedirect] = commandPart.split('>>').map(s => s.trim());\n                    append = true;\n                } else if (commandPart.includes('>')) {\n                    [commandPart, outputRedirect] = commandPart.split('>').map(s => s.trim());\n                }\n\n                const [command, ...args] = commandPart.split(' ').filter(c => c);\n                if (commands[command]) {\n                    try {\n                        let output = await commands[command].execute(args, input);\n                        if (outputRedirect) {\n                            const filePath = resolvePath(outputRedirect);\n                            let file = getPathObject(filePath);\n                            if (!file) {\n                                await commands.touch.execute([outputRedirect]);\n                                file = getPathObject(filePath);\n                            }\n                            if (file && file.type === 'file') {\n                                file.content = append ? file.content + output : output;\n                                saveState();\n                            } else {\n                                term.writeln(`Errore: ${outputRedirect} non è un file valido.`);\n                            }\n                        } else {\n                            input = output;\n                        }\n                    } catch (error) {\n                        term.writeln(`Errore nell'esecuzione di ${command}: ${error.message}`);\n                        return;\n                    }\n                } else if (command) {\n                    term.writeln(`Comando non trovato: ${command}`);\n                    return;\n                }\n            }\n\n            if (input !== undefined && input !== '') {\n                term.writeln(input);\n            }\n        };\n\n        term.onKey(({ key, domEvent }) => {\n            if (isEditing) {\n                if (domEvent.ctrlKey && domEvent.key === 's') {\n                    domEvent.preventDefault();\n                    onEditorSaveCallback(editorContent);\n                    term.write('\\n\\x1b[32mSalvato!\\x1b[0m');\n                } else if (domEvent.ctrlKey && domEvent.key === 'x') {\n                    domEvent.preventDefault();\n                    isEditing = false;\n                    term.clear();\n                    term.write(prompt());\n                } else {\n                    switch (domEvent.key) {\n                        case 'Enter':\n                            editorContent += '\\n';\n                            term.writeln('');\n                            break;\n                        case 'Backspace':\n                            if (term.buffer.active.cursorX > 0) {\n                                editorContent = editorContent.slice(0, -1);\n                                term.write('\\b \\b');\n                            }\n                            break;\n                        default:\n                            if (!domEvent.ctrlKey && !domEvent.altKey && !domEvent.metaKey) {\n                                editorContent += key;\n                                term.write(key);\n                            }\n                    }\n                }\n                return;\n            }\n\n            switch (domEvent.key) {\n                case 'Enter':\n                    if (currentCommand.trim() !== '') {\n                        term.writeln('');\n                        executeCommand(currentCommand);\n                        commandHistory.unshift(currentCommand);\n                        if (commandHistory.length > 50) commandHistory.pop();\n                        historyIndex = -1;\n                    }\n                    currentCommand = '';\n                    term.write(prompt());\n                    break;\n                case 'Backspace':\n                    if (currentCommand.length > 0) {\n                        currentCommand = currentCommand.slice(0, -1);\n                        term.write('\\b \\b');\n                    }\n                    break;\n                case 'ArrowUp':\n                    if (historyIndex < commandHistory.length - 1) {\n                        historyIndex++;\n                        term.write('\\x1b[2K\\r' + prompt());\n                        currentCommand = commandHistory[historyIndex];\n                        term.write(currentCommand);\n                    }\n                    break;\n                case 'ArrowDown':\n                    if (historyIndex > 0) {\n                        historyIndex--;\n                        term.write('\\x1b[2K\\r' + prompt());\n                        currentCommand = commandHistory[historyIndex];\n                        term.write(currentCommand);\n                    } else {\n                        historyIndex = -1;\n                        term.write('\\x1b[2K\\r' + prompt());\n                        currentCommand = '';\n                    }\n                    break;\n                case 'Tab':\n                    domEvent.preventDefault();\n                    const matchingCommands = Object.keys(commands).filter(c => c.startsWith(currentCommand));\n                    if (matchingCommands.length === 1) {\n                        term.write('\\x1b[2K\\r' + prompt());\n                        currentCommand = matchingCommands[0];\n                        term.write(currentCommand);\n                    }\n                    break;\n                default:\n                    if (!domEvent.ctrlKey && !domEvent.altKey && !domEvent.metaKey) {\n                        currentCommand += key;\n                        term.write(key);\n                    }\n            }\n        });\n\n        async function start() {\n            loadState();\n            figlet.parseFont('Standard', await (await fetch('https://cdn.jsdelivr.net/npm/figlet@1.7.0/fonts/Standard.flf')).text());\n            const asciiArt = figlet.textSync('Lorel Axun', { font: 'Standard' });\n            term.writeln(`\\x1b[1;32m${asciiArt}\\x1b[0m`);\n            const welcomeMessage = 'Benvenuto. Digita `help` per iniziare.';\n            for (let i = 0; i < welcomeMessage.length; i++) {\n                term.write(welcomeMessage[i]);\n                await new Promise(resolve => setTimeout(resolve, 25));\n            }\n            term.writeln('');\n            term.write(prompt());\n        }\n\n        start();\n    </script>\n</body>\n</html>