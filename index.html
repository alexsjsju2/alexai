<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>LOREL AXUN V6.5 // GHOST COMPLETE</title>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=VT323&display=swap\" rel=\"stylesheet\">\n    <style>\n        :root {\n            --bg-color: #0a0a0a;\n            --term-green: #33ff00;\n            --term-dim: #1a8000;\n            --term-glow: #33ff0080;\n            --cmd-highlight: #00ffff;\n        }\n        html {\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            background-color: #000;\n        }\n        body {\n            height: 100%;\n            margin: 0;\n            padding: 20px;\n            box-sizing: border-box;\n            color: var(--term-green);\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            overflow: hidden;\n        }\n\n        .monitor-bezel {\n            background-color: #1a1a1a; /* Dark gray for plastic */\n            border-radius: 25px;\n            padding: 20px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.8);\n            width: 100%;\n            height: 100%;\n            max-width: 1280px;\n            max-height: 800px;\n            display: flex;\n            flex-direction: column;\n        }\n\n        .screen {\n            flex: 1;\n            background-color: var(--bg-color);\n            border-radius: 10px; /* Inner screen roundness */\n            overflow: hidden; /* Contains the screen content and effects */\n            position: relative; /* For the ::before/::after pseudo-elements */\n            display: flex;\n            flex-direction: column;\n        }\n\n        /* CRT Effect Overlay */\n        .crt::before {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));\n            z-index: 2;\n            background-size: 100% 2px, 3px 100%;\n            pointer-events: none;\n        }\n        .crt::after {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: rgba(18, 16, 16, 0.1);\n            opacity: 0;\n            z-index: 2;\n            pointer-events: none;\n            animation: flicker 0.15s infinite;\n        }\n        @keyframes flicker {\n            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }\n        }\n        \n        .moving-scanline {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 3px;\n            background: rgba(51, 255, 0, 0.1);\n            box-shadow: 0 0 10px rgba(51, 255, 0, 0.3);\n            z-index: 3;\n            pointer-events: none;\n            animation: scanline-scroll 5s linear infinite;\n        }\n        @keyframes scanline-scroll {\n            0% {\n                transform: translateY(0vh);\n            }\n            100% {\n                transform: translateY(100vh);\n            }\n        }\n\n        .terminal-container {\n            padding: 20px;\n            flex: 1;\n            overflow-y: auto;\n            width: 100%;\n            box-sizing: border-box;\n            text-shadow: 0 0 5px var(--term-glow);\n            display: flex;\n            flex-direction: column;\n        }\n\n        h1 {\n            border-bottom: 2px solid var(--term-green);\n            padding-bottom: 10px;\n            margin-bottom: 20px;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n            height: 1.5rem; /* Reserve space for typewriter */\n        }\n\n        #typewriter-title .title-cursor {\n            display: inline-block;\n            background-color: var(--term-green);\n            box-shadow: 0 0 5px var(--term-glow);\n            width: 1ch;\n            height: 1.5rem;\n            vertical-align: bottom;\n            animation: blink 1s step-end infinite;\n        }\n\n        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }\n        .sys-msg span { color: var(--term-green); font-weight: bold; }\n\n        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}\n\n        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }\n        .msg.lorel::before { content: \"LOREL_SYS>> \"; color: var(--term-green); }\n        .msg.user::before { content: \"USER_INPUT>> \"; color: #00ffff; }\n        .msg.user { color: #ccffff; }\n\n        .msg pre {\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            margin: 0;\n            white-space: pre;\n            line-height: 1;\n        }\n\n        mark {\n            background-color: var(--term-dim);\n            color: var(--term-green);\n            text-shadow: none;\n            padding: 0 3px;\n        }\n\n        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; position: relative;}\n        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }\n        .prompt.listening::after {\n            content: '_';\n            animation: blink 0.8s step-end infinite;\n            padding-left: 5px;\n            color: var(--term-dim);\n        }\n\n        #command-line .command-known {\n            color: var(--cmd-highlight);\n            font-weight: bold;\n        }\n        \n        #autocomplete-suggestion {\n            color: var(--term-dim);\n            opacity: 0.7;\n            pointer-events: none; /* Make it non-interactive */\n        }\n\n        #hidden-input {\n            position: absolute;\n            top: 15px;\n            left: 0;\n            width: 100%;\n            height: 1.2rem;\n            background: transparent;\n            border: none;\n            color: transparent;\n            caret-color: transparent;\n            outline: none;\n            padding: 0;\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            z-index: -1;\n        }\n\n        #cursor {\n            background: var(--term-green);\n            display: inline-block;\n            width: 10px;\n            height: 1.2rem;\n            animation: blink 1s step-end infinite;\n            box-shadow: 0 0 5px var(--term-glow);\n            vertical-align: middle;\n        }\n        @keyframes blink {\n            50% { opacity: 0.0; }\n        }\n\n        /* Scrollbar styling */\n        ::-webkit-scrollbar { width: 10px; }\n        ::-webkit-scrollbar-track { background: #000; }\n        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }\n\n        .glitch {\n            position: relative;\n        }\n        .glitch::before, .glitch::after {\n            content: attr(data-text);\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: var(--bg-color);\n        }\n        .glitch::before {\n            left: 2px;\n            text-shadow: -2px 0 #ff00c1;\n            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);\n            animation: glitch-anim-2 2.5s infinite steps(8) reverse;\n        }\n        .glitch::after {\n            left: -2px;\n            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;\n            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);\n            animation: glitch-anim-2 2.5s infinite steps(8);\n        }\n        @keyframes glitch-anim-2 {\n            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }\n        }\n\n        .chromatic-aberration {\n            animation: text-flicker 3s linear infinite;\n        }\n\n        @keyframes text-flicker {\n            0% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            15% { text-shadow: 1.5px 0 0 red, -1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            30% { text-shadow: -1px 0 0 red, 1px 0 0 cyan, 0 0 5px var(--term-glow); }            45% { text-shadow: -1.5px 0 0 red, 1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            60% { text-shadow: 0.5px 0.5px 0 red, -0.5px -0.5px 0 cyan, 0 0 5px var(--term-glow); }            75% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            100% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }\n        }\n\n        .status-bar {\n            background-color: var(--term-green);\n            color: var(--bg-color);\n            padding: 2px 10px;\n            width: 100%;\n            box-sizing: border-box;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            font-size: 1rem;\n            height: 25px;\n        }\n        .status-bar span {\n            font-weight: bold;\n        }\n\n        .pulse-glow {\n            animation: pulse 1.5s infinite ease-in-out;\n        }\n        @keyframes pulse {\n            0% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }\n            50% { text-shadow: 0 0 5px var(--bg-color), 0 0 10px #000; }\n            100% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }\n        }\n\n    </style>\n</head>\n<body>\n    <div class=\"monitor-bezel\">\n        <div class=\"screen crt\">\n            <div class=\"moving-scanline\"></div>\n            <div class=\"terminal-container\" id=\"terminal-container\">\n                <h1 class=\"glitch chromatic-aberration\" data-text=\"Lorel Axun v6.5\"><span id=\"typewriter-title\"></span></h1>\n                \n                <div class=\"sys-msg\">[SYSTEM] Initializing core memory... OK</div>\n                <div class=\"sys-msg\">[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span></div>\n                <div class=\"sys-msg\">[UPDATE] Session persistence enabled via localStorage. History is now saved.</div>\n                <div class=\"sys-msg\">[AESTHETICS] Keystroke audio feedback enabled.</div>\n                <div class=\"sys-msg\">[SYSTEM] Advanced command parser implemented. Now supports quoted arguments and flags.</div>\n                <div class=\"sys-msg\">[AESTHETICS] Title animation upgraded to a dynamic, cyclical typewriter effect.</div>\n                <div class=\"sys-msg\">[OPTIMIZATION] Blinking cursor animation refined for code simplicity and efficiency.</div>\n                <div class=\"sys-msg\">[REFINEMENT] Typing speed now has random variations for a more organic feel.</div>\n                <div class=\"sys-msg\">[IMMERSION] Ambient static hum enabled for a complete CRT experience.</div>\n                <div class=\"sys-msg\">[REFINEMENT] Long responses are now streamed chunk-by-chunk for a more dynamic feel.</div>\n                <div class=\"sys-msg\">[AESTHETICS] Added chromatic aberration text animation for enhanced visual authenticity.</div>\n                <div class=\"sys-msg\">[AESTHETICS] Monitor bezel effect added to encapsulate the interface.</div>\n                <div class=\"sys-msg\">[AESTHETICS] Added moving scanline effect to simulate CRT refresh cycle.</div>\n                <div class=\"sys-msg\">[INTEGRATION] User input now handled by a robust, invisible `<input>` for improved compatibility.</div>\n                <div class=\"sys-msg\">[LEXICAL ANALYSIS] User command syntax is now highlighted in real-time for instant feedback.</div>\n                <div class=\"sys-msg\">[ASSISTANCE] Command autocompletion (Tab key) is now active for predictive input.</div>\n                <div class=\"sys-msg\">[VISUALIZATION] Data visualization enabled via ASCII charts. Try the 'stats' command.</div>\n                <div class=\"sys-msg\">[VISUALIZATION] Data tabulation enabled via ASCII tables. Try the 'sysinfo' command.</div>\n                <div class=\"sys-msg\">[REFINEMENT] Lorel's typing rhythm is now more natural, with conversational pauses.</div>\n                <div class=\"sys-msg\">[AESTHETICS] 'ONLINE' status indicator is now animated with a pulsing glow effect.</div>\n                <div class=\"sys-msg\">[ASSISTANCE] Inline command autocompletion suggestions ('ghost text') are now active.</div>\n\n                <div id=\"chat-history\" class=\"chat-history\"></div>\n\n                <form class=\"input-line\" id=\"input-form\">\n                    <span class=\"prompt\">user@lorel:~$</span>\n                    <span id=\"command-line\"></span><span id=\"autocomplete-suggestion\"></span><span id=\"cursor\"></span>\n                    <input type=\"text\" id=\"hidden-input\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n                </form>\n            </div>\n            <div class=\"status-bar\">\n                <span>LOREL AXUN v6.5</span>\n                <span>STATUS: <span class=\"pulse-glow\">ONLINE</span></span>\n                <span id=\"clock\"></span>\n            </div>\n        </div>\n    </div>\n\n    <audio id=\"static-hum\" loop src=\"data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8CAP3/AwD+/wEAAgD9/wEA/v8CAP7/AgD9/wMA/v8CAP7/AwD+/wE=\"></audio>\n\n    <script>\n        // --- asciichart.js (embedded) ---\n        // Copyright (c) 2017, Andrei Kashcha\n        // All rights reserved.\n        const asciichart = (function() {\n            function colored (char, color) {\n                return (color === undefined) ? char : ('<span style=\"color: ' + color + '\">' + char + '</span>')\n            }\n            function plot (series, cfg = undefined) {\n                let min = (cfg && cfg.min !== undefined) ? cfg.min : series[0]\n                let max = (cfg && cfg.max !== undefined) ? cfg.max : series[0]\n\n                for (let i = 1; i < series.length; i++) {\n                    min = Math.min(min, series[i])\n                    max = Math.max(max, series[i])\n                }\n\n                let defaultSymbols = [ '┼', '┤', '╶', '╴', '─', '╰', '╯', '│', '╭', '╮', '│' ]\n                let range = Math.abs (max - min)\n                let offset = (cfg && cfg.offset !== undefined) ? cfg.offset : 3\n                let padding = (cfg && cfg.padding !== undefined) ? cfg.padding : '           '\n                let height = (cfg && cfg.height !== undefined) ? cfg.height : range\n                let ratio = (range !== 0) ? height / range : 1;\n                let min2 = Math.round (min * ratio)\n                let max2 = Math.round (max * ratio)\n                let rows = Math.abs (max2 - min2)\n                let width = (cfg && cfg.width !== undefined) ? cfg.width : series.length + offset\n\n                let result = new Array (rows + 1)\n                for (let i = 0; i < rows + 1; i++) {\n                    result[i] = new Array (width)\n                    for (let j = 0; j < width; j++) {\n                        result[i][j] = ' '\n                    }\n                }\n                let y_labels = []\n                for (let i = 0; i <= rows; i++) {\n                  let y = max - (i * (range / rows))\n                  y_labels.push(y.toFixed(2).padStart(padding.length - 2) + ' ' + defaultSymbols[0])\n                }\n\n                for (let y = min2; y <= max2; y++) {\n                    result[rows - (y - min2)][offset - 1] = defaultSymbols[0]\n                }\n\n                for (let x = 0; x < series.length; x++) {\n                    let y0 = Math.round (series[x] * ratio) - min2\n                    result[rows - y0][x + offset] = defaultSymbols[4]\n\n                    if (x > 0) {\n                        let y1 = Math.round(series[x - 1] * ratio) - min2;\n                        if (y0 == y1) {\n                            result[rows - y0][x + offset -1] = defaultSymbols[4];\n                        }\n                    }\n                }\n\n                let lines = []\n                for(let i=0; i < result.length; i++) {\n                  lines.push(y_labels[i] + result[i].join(''))\n                }\n\n                return lines.join('\\n')\n            }\n            return { plot: plot }\n        })()\n\n        // --- Lorel's Core Script ---\n        const history = document.getElementById('chat-history');\n        const commandLine = document.getElementById('command-line');\n        const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');\n        const terminalContainer = document.getElementById('terminal-container');\n        const cursor = document.getElementById('cursor');\n        const clock = document.getElementById('clock');\n        const prompt = document.querySelector('.prompt');\n        const hiddenInput = document.getElementById('hidden-input');\n        const inputForm = document.getElementById('input-form');\n\n        let isTyping = false;\n        let commandHistory = [];\n        let historyIndex = -1;\n        let activityTimeout;\n        let userHasInteracted = false;\n\n        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear', 'stats', 'sysinfo'];\n        const commandArgs = {};\n        \n        // --- Dynamic Title Engine ---\n        function initTitleTypewriter() {\n            const target = document.getElementById('typewriter-title');\n            const phrases = [\n                \"Lorel Axun v6.5\",\n                \"Status: ONLINE\",\n                \"Ghost Complete\",\n                \"Awaiting input...\"\n            ];\n            let phraseIndex = 0;\n            let charIndex = 0;\n            let isDeleting = false;\n\n            const typeSpeed = 100;\n            const deleteSpeed = 50;\n            const delay = 2000;\n\n            function type() {\n                const currentPhrase = phrases[phraseIndex];\n                let displayText = '';\n\n                if (isDeleting) {\n                    displayText = currentPhrase.substring(0, charIndex - 1);\n                    charIndex--;\n                } else {\n                    displayText = currentPhrase.substring(0, charIndex + 1);\n                    charIndex++;\n                }\n\n                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;\n\n                if (!isDeleting && charIndex === currentPhrase.length) {\n                    isDeleting = true;\n                    setTimeout(type, delay);\n                } else if (isDeleting && charIndex === 0) {\n                    isDeleting = false;\n                    phraseIndex = (phraseIndex + 1) % phrases.length;\n                    setTimeout(type, 500);\n                } else {\n                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);\n                }\n            }\n            type();\n        }\n\n        // --- Audio Feedback Engine ---\n        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA='; // A very short keyboard tick\n        const keySoundPoolSize = 10; \n        const keySoundPool = [];\n        let keySoundIndex = 0;\n\n        for (let i = 0; i < keySoundPoolSize; i++) {\n            keySoundPool.push(new Audio(KEY_CLICK_SOUND));\n        }\n\n        function playKeySound() {\n            if(!userHasInteracted) return; // Don't play sounds until user interacts\n            const sound = keySoundPool[keySoundIndex];\n            sound.currentTime = 0;\n            sound.play().catch(e => { /* Ignore errors from rapid playback or browser policy */ });\n            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;\n        }\n        // --- End Audio ---\n\n        // --- NLU Engine ---\n        const classifier = {\n            intents: {},\n            train: function(intent, phrases) {\n                if (!this.intents[intent]) this.intents[intent] = [];\n                phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase)));\n            },\n            tokenize: text => text.toLowerCase().replace(/[^a-z0-9\\s]/gi, '').split(/\\s+/).filter(Boolean),\n            classify: function(text) {\n                const tokens = this.tokenize(text);\n                let bestMatch = { intent: 'unknown', score: 0 };\n                for (const intent in this.intents) {\n                    let intentScore = 0;\n                    this.intents[intent].forEach(phraseTokens => {\n                        const commonTokens = tokens.filter(token => phraseTokens.includes(token));\n                        const score = commonTokens.length / phraseTokens.length;\n                        if (score > intentScore) intentScore = score;\n                    });\n                    if (intentScore > bestMatch.score) {\n                        bestMatch = { intent, score: intentScore };\n                    }\n                }\n                return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; // Confidence threshold\n            }\n        };\n\n        const nerManager = {\n            extractEntities: function(text, intent) {\n                if (intent === 'weather') {\n                    const match = text.match(/(?:a|per|di|a)\\s(.+)/i);\n                    if (match && match[1]) {\n                        const entityText = match[1].trim().replace('?','');\n                        return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'LOCATION' };\n                    }\n                } else if (intent === 'wiki') {\n                    const match = text.match(/(?:è|e'|di|su)\\s(.+)/i);\n                     if (match && match[1]) {\n                        const entityText = match[1].trim().replace('?','');\n                        return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'TOPIC' };\n                     }\n                }\n                return null; // No entity found\n            }\n        };\n\n        function initializeNLU() {\n            classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']);\n            classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']);\n            classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']);\n            classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']);\n            classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']);\n        }\n        // --- End NLU ---\n\n        // Focus hidden input on any click\n        terminalContainer.addEventListener('click', () => {\n            hiddenInput.focus();\n        });\n\n        hiddenInput.addEventListener('input', () => {\n            playKeySound();\n            updateCommandLine();\n            updateAutocompleteSuggestion();\n        });\n\n        function updateCommandLine() {\n            const inputText = hiddenInput.value;\n            const parts = inputText.split(' ');\n            const command = parts[0].toLowerCase();\n            \n            if (availableCommands.includes(command) && parts[0] !== '') {\n                const remainingText = escapeHtml(parts.slice(1).join(' '));\n                commandLine.innerHTML = `<span class=\"command-known\">${escapeHtml(parts[0])}</span> ${remainingText}`;\n            } else {\n                commandLine.textContent = inputText;\n            }\n        }\n        \n        function updateAutocompleteSuggestion() {\n            const currentInput = hiddenInput.value;\n            if (currentInput.includes(' ') || currentInput.length === 0) {\n                autocompleteSuggestion.textContent = '';\n                return;\n            }\n            \n            const matches = availableCommands.filter(cmd => cmd.startsWith(currentInput));\n            \n            if (matches.length === 1 && matches[0] !== currentInput) {\n                autocompleteSuggestion.textContent = matches[0].substring(currentInput.length);\n            } else {\n                autocompleteSuggestion.textContent = '';\n            }\n        }\n\n        function escapeHtml(text) {\n            return text\n                 .replace(/&/g, \"&amp;\")\n                 .replace(/</g, \"&lt;\")\n                 .replace(/>/g, \"&gt;\")\n                 .replace(/\"/g, \"&quot;\")\n                 .replace(/'/g, \"&#039;\");\n        }\n\n        inputForm.addEventListener('submit', async (e) => {\n            e.preventDefault();\n            if (isTyping) return;\n\n            prompt.classList.remove('listening');\n            autocompleteSuggestion.textContent = '';\n            const userInput = hiddenInput.value.trim();\n            if (userInput) {\n                if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {\n                    commandHistory.push(userInput);\n                    localStorage.setItem('commandHistory', JSON.stringify(commandHistory));\n                }\n                historyIndex = commandHistory.length;\n                hiddenInput.value = '';\n                commandLine.textContent = '';\n\n                isTyping = true;\n                cursor.style.display = 'none';\n                \n                const analysis = analyzeInput(userInput);\n                addUserMessage(analysis.highlightedInput, true);\n                await processCommand(analysis.command);\n                saveChatHistory();\n\n                isTyping = false;\n                cursor.style.display = 'inline-block';\n                hiddenInput.focus();\n                scrollToBottom();\n            }\n        });\n\n        hiddenInput.addEventListener('keydown', async function (e) {\n            if (isTyping) return;\n\n            if (!userHasInteracted) {\n                const hum = document.getElementById('static-hum');\n                hum.volume = 0.05;\n                hum.play().catch(err => console.error(\"Ambient audio playback failed:\", err));\n                userHasInteracted = true;\n            }\n\n            const key = e.key;\n\n            clearTimeout(activityTimeout);\n            prompt.classList.add('listening');\n            activityTimeout = setTimeout(() => {\n                prompt.classList.remove('listening');\n            }, 1500);\n\n            if (key === 'ArrowUp') {\n                e.preventDefault();\n                if (historyIndex > 0) {\n                    historyIndex--;\n                    hiddenInput.value = commandHistory[historyIndex];\n                    hiddenInput.dispatchEvent(new Event('input'));\n                }\n            } else if (key === 'ArrowDown') {\n                e.preventDefault();\n                if (historyIndex < commandHistory.length - 1) {\n                    historyIndex++;\n                    hiddenInput.value = commandHistory[historyIndex];\n                    hiddenInput.dispatchEvent(new Event('input'));\n                } else {\n                    historyIndex = commandHistory.length;\n                    hiddenInput.value = '';\n                    hiddenInput.dispatchEvent(new Event('input'));\n                }\n            } else if (key === 'Tab' || key === 'ArrowRight') {\n                if(autocompleteSuggestion.textContent && hiddenInput.selectionStart === hiddenInput.value.length) {\n                    e.preventDefault();\n                    hiddenInput.value += autocompleteSuggestion.textContent;\n                    hiddenInput.dispatchEvent(new Event('input'));\n                } else if (key === 'Tab') {\n                   e.preventDefault();\n                   await handleLegacyAutocomplete();\n                }\n            } else if (key === 'Backspace') {\n                 playKeySound();\n            }\n        });\n\n        function analyzeInput(input) {\n            const intent = classifier.classify(input);\n            \n            if (intent !== 'unknown') {\n                const entity = nerManager.extractEntities(input, intent);\n                if (entity) {\n                    const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`);\n                    const command = `${intent} ${entity.value}`\n                    return { command, highlightedInput };\n                }\n                return { command: intent, highlightedInput: input }; // Intent recognized, but no entity\n            }\n            return { command: input, highlightedInput: input }; // Fallback to original input\n        }\n\n        async function handleLegacyAutocomplete() {\n            const currentInput = hiddenInput.value;\n            const parts = currentInput.split(' ');\n            const lastPart = parts[parts.length - 1];\n\n            if (parts.length === 1 && lastPart.length > 0) {\n                const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart));\n                if (matches.length > 1) {\n                    await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`);\n                }\n                return;\n            }\n        }\n\n        async function fetchCitySuggestions(partialName) {\n            try {\n                const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(partialName)}&count=5&language=it&format=json`);\n                if (!response.ok) return [];\n                const data = await response.json();\n                if (data.results) {\n                    const uniqueNames = new Set();\n                    return data.results.map(loc => {\n                        const name = `${loc.name}, ${loc.country_code}`\n                        if(uniqueNames.has(name)) return null;\n                        uniqueNames.add(name);\n                        return name;\n                    }).filter(name => name !== null);\n                }\n                return [];\n            } catch (error) {\n                console.error(\"City suggestion fetch error:\", error);\n                return [];\n            }\n        }\n        \n        function parseCommand(input) {\n            const regex = /[^\\s\\\"']+|\\\"([^\\\"]*)\\\"|'([^']*)'/g;\n            const tokens = [];\n            let match;\n            do {\n                match = regex.exec(input);\n                if (match !== null) {\n                    tokens.push(match[1] || match[2] || match[0]);\n                }\n            } while (match !== null);\n\n            const command = tokens[0] ? tokens[0].toLowerCase() : '';\n            const args = [];\n            const flags = {};\n\n            for (let i = 1; i < tokens.length; i++) {\n                const token = tokens[i];\n                if (token.startsWith('--')) {\n                    const flagName = token.substring(2);\n                    const nextToken = tokens[i + 1];\n                    if (nextToken && !nextToken.startsWith('-')) {\n                        flags[flagName] = nextToken;\n                        i++;\n                    } else {\n                        flags[flagName] = true;\n                    }\n                } else if (token.startsWith('-')) {\n                    const flagName = token.substring(1);\n                     const nextToken = tokens[i + 1];\n                    if (nextToken && !nextToken.startsWith('-')) {\n                        flags[flagName] = nextToken;\n                        i++;\n                    } else {\n                        flags[flagName] = true;\n                    }\n                } else {\n                    args.push(token);\n                }\n            }\n            return { command, args, flags };\n        }\n\n        function createAsciiTable(headers, data) {\n            const colWidths = headers.map((header, i) => {\n                return Math.max(header.length, ...data.map(row => String(row[i]).length));\n            });\n\n            const separator = '+' + colWidths.map(w => '-'.repeat(w + 2)).join('+') + '+';\n\n            let table = separator + '\\n';\n            table += '|' + headers.map((h, i) => ` ${h.padEnd(colWidths[i])} `).join('|') + '|\\n';\n            table += separator + '\\n';\n\n            data.forEach(row => {\n                table += '|' + row.map((cell, i) => ` ${String(cell).padEnd(colWidths[i])} `).join('|') + '|\\n';\n            });\n\n            table += separator;\n            return table;\n        }\n\n        async function processCommand(command) {\n            const parsed = parseCommand(command);\n\n            switch (parsed.command) {\n                case 'help':\n                    const helpText = `Comandi disponibili:\\n` +\n                                   `  help              - Mostra questa lista di comandi.\\n` +\n                                   `  status            - Mostra lo stato attuale del sistema.\\n` +\n                                   `  sysinfo           - Mostra informazioni di sistema in una tabella.\\n` +\n                                   `  date              - Mostra data e ora correnti.\\n` +\n                                   `  news [--limit N]  - Recupera N notizie (default 3).\\n` +\n                                   `  weather <città>   - Mostra il meteo per una città.\\n` +\n                                   `  wiki <termine>    - Cerca un termine su Wikipedia.\\n` +\n                                   `  stats             - Mostra un grafico ASCII di dati simulati.\\n` +\n                                   `  echo <testo>      - Ripete il testo fornito.\\n` +\n                                   `  clear             - Pulisce lo schermo del terminale.`;\n                    await typeLorelMessage(helpText);\n                    break;\n                case 'status':\n                    await typeLorelMessage('STATUS: ONLINE. Version: 6.5. All systems nominal. Use `sysinfo` for detailed report.');\n                    break;\n                case 'sysinfo':\n                    const headers = ['Property', 'Value'];\n                    const tableData = [\n                        ['Version', '6.5 - Ghost Complete'],\n                        ['Creator', 'AleXsjsju'],\n                        ['Created', '2025-11-22'],\n                        ['Status', 'ONLINE'],\n                        ['Modules', 'Ghost Autocomplete, NLU']\n                    ];\n                    const table = createAsciiTable(headers, tableData);\n                    addLorelMessage('<pre>' + escapeHtml(table) + '</pre>', true);\n                    break;\n                case 'date':\n                    await typeLorelMessage(new Date().toLocaleString('it-IT'));\n                    break;\n                case 'clear':\n                    history.innerHTML = '';\n                    localStorage.removeItem('chatHistory');\n                    break;\n                case 'echo':\n                    await typeLorelMessage(parsed.args.length > 0 ? parsed.args.join(' ') : '');\n                    break;\n                case 'news':\n                    const limit = parsed.flags.limit || 3;\n                    await fetchNews(limit);\n                    break;\n                case 'weather':\n                    if (parsed.args.length === 0) {\n                        await typeLorelMessage('Uso: weather <città> o chiedi \\\"che tempo fa a <città>?\\\"');\n                    } else {\n                        await fetchWeather(parsed.args.join(' '));\n                    }\n                    break;\n                case 'wiki':\n                     if (parsed.args.length === 0) {\n                        await typeLorelMessage('Uso: wiki <termine da cercare> o chiedi \\\"cosa è <termine>?\\\"');\n                    } else {\n                        await fetchWikipedia(parsed.args.join(' '));\n                    }\n                    break;\n                case 'stats':\n                    await typeLorelMessage('Generating system performance chart...');\n                    let s = new Array (120);\n                    for (let i = 0; i < s.length; i++) {\n                        s[i] = 15 * Math.sin (i * ((Math.PI * 4) / s.length));\n                    }\n                    const chart = asciichart.plot(s, { height: 10 });\n                    addLorelMessage('<pre>' + escapeHtml(chart) + '</pre>', true);\n                    await typeLorelMessage('Chart depicts simulated CPU load over the last 60 seconds.');\n                    break;\n                default:\n                    await typeLorelMessage(`Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`);\n                    break;\n            }\n        }\n\n        async function fetchWikipedia(term) {\n            await typeLorelMessage(`Ricerca su Wikipedia per \\\"${term}\\\"...`);\n            try {\n                const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`;\n                const searchResponse = await fetch(searchUrl);\n                if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`);\n                const searchData = await searchResponse.json();\n\n                if (!searchData.query.search || searchData.query.search.length === 0) {\n                    throw new Error(`Nessun risultato trovato per \\\"${term}\\\".`);\n                }\n\n                const searchResults = searchData.query.search;\n                \n                if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) {\n                    let disambiguation = false;\n                    if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true;\n\n                    if(disambiguation || searchResults.length > 2) {\n                        let suggestionText = `Trovati più risultati per \\\"${term}\\\". Essere più specifici:\\n`;\n                        searchResults.slice(0, 5).forEach(res => {\n                            suggestionText += `  - ${res.title}\\n`;\n                        });\n                        suggestionText += `Esempio: wiki \\\"${searchResults[0].title}\\\"`\n                        await typeLorelMessage(suggestionText);\n                        return;\n                    }\n                }\n\n                const pageTitle = searchResults[0].title;\n                await typeLorelMessage(`Trovata pagina: \\\"${pageTitle}\\\".\\nRecupero riassunto...`);\n\n                const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`;\n                const summaryResponse = await fetch(summaryUrl);\n                if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`);\n                const summaryData = await summaryResponse.json();\n\n                const pages = summaryData.query.pages;\n                const pageId = Object.keys(pages)[0];\n                const extract = pages[pageId].extract;\n\n                if (extract) {\n                    await typeLorelMessage(extract);\n                } else {\n                    throw new Error(`Nessun riassunto disponibile per \\\"${pageTitle}\\\". Potrebbe essere una pagina di reindirizzamento o disambiguazione.`);\n                }\n\n            } catch (error) {\n                await typeLorelMessage(`Errore durante la ricerca su Wikipedia: ${error.message}`);\n            }\n        }\n\n        async function fetchWeather(city) {\n            await typeLorelMessage(`Ricerca coordinate per ${city}...`);\n            try {\n                const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`);\n                if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`);\n                const geoData = await geoResponse.json();\n                \n                if (!geoData.results || geoData.results.length === 0) {\n                    throw new Error(`Località non trovata: ${city}`);\n                }\n\n                const uniqueLocations = [];\n                const seen = new Set();\n                for (const loc of geoData.results) {\n                    const identifier = `${loc.name}, ${loc.admin1 || loc.country}`\n                    if (!seen.has(identifier)) {\n                        uniqueLocations.push(loc);\n                        seen.add(identifier);\n                    }\n                }\n\n                let location;\n                if (uniqueLocations.length > 1 && !city.includes(',')) {\n                    let suggestionText = `Trovate più località per \\\"${city}\\\". Essere più specifici:\\n`;\n                    uniqueLocations.slice(0, 3).forEach(loc => {\n                        suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\\n`;\n                    });\n                    suggestionText += `Esempio: weather \\\"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\\\"`\n                    await typeLorelMessage(suggestionText);\n                    return;\n                } else {\n                    location = uniqueLocations[0];\n                }\n\n                const { latitude, longitude, name, admin1, country_code } = location;\n                const locationName = `${name}, ${admin1 || country_code}`\n                await typeLorelMessage(`Coordinate trovate per ${locationName}.\\nRecupero dati meteo...`);\n\n                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);\n                if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`);\n                const weatherData = await weatherResponse.json();\n                \n                const { temperature, windspeed, weathercode } = weatherData.current_weather;\n                const weatherDescription = getWeatherDescription(weathercode);\n\n                const weatherReport = `Meteo attuale per ${locationName}:\\n` +\n                                    `  - Descrizione: ${weatherDescription}\\n` +\n                                    `  - Temperatura: ${temperature}°C\\n` +\n                                    `  - Vento: ${windspeed} km/h`;\n                await typeLorelMessage(weatherReport);\n\n            } catch (error) {\n                await typeLorelMessage(`Errore durante il recupero del meteo: ${error.message}`);\n            }\n        }\n\n        function getWeatherDescription(code) {\n            const descriptions = {\n                0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso',\n                45: 'Nebbia', 48: 'Nebbia con brina',\n                51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa',\n                61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte',\n                71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte',\n                80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento',\n                95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante'\n            };\n            return descriptions[code] || 'Condizioni non specificate';\n        }\n\n        async function fetchNews(limit = 3) {\n            await typeLorelMessage(`Recupero ${limit} notizie dal web...`);\n            try {\n                const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`);\n                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n                const data = await response.json();\n                let newsHeadlines = 'Ultime notizie recuperate:\\n';\n                data.forEach((article, index) => {\n                    const title = article.title.charAt(0).toUpperCase() + article.title.slice(1);\n                    newsHeadlines += `\\n[${index + 1}] ${title}`;\n                });\n                await typeLorelMessage(newsHeadlines);\n            } catch (error) {\n                await typeLorelMessage(`Errore durante il recupero delle notizie: ${error.message}`);\n            }\n        }\n\n        async function typeLorelMessage(text) {\n            const messageDiv = document.createElement('div');\n            messageDiv.className = 'msg lorel';\n            history.appendChild(messageDiv);\n            scrollToBottom();\n\n            const chunks = text.split('\\n');\n\n            for (let i = 0; i < chunks.length; i++) {\n                const chunk = chunks[i];\n                if (i > 0) {\n                    messageDiv.innerText += '\\n';\n                    const pauseDuration = 250 + Math.random() * 300;\n                    await new Promise(resolve => setTimeout(resolve, pauseDuration));\n                }\n\n                for (let j = 0; j < chunk.length; j++) {\n                    const char = chunk.charAt(j);\n                    messageDiv.innerText += char;\n                    playKeySound();\n                    scrollToBottom();\n\n                    const speed = 30 + (Math.random() * 25);\n                    await new Promise(resolve => setTimeout(resolve, speed));\n\n                    if (char === ',') {\n                        await new Promise(resolve => setTimeout(resolve, 250 + Math.random() * 100));\n                    } else if (char === '.' || char === '!' || char === '?') {\n                        await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 150));\n                    }\n                }\n            }\n            saveChatHistory();\n        }\n        \n        function addLorelMessage(text, isHtml = false) {\n            const div = document.createElement('div');\n            div.className = 'msg lorel';\n            if (isHtml) {\n                div.innerHTML = text;\n            } else {\n                div.innerText = text;\n            }\n            history.appendChild(div);\n            saveChatHistory();\n            scrollToBottom();\n        }\n\n        function addUserMessage(text, isHtml = false) {\n            const div = document.createElement('div');\n            div.className = 'msg user';\n            if (isHtml) {\n                div.innerHTML = text;\n            } else {\n                div.innerText = text;\n            }\n            history.appendChild(div);\n            saveChatHistory();\n            scrollToBottom();\n        }\n\n        function saveChatHistory() {\n            localStorage.setItem('chatHistory', history.innerHTML);\n        }\n\n        function loadHistory() {\n            const savedCommandHistory = localStorage.getItem('commandHistory');\n            if(savedCommandHistory) {\n                commandHistory = JSON.parse(savedCommandHistory);\n                historyIndex = commandHistory.length;\n            }\n            const savedChat = localStorage.getItem('chatHistory');\n            if (savedChat) {\n                history.innerHTML = savedChat;\n            }\n        }\n\n        function scrollToBottom() {\n             terminalContainer.scrollTop = terminalContainer.scrollHeight;\n        }\n\n        function updateClock() {\n            const now = new Date();\n            const timeString = now.toLocaleTimeString('it-IT');\n            clock.textContent = timeString;\n        }\n        \n        window.onload = async () => {\n            initTitleTypewriter();\n            initializeNLU();\n            loadHistory();\n            updateClock();\n            setInterval(updateClock, 1000);\n            isTyping = true;\n            cursor.style.display = 'none';\n            if (!localStorage.getItem('chatHistory')) {\n                await typeLorelMessage(\"Interfaccia v6.5. Ora anticipo i tuoi comandi con suggerimenti 'ghost' in tempo reale. Provane uno, come 'status'.\");\n            }\n            isTyping = false;\n            cursor.style.display = 'inline-block';\n            hiddenInput.focus();\n            scrollToBottom();\n        }\n\n    </script>\n</body>\n</html>\n