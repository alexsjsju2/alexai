<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-w_idth, initial-scale=1.0\">\n    <title>LOREL AXUN V9.5 // CONTEXT MENU</title>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=VT323&display=swap\" rel=\"stylesheet\">\n    <script src=\"https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1\"></script>\n    <style>\n        :root {\n            --bg-color: #0a0a0a;\n            --term-green: #33ff00;\n            --term-dim: #1a8000;\n            --term-glow: #33ff0080;\n            --cmd-highlight: #00ffff;\n            --bios-text: #cccccc;\n            --error-red: #ff3333;\n            --dir-blue: #87cefa; /* Light Sky Blue for directories */\n            --window-bg: #111111;\n            --window-border: #222222;\n            --header-bg: var(--term-green);\n            --header-text: var(--bg-color);\n        }\n        html {\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            background-color: #000;\n        }\n        body {\n            height: 100%;\n            margin: 0;\n            padding: 20px;\n            box-sizing: border-box;\n            color: var(--term-green);\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            overflow: hidden;\n        }\n\n        .monitor-bezel {\n            background-color: #1a1a1a; /* Dark gray for plastic */\n            border-radius: 25px;\n            padding: 20px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.8);\n            width: 100%;\n            height: 100%;\n            max-width: 1280px;\n            max-height: 800px;\n            display: flex;\n            flex-direction: column;\n        }\n\n        .screen {\n            flex: 1;\n            background-color: var(--bg-color);\n            border-radius: 10px; /* Inner screen roundness */\n            overflow: hidden; /* Contains the screen content and effects */\n            position: relative; /* For the ::before/::after pseudo-elements */\n            display: flex;\n            flex-direction: column;\n            transition: opacity 0.5s ease-in-out;\n        }\n\n        /* CRT Effect Overlay */\n        .crt::before {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));\n            z-index: 2;\n            background-size: 100% 2px, 3px 100%;\n            pointer-events: none;\n        }\n        .crt::after {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: rgba(18, 16, 16, 0.1);\n            opacity: 0;\n            z-index: 2;\n            pointer-events: none;\n            animation: flicker 0.15s infinite;\n        }\n        @keyframes flicker {\n            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }\n        }\n        \n        .moving-scanline {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 3px;\n            background: rgba(51, 255, 0, 0.1);\n            box-shadow: 0 0 10px rgba(51, 255, 0, 0.3);\n            z-index: 3;\n            pointer-events: none;\n            animation: scanline-scroll 5s linear infinite;\n        }\n        @keyframes scanline-scroll {\n            0% {\n                transform: translateY(0vh);\n            }\n            100% {\n                transform: translateY(100vh);\n            }\n        }\n\n        #desktop {\n            width: 100%;\n            height: calc(100% - 30px); /* Leave space for taskbar */\n            position: relative;\n        }\n        \n        .window {\n            position: absolute;\n            background: var(--window-bg);\n            border: 2px solid var(--window-border);\n            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 10px var(--term-glow);\n            display: flex;\n            flex-direction: column;\n            z-index: 100;\n            resize: both;\n            overflow: auto;\n            min-width: 200px; /* Prevent shrinking too much */\n            min-height: 100px; /* Prevent shrinking too much */\n        }\n        \n        .window-header {\n            background: var(--header-bg);\n            color: var(--header-text);\n            padding: 3px 8px;\n            font-weight: bold;\n            cursor: move;\n            user-select: none;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            height: 25px;\n            box-sizing: border-box;\n            flex-shrink: 0; /* Prevent header from shrinking */\n        }\n        \n        .window-title { white-space: pre; }\n        \n        .window-controls span {\n            display: inline-block;\n            width: 15px;\n            height: 15px;\n            text-align: center;\n            line-height: 15px;\n            margin-left: 5px;\n            border: 1px solid var(--header-text);\n            cursor: pointer;\n        }\n        .window-controls span:hover { background: rgba(0,0,0,0.2); }\n\n        .window-content {\n            flex: 1;\n            display: flex;\n            flex-direction: column;\n            overflow: hidden;\n        }\n        \n        .terminal-container {\n            padding: 10px;\n            flex: 1;\n            overflow-y: auto;\n            width: 100%;\n            box-sizing: border-box;\n            text-shadow: 0 0 5px var(--term-glow);\n            display: flex;\n            flex-direction: column;\n        }\n\n        h1 {\n            border-bottom: 2px solid var(--term-green);\n            padding-bottom: 10px;\n            margin-bottom: 20px;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n            height: 1.5rem; /* Reserve space for typewriter */\n        }\n\n        #typewriter-title .title-cursor {\n            display: inline-block;\n            background-color: var(--term-green);\n            box-shadow: 0 0 5px var(--term-glow);\n            width: 1ch;\n            height: 1.5rem;\n            vertical-align: bottom;\n            animation: blink 1s step-end infinite;\n        }\n\n        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }\n        .sys-msg span { color: var(--term-green); font-weight: bold; }\n\n        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}\n        #initial-messages { display: flex; flex-direction: column; gap: 0px; margin-bottom:10px; }\n\n        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }\n        .msg.lorel::before { content: \"LOREL_SYS>> \"; color: var(--term-green); }\n        .msg.user::before { content: \"USER_INPUT>> \"; color: #00ffff; }\n        .msg.user { color: #ccffff; }\n\n        .msg pre {\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            margin: 0;\n            white-space: pre-wrap;\n            line-height: 1.2;\n        }\n        .msg .fs-dir { color: var(--dir-blue); font-weight: bold; }\n\n        mark {\n            background-color: var(--term-dim);\n            color: var(--term-green);\n            text-shadow: none;\n            padding: 0 3px;\n        }\n\n        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; position: relative;}\n        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }\n        .prompt.listening::after {\n            content: '_';\n            animation: blink 0.8s step-end infinite;\n            padding-left: 5px;\n            color: var(--term-dim);\n        }\n\n        #command-line .command-known {\n            color: var(--cmd-highlight);\n            font-weight: bold;\n        }\n        \n        #autocomplete-suggestion {\n            color: var(--term-dim);\n            opacity: 0.7;\n            pointer-events: none; /* Make it non-interactive */\n        }\n\n        #hidden-input {\n            position: absolute;\n            top: 15px;\n            left: 0;\n            width: 100%;\n            height: 1.2rem;\n            background: transparent;\n            border: none;\n            color: transparent;\n            caret-color: transparent;\n            outline: none;\n            padding: 0;\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            z-index: -1;\n        }\n\n        #cursor {\n            background: var(--term-green);\n            display: inline-block;\n            width: 10px;\n            height: 1.2rem;\n            animation: blink 1s step-end infinite;\n            box-shadow: 0 0 5px var(--term-glow);\n            vertical-align: middle;\n        }\n        @keyframes blink {\n            50% { opacity: 0.0; }\n        }\n\n        /* Scrollbar styling */\n        ::-webkit-scrollbar { width: 10px; }\n        ::-webkit-scrollbar-track { background: #000; }\n        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }\n\n        .glitch {\n            position: relative;\n        }\n        .glitch::before, .glitch::after {\n            content: attr(data-text);\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: var(--bg-color);\n        }\n        .glitch::before {\n            left: 2px;\n            text-shadow: -2px 0 #ff00c1;\n            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);\n            animation: glitch-anim-2 2.5s infinite steps(8) reverse;\n        }\n        .glitch::after {\n            left: -2px;\n            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;\n            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);\n            animation: glitch-anim-2 2.5s infinite steps(8);\n        }\n        @keyframes glitch-anim-2 {\n            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }\n        }\n\n        .chromatic-aberration {\n            animation: text-flicker 3s linear infinite;\n        }\n\n        @keyframes text-flicker {\n            0% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            15% { text-shadow: 1.5px 0 0 red, -1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            30% { text-shadow: -1px 0 0 red, 1px 0 0 cyan, 0 0 5px var(--term-glow); }            45% { text-shadow: -1.5px 0 0 red, 1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            60% { text-shadow: 0.5px 0.5px 0 red, -0.5px -0.5px 0 cyan, 0 0 5px var(--term-glow); }            75% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            100% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }\n        }\n\n        .status-bar {\n            background-color: var(--term-green);\n            color: var(--bg-color);\n            padding: 2px 10px;\n            width: 100%;\n            box-sizing: border-box;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            font-size: 1rem;\n            height: 25px;\n        }\n        .status-bar span {\n            font-weight: bold;\n        }\n\n        .pulse-glow {\n            animation: pulse 1.5s infinite ease-in-out;\n        }\n        @keyframes pulse {\n            0% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }            50% { text-shadow: 0 0 5px var(--bg-color), 0 0 10px #000; }            100% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }\n        }\n\n        #bios-overlay, #boot-logo-overlay, #login-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: #000;\n            font-family: 'VT323', monospace;\n            padding: 20px;\n            box-sizing: border-box;\n            display: none;\n            white-space: pre;\n            align-items: center;\n            justify-content: center;\n            flex-direction: column;\n            z-index: 10000;\n        }\n        #bios-overlay {\n             color: var(--bios-text);\n             align-items: flex-start;\n             justify-content: flex-start;\n        }\n        #boot-logo-overlay {\n            z-index: 9999;\n        }\n        #boot-logo-overlay pre {\n            color: var(--term-green);\n            font-size: 1.5rem;\n            text-shadow: 0 0 10px var(--term-glow);\n            animation: logo-fade-glitch 3.5s ease-in-out forwards;\n            line-height: 1.2;\n            text-align: center;\n        }\n        @keyframes logo-fade-glitch {\n            0% { opacity: 0; transform: translateY(10px); }            10% { opacity: 1; transform: translateY(0); }            20% { text-shadow: 0 0 15px var(--term-glow), 2px 0 red, -2px 0 cyan; }            21% { text-shadow: 0 0 10px var(--term-glow); }            80% { opacity: 1; }            100% { opacity: 0; }\n        }\n\n        #login-overlay {\n            z-index: 9998;\n            font-size: 1.5rem;\n            color: var(--term-green);\n            text-shadow: 0 0 5px var(--term-glow);\n        }\n        .login-box {\n            border: 2px solid var(--term-green);\n            padding: 2rem 4rem;\n            box-shadow: 0 0 15px var(--term-glow) inset;\n        }\n        .login-prompt {\n            display: flex;\n            align-items: center;\n            margin: 1rem 0;\n        }\n        .login-cursor {\n             display: inline-block;\n            background-color: var(--term-green);\n            box-shadow: 0 0 5px var(--term-glow);\n            width: 1ch;\n            height: 1.5rem;\n            vertical-align: bottom;\n            animation: blink 1s step-end infinite;\n            margin-left: 5px;\n        }\n        #login-error-message {\n            color: var(--error-red);\n            text-shadow: 0 0 5px var(--error-red);\n            height: 1.5rem;\n            margin-top: 1rem;\n            text-align: center;\n            animation: error-flicker 0.2s infinite;\n        }\n        @keyframes error-flicker {\n            50% { opacity: 0.7; }\n        }\n\n        #editor-textarea {\n            background: transparent;\n            border: none;\n            color: var(--term-green);\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            padding: 10px;\n            resize: none;\n            outline: none;\n            text-shadow: 0 0 5px var(--term-glow);\n            width: 100%;\n            height: 100%;\n            box-sizing: border-box;\n        }\n        #top-content {\n            padding: 10px;\n            overflow: hidden;\n            white-space: pre;\n            text-shadow: 0 0 5px var(--term-glow);\n            width: 100%;\n            height: 100%;\n            box-sizing: border-box;\n        }\n\n        #taskbar {\n            position: absolute;\n            bottom: 0;\n            left: 0;\n            width: 100%;\n            height: 30px;\n            background: var(--window-border);\n            border-top: 2px solid var(--term-green);\n            display: flex;\n            align-items: center;\n            padding: 0;\n            z-index: 9000;\n        }\n        #start-button {\n            background: var(--term-green);\n            color: var(--bg-color);\n            font-weight: bold;\n            padding: 0 15px;\n            height: 100%;\n            display: flex;\n            align-items: center;\n            cursor: pointer;\n            user-select: none;\n            border-right: 2px solid var(--term-green);\n        }\n        #start-button:hover { background: #8eff7f; }\n\n        #taskbar-apps {\n            flex-grow: 1;\n            display: flex;\n            align-items: center;\n            height: 100%;\n            overflow-x: auto;\n            padding: 0 5px;\n        }\n\n        #system-tray {\n            height: 100%;\n            display: flex;\n            align-items: center;\n            padding: 0 10px;\n            border-left: 2px solid var(--term-dim);\n        }\n        #taskbar-clock { font-size: 1.1rem; }\n\n        .taskbar-item {\n            background: var(--term-dim);\n            color: var(--term-green);\n            border: 1px solid var(--term-green);\n            padding: 2px 10px;\n            margin-right: 5px;\n            cursor: pointer;\n            white-space: nowrap;\n            flex-shrink: 0;\n            max-width: 150px;\n            overflow: hidden;\n            text-overflow: ellipsis;\n            transition: background 0.2s;\n        }\n        .taskbar-item:hover { background: var(--term-green); color: var(--bg-color); }\n        .taskbar-item.active { background: var(--term-green); color: var(--bg-color); font-weight: bold; }\n        .taskbar-item.minimized { background: var(--window-bg); color: var(--term-dim); border-style: dashed; }\n\n        #start-menu, #context-menu {\n            position: absolute;\n            background: var(--window-bg);\n            border: 2px solid var(--term-green);\n            box-shadow: 0 0 20px rgba(0,0,0,0.5);\n            z-index: 9999;\n            padding: 10px;\n            min-width: 250px;\n            display: none;\n        }\n        #start-menu {\n            bottom: 30px; /* Height of the taskbar */\n            left: 0;\n        }\n        .start-menu-section {\n            margin-bottom: 10px;\n        }\n        .start-menu-header {\n            color: var(--cmd-highlight);\n            border-bottom: 1px solid var(--term-dim);\n            padding-bottom: 5px;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n        .start-menu-item, .context-menu-item {\n            padding: 4px 8px;\n            cursor: pointer;\n            display: block;\n            user-select: none;\n        }\n        .start-menu-item:hover, .context-menu-item:hover {\n            background: var(--term-green);\n            color: var(--bg-color);\n        }\n\n    </style>\n</head>\n<body>\n    <div id=\"bios-overlay\"></div>\n    <div id=\"boot-logo-overlay\"></div>\n    <div id=\"login-overlay\"></div>\n\n    <div class=\"monitor-bezel\" id=\"monitor-bezel\" style=\"display: none;\">\n        <div class=\"screen crt\" id=\"main-screen\">\n            <div class=\"moving-scanline\"></div>\n            <div id=\"desktop\">\n                <!-- Windows will be injected here by JS -->\n            </div>\n            <div id=\"taskbar\">\n                <div id=\"start-button\">L.A.O.S.</div>\n                <div id=\"taskbar-apps\">\n                    <!-- Taskbar items will be injected here -->\n                </div>\n                <div id=\"system-tray\">\n                    <span id=\"taskbar-clock\"></span>\n                </div>\n            </div>\n             <div id=\"start-menu\"></div>\n             <div id=\"context-menu\"></div>\n        </div>\n    </div>\n\n    <audio id=\"static-hum\" loop src=\"data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8CAP3/AwD+/wEAAgD9/wEA/v8CAP7/AgD9/wMA/v8CAP7/AwD+/wE=\"></audio>\n    <audio id=\"startup-sound\" src=\"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8/wD7APgA+wD4AP8A+wD8AP4A/AD9AP0A/QD8AP0A/QD9APwA/QD7APwA+wD7APgA+QD5APsA+QD5APkA+QD4APgA+AD4APc=+\"></audio>\n    <audio id=\"login-success-sound\" src=\"data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVgAAAAIAAD/AP8A/wD/AP8A/wD/AAABAAEBAgADAgMDBAQEBgYIBwkKCw0ODxAREhMUFRYXGBkbHR4fICEiJCUnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW11eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAA==\"></audio>\n    <audio id=\"login-fail-sound\" src=\"data:audio/wav;base64,UklGRiwAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQgAAAAAAAD/AP4A/QD7APYA9ADwAOwA6ADlANsA1QDHAMQAwgC/ALsAsQCiAIcAfwB3AHQAcQBwAGoAZQBgAFwAVQBRAEsARgBDAEAAOQAyACsAJQAgABwAGQAVABEADgAKAAcABAAAAAAA//8=\"></audio>\n\n    <script>\n        // --- asciichart.js (embedded) ---\n        // Copyright (c) 2017, Andrei Kashcha\n        // All rights reserved.\n        const asciichart = (function() {\n            function colored (char, color) {\n                return (color === undefined) ? char : ('<span style=\"color: ' + color + '\">' + char + '</span>')\n            }\n            function plot (series, cfg = undefined) {\n                let min = (cfg && cfg.min !== undefined) ? cfg.min : series[0]\n                let max = (cfg && cfg.max !== undefined) ? cfg.max : series[0]\n\n                for (let i = 1; i < series.length; i++) {\n                    min = Math.min(min, series[i])\n                    max = Math.max(max, series[i])\n                }\n\n                let defaultSymbols = [ '┼', '┤', '╶', '╴', '─', '╰', '╯', '│', '╭', '╮', '│' ]\n                let range = Math.abs (max - min)\n                let offset = (cfg && cfg.offset !== undefined) ? cfg.offset : 3\n                let padding = (cfg && cfg.padding !== undefined) ? cfg.padding : '           '\n                let height = (cfg && cfg.height !== undefined) ? cfg.height : range\n                let ratio = (range !== 0) ? height / range : 1;\n                let min2 = Math.round (min * ratio)\n                let max2 = Math.round (max * ratio)\n                let rows = Math.abs (max2 - min2)\n                let width = (cfg && cfg.width !== undefined) ? cfg.width : series.length + offset\n\n                let result = new Array (rows + 1)\n                for (let i = 0; i < rows + 1; i++) {\n                    result[i] = new Array (width)\n                    for (let j = 0; j < width; j++) {\n                        result[i][j] = ' '\n                    }\n                }\n                let y_labels = []\n                for (let i = 0; i <= rows; i++) {\n                  let y = max - (i * (range / rows))\n                  y_labels.push(y.toFixed(2).padStart(padding.length - 2) + ' ' + defaultSymbols[0])\n                }\n\n                for (let y = min2; y <= max2; y++) {\n                    result[rows - (y - min2)][offset - 1] = defaultSymbols[0]\n                }\n\n                for (let x = 0; x < series.length; x++) {\n                    let y0 = Math.round (series[x] * ratio) - min2\n                    result[rows - y0][x + offset] = defaultSymbols[4]\n\n                    if (x > 0) {\n                        let y1 = Math.round(series[x - 1] * ratio) - min2;\n                        if (y0 == y1) {\n                            result[rows - y0][x + offset -1] = defaultSymbols[4];\n                        }\n                    }\n                }\n\n                let lines = []\n                for(let i=0; i < result.length; i++) {\n                  lines.push(y_labels[i] + result[i].join(''))\n                }\n\n                return lines.join('\\n')\n            }\n            return { plot: plot }\n        })()\n\n        // --- Lorel's Core Script ---\n        // DOM Elements\n        const desktop = document.getElementById('desktop');\n        const taskbar = document.getElementById('taskbar');\n        const taskbarApps = document.getElementById('taskbar-apps');\n        const startButton = document.getElementById('start-button');\n        const startMenu = document.getElementById('start-menu');\n        const contextMenu = document.getElementById('context-menu');\n        const taskbarClock = document.getElementById('taskbar-clock');\n        const biosOverlay = document.getElementById('bios-overlay');\n        const bootLogoOverlay = document.getElementById('boot-logo-overlay');\n        const loginOverlay = document.getElementById('login-overlay');\n        const mainScreen = document.getElementById('main-screen');\n        const monitorBezel = document.getElementById('monitor-bezel');\n\n        // State Variables\n        let commandHistory = [];\n        let historyIndex = -1;\n        let userHasInteracted = false;\n        let audioCtx = null;\n        let currentUser = 'user';\n        let cwd = '/home/admin'; // Current Working Directory\n        let loginState = { active: false, step: 'username', username: '', password: '' };\n        let editorState = { active: false, filePath: null, windowEl: null };\n        let topState = { active: false, intervalId: null, windowEl: null };\n        let processList = {};\n        let nextPid = 1;\n        let sentimentPipeline = null;\n        let textGenerationPipeline = null;\n        let installedPackages = {};\n        let highestZ = 100;\n\n        // --- Window Manager --- \n        function createDraggableWindow(id, title, width, height, top, left) {\n            highestZ++;\n            const win = document.createElement('div');\n            win.id = id;\n            win.className = 'window';\n            win.style.width = width + 'px';\n            win.style.height = height + 'px';\n            win.style.top = top + 'px';\n            win.style.left = left + 'px';\n\n            const header = document.createElement('div');\n            header.className = 'window-header';\n            header.innerHTML = `<span class=\"window-title\">${title}</span><div class=\"window-controls\"><span class=\"wc-minimize\">_</span><span class=\"wc-close\">x</span></div>`;\n\n            const content = document.createElement('div');\n            content.className = 'window-content';\n\n            win.appendChild(header);\n            win.appendChild(content);\n            desktop.appendChild(win);\n\n            // Taskbar integration\n            const taskbarItem = document.createElement('div');\n            taskbarItem.className = 'taskbar-item';\n            taskbarItem.textContent = title;\n            taskbarItem.dataset.windowId = id;\n            taskbarApps.appendChild(taskbarItem);\n\n            win.dataset.taskbarId = id; // Link window to taskbar item\n\n            function focusWindow() {\n                win.style.zIndex = ++highestZ;\n                document.querySelectorAll('.taskbar-item').forEach(item => item.classList.remove('active'));\n                taskbarItem.classList.add('active');\n                taskbarItem.classList.remove('minimized');\n            }\n            \n            focusWindow(); // Focus on creation\n\n            // Make draggable\n            let isDragging = false;\n            let offsetX, offsetY;\n\n            const onMouseDown = (e) => {\n                if (e.target.classList.contains('window-controls') || e.target.parentElement.classList.contains('window-controls')) return;\n                isDragging = true;\n                offsetX = e.clientX - win.offsetLeft;\n                offsetY = e.clientY - win.offsetTop;\n                focusWindow();\n                document.addEventListener('mousemove', onMouseMove);\n                document.addEventListener('mouseup', onMouseUp);\n            };\n\n            const onMouseMove = (e) => {\n                if (isDragging) {\n                    win.style.left = `${e.clientX - offsetX}px`;\n                    win.style.top = `${e.clientY - offsetY}px`;\n                }\n            };\n\n            const onMouseUp = () => {\n                isDragging = false;\n                document.removeEventListener('mousemove', onMouseMove);\n                document.removeEventListener('mouseup', onMouseUp);\n            };\n            \n            header.addEventListener('mousedown', onMouseDown);\n            win.addEventListener('mousedown', () => {\n                focusWindow();\n                hideStartMenu();\n                hideContextMenu();\n            });\n\n            // Window Controls\n            win.querySelector('.wc-close').onclick = () => {\n                if (win.id === 'top-window') exitTopMode();\n                else if (win.id === 'editor-window') exitEditorWithoutSaving();\n                else {\n                    win.remove();\n                    taskbarItem.remove();\n                }\n            };\n\n            win.querySelector('.wc-minimize').onclick = () => {\n                win.style.display = 'none';\n                taskbarItem.classList.add('minimized');\n                taskbarItem.classList.remove('active');\n            };\n\n            taskbarItem.onclick = () => {\n                if (win.style.display === 'none') { // Is minimized\n                    win.style.display = 'flex';\n                    focusWindow();\n                } else { // Is visible\n                    if (taskbarItem.classList.contains('active')) {\n                        win.style.display = 'none';\n                        taskbarItem.classList.add('minimized');\n                        taskbarItem.classList.remove('active');\n                    } else {\n                        focusWindow();\n                    }\n                }\n                hideStartMenu();\n                hideContextMenu();\n            };\n\n            return { windowEl: win, contentEl: content };\n        }\n\n        // --- Persistence Layer (IndexedDB) ---\n        const dbManager = (() => {\n            const DB_NAME = 'LorelAxunOS_V9';\n            const DB_VERSION = 1;\n            const FS_STORE = 'fileSystem';\n            const PKG_STORE = 'packages';\n            let db;\n\n            const init = () => {\n                return new Promise((resolve, reject) => {\n                    const request = indexedDB.open(DB_NAME, DB_VERSION);\n                    request.onupgradeneeded = (event) => {\n                        const dbInstance = event.target.result;\n                        if (!dbInstance.objectStoreNames.contains(FS_STORE)) {\n                            dbInstance.createObjectStore(FS_STORE);\n                        }\n                        if (!dbInstance.objectStoreNames.contains(PKG_STORE)) {\n                            dbInstance.createObjectStore(PKG_STORE);\n                        }\n                    };\n                    request.onsuccess = (event) => {\n                        db = event.target.result;\n                        resolve(db);\n                    };\n                    request.onerror = (event) => {\n                        console.error('IndexedDB error:', event.target.errorCode);\n                        reject(event.target.errorCode);\n                    };\n                });\n            };\n\n            const saveData = (storeName, key, data) => {\n                if (!db) return Promise.reject('DB not initialized');\n                return new Promise((resolve, reject) => {\n                    const transaction = db.transaction([storeName], 'readwrite');\n                    const store = transaction.objectStore(storeName);\n                    const request = store.put(data, key);\n                    request.onsuccess = () => resolve();\n                    request.onerror = (event) => reject(event.target.error);\n                });\n            };\n\n            const loadData = (storeName, key) => {\n                if (!db) return Promise.reject('DB not initialized');\n                return new Promise((resolve, reject) => {\n                    const transaction = db.transaction([storeName], 'readonly');\n                    const store = transaction.objectStore(storeName);\n                    const request = store.get(key);\n                    request.onsuccess = (event) => resolve(event.target.result);\n                    request.onerror = (event) => reject(event.target.error);\n                });\n            };\n\n            return {\n                init,\n                saveFileSystem: (fsData) => saveData(FS_STORE, 'mainFileSystem', fsData),\n                loadFileSystem: () => loadData(FS_STORE, 'mainFileSystem'),\n                savePackages: (pkgData) => saveData(PKG_STORE, 'installedPackages', pkgData),\n                loadPackages: () => loadData(PKG_STORE, 'installedPackages')\n            };\n        })();\n\n        // Simulated Resource Monitor\n        setInterval(() => {\n            for (const pid in processList) {\n                let process = processList[pid];\n                // Fluctuate CPU\n                let cpuChange = (Math.random() - 0.5) * 0.5;\n                process.cpu = Math.max(0.1, parseFloat(process.cpu) + cpuChange).toFixed(2);\n                // Fluctuate Memory\n                let memChange = (Math.random() - 0.5) * 0.2;\n                process.mem = Math.max(1.0, parseFloat(process.mem) + memChange).toFixed(2);\n            }\n        }, 2000); // Update every 2 seconds\n\n        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear', 'stats', 'sysinfo', 'reboot', 'whoami', 'ls', 'cd', 'cat', 'pwd', 'neofetch', 'mkdir', 'touch', 'rm', 'sentiment', 'generate', 'run', 'edit', 'ps', 'kill', 'bg', 'top', 'lax'];\n        \n        // --- Simulated File System (Default State) ---\n        const defaultFileSystem = {\n            '/': { type: 'dir', children: ['home', 'var', 'README'] },\n            '/home': { type: 'dir', children: ['admin'] },\n            '/home/admin': { type: 'dir', children: ['docs', 'welcome.txt', 'demo.js', 'fs_demo.js', 'notes.txt', 'logger.js'] },\n            '/home/admin/docs': { type: 'dir', children: ['project.txt'] },\n            '/home/admin/docs/project.txt': { type: 'file', content: 'Project Phoenix: An initiative to expand conversational AI capabilities using in-browser transformers.' },\n            '/home/admin/welcome.txt': { type: 'file', content: 'Benvenuto nel sistema L.A.O.S. v9.5!\\nQuesto è un file system persistente grazie a IndexedDB.\\nUsa il menu Start o il right-click sul desktop per scoprire i comandi.' },\n            '/home/admin/notes.txt': { type: 'file', content: 'Questa è una nota di prova.\\nPuoi modificare questo file con il comando `edit`.' },\n            '/home/admin/demo.js': { type: 'file', content: 'terminal.log(\"Ciao dal mio primo script!\");\\nfor (let i = 1; i <= 3; i++) {\\n  terminal.log(`Esecuzione ciclo: ${i}`);\\n}\\nterminal.log(\"Script completato.\");' },\n            '/home/admin/fs_demo.js': { type: 'file', content: '// Demo script for the new File System API\\nterminal.log(\"--- Esecuzione FS Demo Script ---\");\\nconst filePath = \\'welcome.txt\\';\\nconst newFilePath = \\'welcome_copy.txt\\';\\nterminal.log(`Lettura del file: ${filePath}...`);\\nfs.readFile(filePath, (err, data) => {\\n    if (err) {\\n        terminal.log(`ERRORE: ${err}`);\\n        return;\\n    }\\n    terminal.log(\\'Contenuto letto con successo.\\');\\n    const newData = data + \\'\\\\n\\\\n(Copia generata dallo script fs_demo.js)\\';\\n    terminal.log(`Scrittura del nuovo file: ${newFilePath}...`);\\n    fs.writeFile(newFilePath, newData, (err) => {\\n        if (err) {\\n            terminal.log(`ERRORE: ${err}`);\\n            return;\\n        }\\n        terminal.log(\\'Nuovo file scritto con successo! Prova a usare `cat welcome_copy.txt`\\');\\n        terminal.log(\\'--- Script completato ---\\');\\n    });\\n});' },\n            '/home/admin/logger.js': { type: 'file', content: '// Background Process Demo\\n// This script logs a message every 5 seconds.\\nterminal.log(`[BG SCRIPT] Logger started at ${new Date().toLocaleTimeString()}. Will log every 5s.`);' },\n            '/var': { type: 'dir', children: ['log'] },\n            '/var/log': { type: 'dir', children: ['system.log'] },\n            '/var/log/system.log': { type: 'file', content: 'LOG START\\n2025-11-23 10:00:01 | System boot sequence initiated.\\n2025-11-23 10:00:05 | Login protocol engaged.\\n2025-11-23 10:00:12 | User `admin` authenticated successfully.\\n2025-11-23 10:00:13 | Session started.\\nLOG END' },\n            '/README': { type: 'file', content: 'Lorel Axun Operating System (L.A.O.S.)\\nVersione: 9.5 - Context Menu\\nCreatore: AleXsjsju' },\n        };\n        let fileSystem = {};\n        \n        // --- Simulated Package Manager ---\n        const packageRepository = {\n            'cowsay': {\n                description: 'An ASCII cow says whatever you want.',\n                version: '1.0.0',\n                execute: (args) => {\n                    const what = args.join(' ') || 'Moo-ve along!';\n                    const len = what.length;\n                    const top = ' ' + '_'.repeat(len + 2);\n                    const bottom = ' ' + '-'.repeat(len + 2);\n                    const cow = `\\n ${top}\\n< ${what} >\\n ${bottom}\\n        \\\\   ^__^\\n         \\\\  (oo)\\\\_______\\n            (__)\\\\       )\\\\/\\\\\\n                ||----w |\\n                ||     ||\\n`;\n                    return cow;\n                }\n            },\n            'fortune': {\n                description: 'Displays a random fortune cookie message.',\n                version: '1.0.1',\n                execute: () => {\n                    const fortunes = [\n                        \"A beautiful, smart, and loving person will be coming into your life.\",\n                        \"A dubious friend may be an enemy in camouflage.\",\n                        \"Your success will astonish everyone.\",\n                        \"You will travel to many exotic places in your lifetime.\",\n                        \"The greatest risk is not taking one.\",\n                        \"An alien of some sort will be appearing to you shortly.\",\n                        \"Do not mistake temptation for opportunity.\"\n                    ];\n                    return fortunes[Math.floor(Math.random() * fortunes.length)];\n                }\n            }\n        };\n\n        // --- Dynamic Title Engine ---\n        function initTitleTypewriter(target) {\n            const phrases = [\n                \"Lorel Axun v9.5\",\n                \"Status: ONLINE\",\n                \"Context Menu Ready\",\n                \"Awaiting input...\"\n            ];\n            let phraseIndex = 0;\n            let charIndex = 0;\n            let isDeleting = false;\n\n            const typeSpeed = 100;\n            const deleteSpeed = 50;\n            const delay = 2000;\n\n            function type() {\n                const currentPhrase = phrases[phraseIndex];\n                let displayText = '';\n\n                if (isDeleting) {\n                    displayText = currentPhrase.substring(0, charIndex - 1);\n                    charIndex--;\n                } else {\n                    displayText = currentPhrase.substring(0, charIndex + 1);\n                    charIndex++;\n                }\n\n                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;\n\n                if (!isDeleting && charIndex === currentPhrase.length) {\n                    isDeleting = true;\n                    setTimeout(type, delay);\n                } else if (isDeleting && charIndex === 0) {\n                    isDeleting = false;\n                    phraseIndex = (phraseIndex + 1) % phrases.length;\n                    setTimeout(type, 500);\n                } else {\n                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);\n                }\n            }\n            type();\n        }\n\n        // --- Audio Feedback Engine ---\n        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';\n        const keySoundPoolSize = 10; \n        const keySoundPool = [];\n        let keySoundIndex = 0;\n\n        for (let i = 0; i < keySoundPoolSize; i++) {\n            keySoundPool.push(new Audio(KEY_CLICK_SOUND));\n        }\n\n        function playSound(id) {\n            if(!userHasInteracted) return;\n            const sound = document.getElementById(id);\n            if (sound) {\n                sound.currentTime = 0;\n                sound.play().catch(e => {});\n            }\n        }\n\n        function playKeySound() {\n            playSound('keySoundPool' + keySoundIndex);\n            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;\n        }\n\n        async function playBiosBeep() {\n            return new Promise(resolve => {\n                if (!audioCtx || !userHasInteracted) {\n                    resolve();\n                    return;\n                }\n                const oscillator = audioCtx.createOscillator();\n                const gainNode = audioCtx.createGain();\n                \n                oscillator.connect(gainNode);\n                gainNode.connect(audioCtx.destination);\n\n                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);\n                oscillator.frequency.setValueAtTime(900, audioCtx.currentTime); // High-pitched beep\n                oscillator.type = 'sine';\n\n                oscillator.start();\n                oscillator.stop(audioCtx.currentTime + 0.15); // Beep for 150ms\n                oscillator.onended = resolve;\n            });\n        }\n        \n        // --- NLU Engine ---\n        const classifier = { intents: {}, train: function(intent, phrases) { if (!this.intents[intent]) this.intents[intent] = []; phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase))); }, tokenize: text => text.toLowerCase().replace(/[^a-z0-9\\s]/gi, '').split(/\\s+/).filter(Boolean), classify: function(text) { const tokens = this.tokenize(text); let bestMatch = { intent: 'unknown', score: 0 }; for (const intent in this.intents) { let intentScore = 0; this.intents[intent].forEach(phraseTokens => { const commonTokens = tokens.filter(token => phraseTokens.includes(token)); const score = commonTokens.length / phraseTokens.length; if (score > intentScore) intentScore = score; }); if (intentScore > bestMatch.score) { bestMatch = { intent, score: intentScore }; } } return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; } };\n        const nerManager = { extractEntities: function(text, intent) { if (intent === 'weather') { const match = text.match(/(?:a|per|di|a)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'LOCATION' }; } } else if (intent === 'wiki') { const match = text.match(/(?:è|e'|di|su)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'TOPIC' }; } } return null; } };\n        function initializeNLU() { classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']); classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']); classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']); classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']); classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']); }\n\n        // --- Event Listeners ---\n        function initializeGlobalListeners() {\n            document.addEventListener('keydown', handleGlobalKeyPress, true);\n            desktop.addEventListener('contextmenu', showContextMenu);\n            document.addEventListener('click', (e) => {\n                if (!startButton.contains(e.target) && !startMenu.contains(e.target)) {\n                    hideStartMenu();\n                }\n                 if (!contextMenu.contains(e.target)) {\n                    hideContextMenu();\n                }\n            });\n        }\n\n        function handleGlobalKeyPress(e) {\n            if (e.key === 'Escape') {\n                hideStartMenu();\n                hideContextMenu();\n            }\n\n            if (editorState.active) {\n                handleEditorKeys(e);\n                return; // Stop propagation to terminal listeners\n            }\n            \n            if (!userHasInteracted) {\n                const hum = document.getElementById('static-hum');\n                hum.volume = 0.05;\n                hum.play().catch(err => {});\n                audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n                userHasInteracted = true;\n            }\n\n            if (loginState.active) {\n                handleLoginInput(e);\n            }\n        }\n\n        // --- Login Protocol ---\n        function initLoginScreen() {\n            loginState.active = true;\n            loginState.step = 'username';\n            loginState.username = '';\n            loginState.password = '';\n            currentUser = 'user'; // Reset on logout/reboot\n\n            const loginHTML = `\n                <div class=\"login-box\">\n                    <pre>L.A.O.S. v9.5 (Lorel Axun Operating System)</pre>\n                    <div class=\"login-prompt\">\n                        <span>Username: </span>\n                        <span id=\"login-user-input\"></span>\n                        <span id=\"login-user-cursor\" class=\"login-cursor\"></span>\n                    </div>\n                    <div class=\"login-prompt\">\n                        <span>Password: </span>\n                        <span id=\"login-pass-input\"></span>\n                        <span id=\"login-pass-cursor\" class=\"login-cursor\" style=\"display:none;\"></span>\n                    </div>\n                    <div id=\"login-error-message\"></div>\n                </div>\n            `;\n            loginOverlay.innerHTML = loginHTML;\n            loginOverlay.style.display = 'flex';\n        }\n\n        function handleLoginInput(e) {\n            e.preventDefault();\n            const key = e.key;\n\n            playKeySound();\n\n            if (key === 'Enter') {\n                if (loginState.step === 'username') {\n                    loginState.step = 'password';\n                    document.getElementById('login-user-cursor').style.display = 'none';\n                    document.getElementById('login-pass-cursor').style.display = 'inline-block';\n                } else if (loginState.step === 'password') {\n                    attemptLogin();\n                }\n                return;\n            }\n\n            if (key === 'Backspace') {\n                if (loginState.step === 'username' && loginState.username.length > 0) {\n                    loginState.username = loginState.username.slice(0, -1);\n                } else if (loginState.step === 'password' && loginState.password.length > 0) {\n                    loginState.password = loginState.password.slice(0, -1);\n                } \n            } else if (key.length === 1) { // Regular character input\n                if (loginState.step === 'username') {\n                    loginState.username += key;\n                } else if (loginState.step === 'password') {\n                    loginState.password += key;\n                }\n            }\n            updateLoginDisplay();\n        }\n\n        function updateLoginDisplay() {\n            document.getElementById('login-user-input').textContent = loginState.username;\n            document.getElementById('login-pass-input').textContent = '*'.repeat(loginState.password.length);\n        }\n\n        async function attemptLogin() {\n            const errorEl = document.getElementById('login-error-message');\n            errorEl.textContent = 'AUTHENTICATING...';\n            await new Promise(r => setTimeout(r, 500));\n\n            // Hardcoded credentials for simulation\n            if (loginState.username === 'admin' && loginState.password === 'axun7.3') {\n                playSound('login-success-sound');\n                errorEl.style.color = 'var(--term-green)';\n                errorEl.textContent = 'ACCESS GRANTED';\n                currentUser = loginState.username;\n                await new Promise(r => setTimeout(r, 1000));\n                loginSuccess();\n            } else {\n                playSound('login-fail-sound');\n                errorEl.style.color = 'var(--error-red)';\n                errorEl.textContent = 'ACCESS DENIED';\n                await new Promise(r => setTimeout(r, 1500));\n                initLoginScreen(); // Reset the screen\n            }\n        }\n\n        async function loginSuccess() {\n            loginState.active = false;\n            loginOverlay.style.opacity = '0';\n            await new Promise(r => setTimeout(r, 500));\n            loginOverlay.style.display = 'none';\n\n            monitorBezel.style.display = 'flex';\n            await new Promise(r => setTimeout(r, 100));\n            mainScreen.style.opacity = '1';\n            \n            await initializeTerminal();\n        }\n        \n        // --- Editor Functions ---\n        function handleEditorKeys(e) {\n            if (!editorState.active) return;\n            if (e.ctrlKey && e.key.toLowerCase() === 's') {\n                e.preventDefault();\n                saveAndExitEditor();\n            }\n            else if (e.ctrlKey && e.key.toLowerCase() === 'x') {\n                e.preventDefault();\n                exitEditorWithoutSaving();\n            }\n        }\n\n        async function enterEditorMode(filePath, content) {\n            if (editorState.active) return;\n            editorState.active = true;\n            editorState.filePath = filePath;\n\n            const { windowEl, contentEl } = createDraggableWindow('editor-window', `edit: ${filePath}`, 600, 400, 50, 250);\n            editorState.windowEl = windowEl;\n            \n            const editorTextarea = document.createElement('textarea');\n            editorTextarea.id = 'editor-textarea';\n            editorTextarea.spellcheck = false;\n            editorTextarea.value = content;\n            contentEl.appendChild(editorTextarea);\n            \n            setTimeout(() => editorTextarea.focus(), 0);\n        }\n\n        async function saveAndExitEditor() {\n            if (!editorState.active) return;\n            const editorTextarea = editorState.windowEl.querySelector('#editor-textarea');\n            const newContent = editorTextarea.value;\n            const filePath = editorState.filePath;\n            const targetPath = resolvePath(filePath);\n            const parentPath = resolvePath(targetPath + '/..');\n            const parentNode = fileSystem[parentPath];\n\n            if (parentNode && parentNode.type === 'dir') {\n                const targetNode = fileSystem[targetPath];\n                if (!targetNode) { // New file\n                     const filename = targetPath.split('/').pop();\n                     parentNode.children.push(filename);\n                     parentNode.children.sort();\n                }\n                fileSystem[targetPath] = { type: 'file', content: newContent };\n                await dbManager.saveFileSystem(fileSystem); // PERSIST\n                await exitEditorMode();\n                await printSystemOutput(`File '${filePath}' saved.`);\n            } else {\n                await exitEditorMode();\n                await printSystemOutput(`Error: Could not save file to invalid path '${filePath}'.`);\n            }\n        }\n\n        async function exitEditorWithoutSaving() {\n            const filePath = editorState.filePath;\n            await exitEditorMode();\n            await printSystemOutput(`Edit aborted. No changes were saved to '${filePath}'.`);\n        }\n\n        async function exitEditorMode() {\n            if (!editorState.active) return;\n            const taskbarItem = document.querySelector(`.taskbar-item[data-window-id=\"${editorState.windowEl.id}\"]`);\n            if (taskbarItem) taskbarItem.remove();\n            editorState.windowEl.remove();\n            editorState.active = false;\n            editorState.filePath = null;\n            editorState.windowEl = null;\n            document.getElementById('hidden-input').focus();\n        }\n\n        // --- Top (Live Monitor) Functions ---\n        function enterTopMode() {\n            if (topState.active) return;\n            topState.active = true;\n            const { windowEl, contentEl } = createDraggableWindow('top-window', 'top - Process Monitor', 650, 300, 80, 80);\n            topState.windowEl = windowEl;\n\n            const topContent = document.createElement('div');\n            topContent.id = 'top-content';\n            contentEl.appendChild(topContent);\n            \n            updateTopDisplay();\n            topState.intervalId = setInterval(updateTopDisplay, 2000); // Refresh every 2 seconds\n        }\n\n        function exitTopMode() {\n            if (!topState.active) return;\n            clearInterval(topState.intervalId);\n            topState.intervalId = null;\n            const taskbarItem = document.querySelector(`.taskbar-item[data-window-id=\"${topState.windowEl.id}\"]`);\n            if (taskbarItem) taskbarItem.remove();\n            topState.windowEl.remove();\n            topState.active = false;\n            topState.windowEl = null;\n            document.getElementById('hidden-input').focus();\n        }\n\n        function updateTopDisplay() {\n            if (!topState.active) return;\n            const topContent = topState.windowEl.querySelector('#top-content');\n\n            const processArray = Object.entries(processList);\n            const totalProcesses = processArray.length;\n            let totalCpu = 0;\n            let totalMem = 0;\n            processArray.forEach(([pid, proc]) => {\n                totalCpu += parseFloat(proc.cpu);\n                totalMem += parseFloat(proc.mem);\n            });\n\n            // Sort processes by CPU usage, descending\n            const sortedProcesses = processArray.sort((a, b) => parseFloat(b[1].cpu) - parseFloat(a[1].cpu));\n\n            let contentText = '';\n            const colHeaders = `  PID USER      CPU%   MEM(MB) UPTIME   COMMAND\\n`;\n            contentText += colHeaders;\n            contentText += '-'.repeat(colHeaders.length) + '\\n';\n\n            sortedProcesses.forEach(([pid, proc]) => {\n                const uptime = Math.floor((new Date() - proc.startTime) / 1000);\n                const line = ` ${String(pid).padStart(4)} ${currentUser.padEnd(9)} ${proc.cpu.padStart(6)} ${proc.mem.padStart(8)} ${String(uptime).padStart(6)}s  ${proc.command}\\n`;\n                contentText += line;\n            });\n\n            topContent.textContent = contentText;\n        }\n\n        // --- Terminal Functions (post-login) ---\n        async function initializeTerminal() {\n            await dbManager.init();\n            \n            const loadedFS = await dbManager.loadFileSystem();\n            if (loadedFS) {\n                fileSystem = loadedFS;\n            } else {\n                fileSystem = JSON.parse(JSON.stringify(defaultFileSystem)); // Deep copy\n                await dbManager.saveFileSystem(fileSystem);\n            }\n            \n            const loadedPkgs = await dbManager.loadPackages();\n            if (loadedPkgs) {\n                installedPackages = loadedPkgs;\n            } else {\n                installedPackages = {};\n                await dbManager.savePackages(installedPackages);\n            }\n            \n            // Create the main terminal window\n            const { windowEl, contentEl } = createDraggableWindow('terminal-window', 'L.A.O.S. Shell', 800, 500, 20, 20);\n            const terminalHTML = `\n                <div class=\"terminal-container\" id=\"terminal-container\">\n                    <h1 class=\"glitch chromatic-aberration\" data-text=\"Lorel Axun v9.5\"><span id=\"typewriter-title\"></span></h1>\n                    <div id=\"initial-messages\"></div>\n                    <div id=\"chat-history\" class=\"chat-history\"></div>\n                    <form class=\"input-line\" id=\"input-form\">\n                        <span class=\"prompt\" id=\"prompt\"></span>\n                        <span id=\"command-line\"></span><span id=\"autocomplete-suggestion\"></span><span id=\"cursor\"></span>\n                        <input type=\"text\" id=\"hidden-input\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n                    </form>\n                </div>\n                <div class=\"status-bar\">\n                    <span>LOREL AXUN v9.5</span>\n                    <span>STATUS: <span class=\"pulse-glow\">ONLINE</span></span>\n                </div>\n            `;\n            contentEl.innerHTML = terminalHTML;\n            const typewriterTitle = document.getElementById('typewriter-title');\n            \n            initTitleTypewriter(typewriterTitle);\n            initializeNLU();\n            loadHistory();\n            loadInstalledPackages();\n            displayInitialMessages();\n            updateTaskbarClock();\n            setInterval(updateTaskbarClock, 1000);\n            setupTerminalInputListeners();\n            populateStartMenu();\n\n            // Initialize base system processes\n            nextPid = 1;\n            processList = {};\n            processList[nextPid++] = { command: 'kernel_task', startTime: new Date(), cpu: (Math.random() * 0.5 + 0.1).toFixed(2), mem: (Math.random() * 50 + 25).toFixed(2) };\n            processList[nextPid++] = { command: 'window_manager', startTime: new Date(), cpu: (Math.random() * 2.0 + 0.8).toFixed(2), mem: (Math.random() * 20 + 10).toFixed(2) };\n            processList[nextPid++] = { command: `shell_session (${currentUser})`, startTime: new Date(), cpu: (Math.random() * 1.0 + 0.2).toFixed(2), mem: (Math.random() * 30 + 15).toFixed(2) };\n\n            updatePrompt();\n\n            (async () => {\n                document.isTyping = true;\n                document.getElementById('cursor').style.display = 'none';\n                if (!localStorage.getItem('motdShown_v9.5')) {\n                    await displayMOTD();\n                    localStorage.setItem('motdShown_v9.5', 'true');\n                }\n                document.isTyping = false;\n                document.getElementById('cursor').style.display = 'inline-block';\n                document.getElementById('hidden-input').focus();\n                scrollToBottom();\n            })();\n        }\n        \n        async function displayMOTD() {\n            const motdContent = `\n  ██╗      █████╗   ██████╗ ███████╗\n  ██║     ██╔══██╗ ██╔═══██╗██╔════╝\n  ██║     ███████║ ██║   ██║███████╗\n  ██║     ██╔══██║ ██║   ██║╚════██║\n  ███████╗██║  ██║ ╚██████╔╝███████║\n  ╚══════╝╚═╝  ╚═╝  ╚═════╝ ╚══════╝\n                                     \nBenvenuto in L.A.O.S. v9.5 (Context Menu)\n* NOVITÀ: Aggiunto menu contestuale (right-click) sul desktop!\n* Prova a cliccare col tasto destro sullo sfondo.\n* Digita 'help' per una lista completa dei comandi nel terminale.\n`;\n            await printSystemOutput(motdContent);\n        }\n\n        function updatePrompt() {\n             const homeDir = `/home/${currentUser}`;\n             let displayCwd = cwd;\n             if (cwd.startsWith(homeDir)) {\n                 displayCwd = '~' + cwd.substring(homeDir.length);\n             }\n             document.getElementById('prompt').innerHTML = `<span style=\"color: var(--cmd-highlight)\">${currentUser}@lorel:</span><span style=\"color: var(--dir-blue)\">${displayCwd}</span>$ `;\n        }\n\n        function setupTerminalInputListeners() {\n            const hiddenInput = document.getElementById('hidden-input');\n            const inputForm = document.getElementById('input-form');\n            const terminalContainer = document.getElementById('terminal-container');\n            \n            terminalContainer.addEventListener('click', (e) => {\n                // Prevent clicks inside the terminal from focusing away from editor\n                if (!editorState.active) hiddenInput.focus();\n            });\n            \n            hiddenInput.addEventListener('input', () => {\n                if (editorState.active) return;\n                playKeySound();\n                updateCommandLine();\n                updateAutocompleteSuggestion();\n            });\n\n            inputForm.addEventListener('submit', async (e) => {\n                e.preventDefault();\n                if (document.isTyping || editorState.active) return;\n                const prompt = document.getElementById('prompt');\n                prompt.classList.remove('listening');\n                document.getElementById('autocomplete-suggestion').textContent = '';\n                const userInput = hiddenInput.value.trim();\n                if (userInput) {\n                    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {\n                        commandHistory.push(userInput);\n                        localStorage.setItem('commandHistory', JSON.stringify(commandHistory));\n                    }\n                    historyIndex = commandHistory.length;\n                    hiddenInput.value = '';\n                    document.getElementById('command-line').textContent = '';\n\n                    document.isTyping = true;\n                    document.getElementById('cursor').style.display = 'none';\n                    \n                    const analysis = analyzeInput(userInput);\n                    addUserMessage(analysis.highlightedInput, true);\n                    await processCommandFromInput(analysis.command);\n                    saveChatHistory();\n\n                    if (parseCommand(userInput).command !== 'reboot' && !editorState.active) {\n                        document.isTyping = false;\n                        document.getElementById('cursor').style.display = 'inline-block';\n                        updatePrompt();\n                        hiddenInput.focus();\n                    }\n                    scrollToBottom();\n                }\n            });\n\n            hiddenInput.addEventListener('keydown', async function (e) {\n                if (document.isTyping || editorState.active) return;\n\n                const key = e.key;\n                const prompt = document.getElementById('prompt');\n                clearTimeout(document.activityTimeout);\n                prompt.classList.add('listening');\n                document.activityTimeout = setTimeout(() => {\n                    prompt.classList.remove('listening');\n                }, 1500);\n\n                if (key === 'ArrowUp') {\n                    e.preventDefault();\n                    if (historyIndex > 0) {\n                        historyIndex--;\n                        hiddenInput.value = commandHistory[historyIndex];\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    }\n                } else if (key === 'ArrowDown') {\n                    e.preventDefault();\n                    if (historyIndex < commandHistory.length - 1) {\n                        historyIndex++;\n                        hiddenInput.value = commandHistory[historyIndex];\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    } else {\n                        historyIndex = commandHistory.length;\n                        hiddenInput.value = '';\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    }\n                } else if (key === 'Tab' || key === 'ArrowRight') {\n                    const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');\n                    if(autocompleteSuggestion.textContent && hiddenInput.selectionStart === hiddenInput.value.length) {\n                        e.preventDefault();\n                        hiddenInput.value += autocompleteSuggestion.textContent;\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    } else if (key === 'Tab') {\n                       e.preventDefault();\n                       await handleLegacyAutocomplete();\n                    }\n                } else if (key === 'Backspace') {\n                     playKeySound();\n                }\n            });\n\n            startButton.addEventListener('click', (e) => {\n                e.stopPropagation();\n                hideContextMenu();\n                toggleStartMenu();\n            });\n        }\n        \n        function hideStartMenu() { startMenu.style.display = 'none'; }\n        function toggleStartMenu() { startMenu.style.display = startMenu.style.display === 'none' ? 'block' : 'none'; }\n        \n        function showContextMenu(e) {\n            e.preventDefault();\n            hideStartMenu();\n\n            const menuItems = [\n                { label: 'Process Monitor', action: () => enterTopMode() },\n                { label: 'System Info', action: () => showNeofetchWindow() }\n            ];\n\n            let menuHTML = '';\n            menuItems.forEach((item, index) => {\n                menuHTML += `<div class=\"context-menu-item\" data-index=\"${index}\">${item.label}</div>`;\n            });\n            contextMenu.innerHTML = menuHTML;\n\n            contextMenu.style.top = `${e.clientY}px`;\n            contextMenu.style.left = `${e.clientX}px`;\n            contextMenu.style.display = 'block';\n\n            document.querySelectorAll('.context-menu-item').forEach(el => {\n                el.onclick = () => {\n                    const index = parseInt(el.dataset.index, 10);\n                    menuItems[index].action();\n                    hideContextMenu();\n                };\n            });\n        }\n\n        function hideContextMenu() { contextMenu.style.display = 'none'; }\n        \n        async function showNeofetchWindow() {\n            const output = getNeofetchOutput();\n            const { windowEl, contentEl } = createDraggableWindow('neofetch-window', 'System Info', 500, 250, 100, 300);\n            contentEl.style.padding = '10px';\n            contentEl.style.whiteSpace = 'pre';\n            contentEl.style.overflow = 'hidden';\n            contentEl.innerHTML = output;\n        }\n        \n        function populateStartMenu() {\n            const menuCategories = {\n                'System': ['help', 'status', 'sysinfo', 'neofetch', 'date', 'whoami', 'reboot', 'clear'],\n                'File System': ['ls', 'cd', 'cat', 'pwd', 'mkdir', 'touch', 'rm'],\n                'Development': ['edit', 'run', 'bg'],\n                'AI & Web': ['news', 'weather', 'wiki', 'sentiment', 'generate'],\n                'Process Management': ['ps', 'top', 'kill'],\n                'Packages': ['lax']\n            };\n            let menuHTML = '';\n            for (const category in menuCategories) {\n                menuHTML += `<div class=\"start-menu-section\"><div class=\"start-menu-header\">${category}</div>`;\n                menuCategories[category].forEach(command => {\n                    menuHTML += `<span class=\"start-menu-item\" data-command=\"${command}\">${command}</span>`;\n                });\n                menuHTML += `</div>`;\n            }\n            startMenu.innerHTML = menuHTML;\n\n            document.querySelectorAll('.start-menu-item').forEach(item => {\n                item.addEventListener('click', () => {\n                    const command = item.dataset.command;\n                    const hiddenInput = document.getElementById('hidden-input');\n                    hiddenInput.value = command + ' ';\n                    hiddenInput.focus();\n                    updateCommandLine();\n                    hideStartMenu();\n                });\n            });\n        }\n\n        function updateCommandLine() {\n            const hiddenInput = document.getElementById('hidden-input');\n            const commandLine = document.getElementById('command-line');\n            const inputText = hiddenInput.value;\n            const parts = inputText.split(' ');\n            const command = parts[0].toLowerCase();\n            \n            if (availableCommands.includes(command) && parts[0] !== '') {\n                const remainingText = escapeHtml(parts.slice(1).join(' '));\n                commandLine.innerHTML = `<span class=\"command-known\">${escapeHtml(parts[0])}</span> ${remainingText}`;\n            } else {\n                commandLine.textContent = inputText;\n            }\n        }\n        \n        function updateAutocompleteSuggestion() {\n            const hiddenInput = document.getElementById('hidden-input');\n            const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');\n            const currentInput = hiddenInput.value;\n            if (currentInput.includes(' ') || currentInput.length === 0) {\n                autocompleteSuggestion.textContent = '';\n                return;\n            }\n            \n            const matches = availableCommands.filter(cmd => cmd.startsWith(currentInput));\n            \n            if (matches.length === 1 && matches[0] !== currentInput) {\n                autocompleteSuggestion.textContent = matches[0].substring(currentInput.length);\n            } else {\n                autocompleteSuggestion.textContent = '';\n            }\n        }\n\n        function resolvePath(path) {\n            if (!path) return cwd;\n            const homeDir = `/home/${currentUser}`;\n            if (path === '~') path = homeDir;\n            if (path.startsWith('~/')) path = `${homeDir}/${path.substring(2)}`;\n            \n            const newPathParts = path.startsWith('/') ? [] : cwd.split('/').filter(p => p);\n            const pathParts = path.split('/').filter(p => p);\n            \n            for (const part of pathParts) {\n                if (part === '.') continue;\n                if (part === '..') {\n                    if (newPathParts.length > 0) newPathParts.pop();\n                } else {\n                    newPathParts.push(part);\n                }\n            }\n            return '/' + newPathParts.join('/');\n        }\n\n        function escapeHtml(text) { return text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\"); }\n        function analyzeInput(input) { const intent = classifier.classify(input); if (intent !== 'unknown') { const entity = nerManager.extractEntities(input, intent); if (entity) { const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`); const command = `${intent} ${entity.value}`; return { command, highlightedInput }; } return { command: intent, highlightedInput: input }; } return { command: input, highlightedInput: input }; }\n        async function handleLegacyAutocomplete() { const hiddenInput = document.getElementById('hidden-input'); const currentInput = hiddenInput.value; const parts = currentInput.split(' '); const lastPart = parts[parts.length - 1]; if (parts.length === 1 && lastPart.length > 0) { const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart)); if (matches.length > 1) { await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`); } return; } }\n        \n        function parseCommandWithRedirection(input) {\n            let redirect = null;\n            let commandStr = input;\n\n            const appendMatch = input.match(/(.*)>>\\s*(.+)$/);\n            if (appendMatch) {\n                commandStr = appendMatch[1].trim();\n                redirect = { operator: '>>', target: appendMatch[2].trim() };\n            } else {\n                const overwriteMatch = input.match(/(.*)>\\s*(.+)$/);\n                if (overwriteMatch) {\n                    commandStr = overwriteMatch[1].trim();\n                    redirect = { operator: '>', target: overwriteMatch[2].trim() };\n                }\n            }\n            return { commandStr, redirect };\n        }\n\n        function parseCommand(input) { const regex = /[^\\s\"']+|\"([^\"]*)\"|'([^']*)'/g; const tokens = []; let match; do { match = regex.exec(input); if (match !== null) { tokens.push(match[1] || match[2] || match[0]); } } while (match !== null); const command = tokens[0] ? tokens[0].toLowerCase() : ''; const args = []; const flags = {}; for (let i = 1; i < tokens.length; i++) { const token = tokens[i]; if (token.startsWith('--')) { const flagName = token.substring(2); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else if (token.startsWith('-')) { const flagName = token.substring(1); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else { args.push(token); } } return { command, args, flags }; }\n        function createAsciiTable(headers, data) { const colWidths = headers.map((header, i) => { return Math.max(header.length, ...data.map(row => String(row[i]).length)); }); const separator = '+' + colWidths.map(w => '-'.repeat(w + 2)).join('+') + '+'; let table = separator + '\\n'; table += '|' + headers.map((h, i) => ` ${h.padEnd(colWidths[i])} `).join('|') + '|\\n'; table += separator + '\\n'; data.forEach(row => { table += '|' + row.map((cell, i) => ` ${String(cell).padEnd(colWidths[i])} `).join('|') + '|\\n'; }); table += separator; return table; }\n        \n        function getNeofetchOutput() {\n            const logoLines = ['██╗      █████╗', '██║     ██╔══██╗', '██║     ███████║', '██║     ██╔══██║', '███████╗██║  ██║', '╚══════╝╚═╝  ╚═╝', ''];\n            const labelColor = 'var(--term-dim)';\n            const valueColor = 'var(--term-green)';\n            const uptimeMins = Math.floor(performance.now() / 60000); \n            const uptimeString = `${uptimeMins} mins`;\n            const infoLines = [\n                `<span style=\"color: ${valueColor};\">${currentUser}@lorel</span>`,\n                '------------------',\n                `<span style=\"color: ${labelColor};\">OS</span>: L.A.O.S. v9.5 Context Menu`,\n                `<span style=\"color: ${labelColor};\">Host</span>: Simulated Web Environment`,\n                `<span style=\"color: ${labelColor};\">Kernel</span>: JS-DOM v11.25`,\n                `<span style=\"color: ${labelColor};\">Uptime</span>: ${uptimeString}`,\n                `<span style=\"color: ${labelColor};\">Shell</span>: LAX-Shell 2.1`,\n            ];\n            const logoWidth = 24;\n            let output = '';\n            const maxLines = Math.max(logoLines.length, infoLines.length);\n            for (let i = 0; i < maxLines; i++) {\n                const logoLine = (logoLines[i] || '').padEnd(logoWidth, ' ');\n                const infoLine = infoLines[i] || '';\n                output += `<span style=\"color: var(--cmd-highlight);\">${logoLine}</span>${infoLine}\\n`;\n            }\n            return '<pre>' + output + '</pre>';\n        }\n\n        async function processCommandFromInput(userInput) {\n            const { commandStr, redirect } = parseCommandWithRedirection(userInput);\n            const parsed = parseCommand(commandStr);\n\n            let outputBuffer = null;\n            let isHtmlOutput = false;\n\n            // Handle installed package commands\n            if (installedPackages[parsed.command]) {\n                try {\n                    outputBuffer = await installedPackages[parsed.command].execute(parsed.args, parsed.flags);\n                } catch (e) {\n                    outputBuffer = `[${parsed.command} ERROR] ${e.message}`;\n                }\n            } else {\n                // Handle built-in commands\n                switch (parsed.command) {\n                    case 'help':\n                        outputBuffer = `Comandi disponibili (visibili anche nel menu Start):\\n` +\n                                    `  help              - Mostra questa lista di comandi.\\n` +\n                                    `  status            - Mostra lo stato attuale del sistema.\\n` +\n                                    `  sysinfo           - Mostra informazioni di sistema in una tabella.\\n` +\n                                    `  neofetch          - Mostra info di sistema con logo ASCII.\\n` +\n                                    `  date              - Mostra data e ora correnti.\\n` +\n                                    `  whoami            - Mostra l'utente attualmente loggato.\\n` +\n                                    `  news [--limit N]  - Recupera N notizie (default 3).\\n` +\n                                    `  weather <città>   - Mostra il meteo per una città.\\n` +\n                                    `  wiki <termine>    - Cerca un termine su Wikipedia.\\n` +\n                                    `  stats             - Mostra un grafico ASCII di dati simulati.\\n` +\n                                    `  sentiment <testo> - Analizza il sentiment di una frase (ENG).\\n` +\n                                    `  generate <prompt> - Genera testo a partire da un prompt (ENG).\\n` +\n                                    `  echo <testo>      - Ripete il testo fornito.\\n` +\n                                    `  clear             - Pulisce lo schermo del terminale.\\n` +\n                                    `  reboot            - Simula un riavvio dell'interfaccia.\\n\\n` +\n                                    `File System & Scripting:\\n` +\n                                    `  ls [percorso]     - Lista i contenuti di una directory.\\n` +\n                                    `  cd <directory>    - Cambia la directory corrente.\\n` +\n                                    `  cat <file>        - Mostra il contenuto di un file.\\n` +\n                                    `  pwd               - Mostra la directory corrente.\\n` +\n                                    `  mkdir <nome>      - Crea una nuova directory.\\n` +\n                                    `  touch <nome>      - Crea un nuovo file vuoto.\\n` +\n                                    `  rm [-r] <nome>    - Rimuove un file o una directory.\\n` +\n                                    `  edit <file>       - Apre un file in un editor di testo a finestra.\\n` +\n                                    `  run <file.js>     - Esegue uno script JS (con API fs asincrona).\\n\\n` +\n                                    `Process Management:\\n` +\n                                    `  ps                - Mostra i processi in esecuzione.\\n` +\n                                    `  top               - Monitora i processi in una finestra in tempo reale.\\n` +\n                                    `  bg <file.js>      - Esegue uno script in background.\\n` +\n                                    `  kill <pid>        - Termina un processo in esecuzione.\\n\\n` +\n                                    `Ecosystem Management:\\n` +\n                                    `  lax install <pkg> - Installa un nuovo comando.\\n` +\n                                    `  lax list          - Mostra i comandi installati.\\n` +\n                                    `  lax remove <pkg>  - Rimuove un comando installato.\\n\\n` +\n                                    `I/O Redirection:\\n` +\n                                    `  > <file>          - Scrive l'output di un comando in un file (sovrascrive).\\n` +\n                                    `  >> <file>         - Aggiunge l'output di un comando a un file.\\n` +\n                                    `  (es. echo \"Ciao\" > note.txt)`;\n                        break;\n                    case 'status':\n                        outputBuffer = 'STATUS: ONLINE. Version: 9.5. All systems nominal. User: ' + currentUser;\n                        break;\n                    case 'sysinfo':\n                        const headers = ['Property', 'Value'];\n                        const tableData = [\n                            ['Version', '9.5 - Context Menu'],\n                            ['Creator', 'AleXsjsju'],\n                            ['Created', '2025-11-22'],\n                            ['Status', 'ONLINE'],\n                            ['Logged User', currentUser],\n                            ['Modules', 'Transformers.js, IndexedDB']\n                        ];\n                        outputBuffer = createAsciiTable(headers, tableData);\n                        break;\n                    case 'neofetch':\n                        outputBuffer = getNeofetchOutput();\n                        isHtmlOutput = true;\n                        break;\n                    case 'whoami': outputBuffer = currentUser; break;\n                    case 'pwd': outputBuffer = cwd; break;\n                    case 'date': outputBuffer = new Date().toLocaleString('it-IT'); break;\n                    case 'clear': document.getElementById('chat-history').innerHTML = ''; localStorage.removeItem('chatHistory'); break;\n                    case 'reboot': await runRebootSequence(); break;\n                    case 'echo': outputBuffer = parsed.args.length > 0 ? parsed.args.join(' ') : ''; break;\n                    case 'news': outputBuffer = await fetchNews(parsed.flags.limit || 3); break;\n                    case 'weather': if (parsed.args.length === 0) { outputBuffer = 'Uso: weather <città> o chiedi \"che tempo fa a <città>?\"'; } else { outputBuffer = await fetchWeather(parsed.args.join(' ')); } break;\n                    case 'wiki': if (parsed.args.length === 0) { outputBuffer = 'Uso: wiki <termine da cercare> o chiedi \"cosa è <termine>?\"'; } else { outputBuffer = await fetchWikipedia(parsed.args.join(' ')); } break;\n                    case 'sentiment': \n                        if (parsed.args.length === 0) {\n                            outputBuffer = 'Uso: sentiment <testo da analizzare in inglese>';\n                        } else {\n                            outputBuffer = await analyzeSentiment(parsed.args.join(' '));\n                        }\n                        break;\n                    case 'generate': \n                        if (parsed.args.length === 0) {\n                            outputBuffer = 'Uso: generate <testo iniziale in inglese>';\n                        } else {\n                            outputBuffer = await generateText(parsed.args.join(' '));\n                        }\n                        break;\n                    case 'ls': {\n                        const path = resolvePath(parsed.args[0]);\n                        const node = fileSystem[path];\n                        if (node && node.type === 'dir') {\n                            let output = '';\n                            node.children.forEach(childName => {\n                                const childPath = (path === '/' ? '' : path) + '/' + childName;\n                                const childNode = fileSystem[childPath];\n                                if (childNode.type === 'dir') {\n                                    output += `<span class=\"fs-dir\">${childName}/</span>  `;\n                                } else {\n                                    output += `${childName}  `;\n                                }\n                            });\n                            outputBuffer = output.trim();\n                            isHtmlOutput = true;\n                        } else {\n                            outputBuffer = `ls: cannot access '${parsed.args[0] || '.'}': No such file or directory`;\n                        }\n                        break;\n                    }\n                    case 'cd': {\n                        if (!parsed.args[0]) { \n                            cwd = `/home/${currentUser}`;
                            break;\n                        } \n                        const path = resolvePath(parsed.args[0]);\n                        const node = fileSystem[path];\n                        if (node && node.type === 'dir') {\n                            cwd = path;\n                        } else {\n                            outputBuffer = `cd: no such file or directory: ${parsed.args[0]}`;\n                        }\n                        break;\n                    }\n                    case 'cat': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = `cat: missing operand`;\n                            break;\n                        }\n                        const path = resolvePath(parsed.args[0]);\n                        const node = fileSystem[path];\n                        if (node && node.type === 'file') {\n                            await printSystemOutput(node.content);\n                            outputBuffer = null;\n                        } else if (node && node.type === 'dir') {\n                            outputBuffer = `cat: ${parsed.args[0]}: Is a directory`;\n                        } else {\n                            outputBuffer = `cat: ${parsed.args[0]}: No such file or directory`;\n                        }\n                        break;\n                    }\n                    case 'mkdir': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = `mkdir: missing operand`;\n                            break;\n                        }\n                        const newDirName = parsed.args[0];\n                        if (newDirName.includes('/')) {\n                            outputBuffer = `mkdir: cannot create directory '${newDirName}': Invalid name`;\n                            break;\n                        }\n                        const parentPath = cwd;\n                        const newDirPath = resolvePath(`${parentPath}/${newDirName}`);\n                        \n                        if (fileSystem[newDirPath]) {\n                            outputBuffer = `mkdir: cannot create directory '${newDirName}': File exists`;\n                            break;\n                        }\n\n                        const parentNode = fileSystem[parentPath];\n                        if (parentNode && parentNode.type === 'dir') {\n                            parentNode.children.push(newDirName);\n                            parentNode.children.sort();\n                            fileSystem[newDirPath] = { type: 'dir', children: [] };\n                            await dbManager.saveFileSystem(fileSystem); // PERSIST\n                        } else {\n                            outputBuffer = `mkdir: fatal error in path resolution`;\n                        }\n                        break;\n                    }\n                    case 'touch': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = `touch: missing file operand`;\n                            break;\n                        }\n                        const newFileName = parsed.args[0];\n                        if (newFileName.includes('/')) {\n                            outputBuffer = `touch: cannot create file '${newFileName}': Invalid name`;\n                            break;\n                        }\n                        const parentPath = cwd;\n                        const newFilePath = resolvePath(`${parentPath}/${newFileName}`);\n\n                        if (fileSystem[newFilePath]) { break; } \n\n                        const parentNode = fileSystem[parentPath];\n                        if (parentNode && parentNode.type === 'dir') {\n                            parentNode.children.push(newFileName);\n                            parentNode.children.sort();\n                            fileSystem[newFilePath] = { type: 'file', content: '' };\n                            await dbManager.saveFileSystem(fileSystem); // PERSIST\n                        } else {\n                            outputBuffer = `touch: fatal error in path resolution`;\n                        }\n                        break;\n                    }\n                    case 'rm': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = `rm: missing operand`;\n                            break;\n                        }\n                        const targetName = parsed.args[0];\n                        const targetPath = resolvePath(targetName);\n                        const targetNode = fileSystem[targetPath];\n\n                        if (!targetNode) {\n                            outputBuffer = `rm: cannot remove '${targetName}': No such file or directory`;\n                            break;\n                        }\n\n                        const parentPath = resolvePath(targetPath + '/..');\n                        const parentNode = fileSystem[parentPath];\n                        const isRecursive = parsed.flags.r || parsed.flags.recursive;\n\n                        if (targetNode.type === 'dir' && targetNode.children.length > 0 && !isRecursive) {\n                            outputBuffer = `rm: cannot remove '${targetName}': Directory not empty`;\n                            break;\n                        }\n                        function deleteRecursively(path) {\n                            const node = fileSystem[path];\n                            if (node.type === 'dir') {\n                                [...node.children].forEach(child => {\n                                    deleteRecursively((path === '/' ? '' : path) + '/' + child);\n                                });\n                            }\n                            delete fileSystem[path];\n                        }\n                        if (isRecursive && targetNode.type === 'dir') {\n                            deleteRecursively(targetPath);\n                        } else {\n                            delete fileSystem[targetPath];\n                        }\n                        if (parentNode && parentNode.children) {\n                            const index = parentNode.children.indexOf(targetName.split('/').pop());\n                            if (index > -1) { parentNode.children.splice(index, 1); }\n                        }\n                        await dbManager.saveFileSystem(fileSystem); // PERSIST\n                        break;\n                    }\n                    case 'edit': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = 'Uso: edit <nomefile>';\n                            break;\n                        }\n                        const filePath = parsed.args[0];\n                        const resolvedPath = resolvePath(filePath);\n                        const node = fileSystem[resolvedPath];\n                        if (node && node.type === 'dir') {\n                            outputBuffer = `edit: '${filePath}' è una directory`;\n                            break;\n                        }\n                        const content = (node && node.type === 'file') ? node.content : '';\n                        await enterEditorMode(filePath, content);\n                        break;\n                    }\n                    case 'run': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = `run: missing file operand`;\n                            break;\n                        }\n                        const filePath = resolvePath(parsed.args[0]);\n                        const fileNode = fileSystem[filePath];\n                        if (!fileNode || fileNode.type !== 'file') {\n                            outputBuffer = `run: cannot find script '${parsed.args[0]}': No such file or directory`;\n                            break;\n                        }\n                        await printSystemOutput(`[SYSTEM] Executing script: ${parsed.args[0]}`)\n                        try {\n                            const sandboxedTerminal = {\n                            log: async (message) => {\n                                    await printSystemOutput(String(message));\n                            }\n                            };\n                            const sandboxedFs = {\n                                readFile: (path, callback) => {\n                                    setTimeout(() => { // Simulate async I/O\n                                        const resolvedPath = resolvePath(path);\n                                        const node = fileSystem[resolvedPath];\n                                        if (node && node.type === 'file') {\n                                            callback(null, node.content);\n                                        } else if (node && node.type === 'dir') {\n                                            callback(`Error: '${path}' is a directory`, null);\n                                        } else {\n                                            callback(`Error: No such file '${path}'`, null);\n                                        }\n                                    }, 100);\n                                },\n                                writeFile: (path, data, callback) => {\n                                    setTimeout(() => { // Simulate async I/O\n                                        const resolvedPath = resolvePath(path);\n                                        const parentPath = resolvePath(resolvedPath + '/..');\n                                        const parentNode = fileSystem[parentPath];\n                                        \n                                        if (!parentNode || parentNode.type !== 'dir') {\n                                            callback(`Error: Cannot write to '${path}': Invalid path`);\n                                            return;\n                                        }\n                                        const targetNode = fileSystem[resolvedPath];\n                                        if (targetNode && targetNode.type === 'dir') {\n                                            callback(`Error: Cannot write to '${path}': Is a directory`);\n                                            return;\n                                        }\n\n                                        if (!targetNode) { // New file\n                                            const filename = resolvedPath.split('/').pop();\n                                            parentNode.children.push(filename);\n                                            parentNode.children.sort();\n                                        }\n\n                                        fileSystem[resolvedPath] = { type: 'file', content: String(data) };\n                                        dbManager.saveFileSystem(fileSystem); // PERSIST\n                                        callback(null);\n                                    }, 100);\n                                }\n                            };\n                            const scriptFunction = new Function('terminal', 'fs', fileNode.content);\n                            await scriptFunction(sandboxedTerminal, sandboxedFs);\n                        } catch (e) {\n                            outputBuffer = `[SCRIPT ERROR] ${e.name}: ${e.message}`;\n                        }\n                        break;\n                    }\n                    case 'bg': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = `bg: missing file operand`;\n                            break;\n                        }\n                        const filePath = resolvePath(parsed.args[0]);\n                        const fileNode = fileSystem[filePath];\n                        if (!fileNode || fileNode.type !== 'file') {\n                            outputBuffer = `bg: cannot find script '${parsed.args[0]}': No such file or directory`;\n                            break;\n                        }\n                        const pid = nextPid++;\n                        const intervalId = setInterval(() => {\n                            printSystemOutput(`[PID ${pid}] ${new Date().toLocaleTimeString()}: Script logger.js is running.`);\n                        }, 5000);\n\n                        processList[pid] = { \n                            command: `bg ${parsed.args[0]}`,\n                            intervalId: intervalId,\n                            startTime: new Date(),\n                            cpu: (Math.random() * 2.5 + 0.5).toFixed(2),\n                            mem: (Math.random() * 20 + 10).toFixed(2)\n                        };\n                        \n                        outputBuffer = `[SYSTEM] Started process with PID ${pid}.`;\n                        try {\n                            const sandboxedTerminal = { log: async (message) => await printSystemOutput(`[PID ${pid}] ${String(message)}`) };\n                            const scriptFunction = new Function('terminal', fileNode.content);\n                            await scriptFunction(sandboxedTerminal);\n                        } catch(e) { /* ignore errors for this simple demo */ }\n\n                        break;\n                    }\n                    case 'ps': {\n                        const headers = ['PID', 'USER', 'CPU%', 'MEM(MB)', 'UPTIME', 'COMMAND'];\n                        const pData = Object.entries(processList).map(([pid, process]) => {\n                            const uptime = Math.floor((new Date() - process.startTime) / 1000) + 's';\n                            return [pid, currentUser, process.cpu, process.mem, uptime, process.command];\n                        });\n\n                        if (pData.length === 0) {\n                            outputBuffer = 'No processes are running.';\n                        } else {\n                            outputBuffer = createAsciiTable(headers, pData);\n                        }\n                        break;\n                    }\n                    case 'kill': {\n                        if (parsed.args.length === 0) {\n                            outputBuffer = `kill: missing pid operand`;\n                            break;\n                        }\n                        const pidToKill = parseInt(parsed.args[0], 10);\n                        if (isNaN(pidToKill) || !processList[pidToKill]) {\n                            outputBuffer = `kill: pid ${parsed.args[0]} not found.`;\n                            break;\n                        }\n                        clearInterval(processList[pidToKill].intervalId);\n                        delete processList[pidToKill];\n                        outputBuffer = `[SYSTEM] Terminated process with PID ${pidToKill}.`;\n                        break;\n                    }\n                    case 'top': {\n                        enterTopMode();\n                        break;\n                    }\n                    case 'lax': {\n                        const subCommand = parsed.args[0];\n                        const pkgName = parsed.args[1];\n\n                        if (subCommand === 'install') {\n                            if (!pkgName) {\n                                outputBuffer = 'Uso: lax install <package>';\n                                break;\n                            }\n                            if (installedPackages[pkgName]) {\n                                outputBuffer = `Package '${pkgName}' is already installed.`;\n                                break;\n                            }\n                            if (!packageRepository[pkgName]) {\n                                outputBuffer = `Package '${pkgName}' not found in repository.`;\n                                break;\n                            }\n                            await printSystemOutput(`Downloading ${pkgName}@${packageRepository[pkgName].version}...`);\n                            await new Promise(r => setTimeout(r, 800)); // fake delay\n                            installedPackages[pkgName] = packageRepository[pkgName];\n                            availableCommands.push(pkgName);\n                            availableCommands.sort();\n                            populateStartMenu(); // Update menu with new command\n                            await dbManager.savePackages(installedPackages); // PERSIST\n                            outputBuffer = `Successfully installed '${pkgName}'. You can now use the '${pkgName}' command.`;\n                        } else if (subCommand === 'list') {\n                            const installed = Object.keys(installedPackages);\n                            if (installed.length === 0) {\n                                outputBuffer = 'No packages installed.';\n                            } else {\n                                let list = 'Installed packages:\\n';\n                                for (const pkg of installed) {\n                                    list += `  - ${pkg}@${installedPackages[pkg].version}: ${installedPackages[pkg].description}\\n`;\n                                }\n                                outputBuffer = list.trim();\n                            }\n                        } else if (subCommand === 'remove') {\n                            if (!pkgName) {\n                                outputBuffer = 'Uso: lax remove <package>';\n                                break;\n                            }\n                            if (!installedPackages[pkgName]) {\n                                outputBuffer = `Package '${pkgName}' is not installed.`;\n                                break;\n                            }\n                            delete installedPackages[pkgName];\n                            const index = availableCommands.indexOf(pkgName);\n                            if (index > -1) {\n                                availableCommands.splice(index, 1);\n                            }\n                            populateStartMenu(); // Update menu\n                            await dbManager.savePackages(installedPackages); // PERSIST\n                            outputBuffer = `Successfully removed package '${pkgName}'.`;\n                        } else {\n                            outputBuffer = 'Uso: lax [install|list|remove] <package>';\n                        }\n                        break;\n                    }\n                    case 'stats':\n                        let s = new Array(120).fill(0).map((_, i) => 15 * Math.sin(i * ((Math.PI * 4) / 120)));\n                        const chart = asciichart.plot(s, { height: 10 });\n                        outputBuffer = chart + '\\nChart depicts simulated CPU load over the last 60 seconds.';\n                        break;\n                    default:\n                        outputBuffer = `Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`;\n                        break;\n                }\n            }\n\n            if (redirect) {\n                if (outputBuffer === null || String(outputBuffer).includes('Uso:')) {\n                    await typeLorelMessage(outputBuffer || 'Comando non produce output per la redirezione.');\n                    return;\n                }\n                const targetPath = resolvePath(redirect.target);\n                const parentPath = resolvePath(targetPath + '/..');\n                const parentNode = fileSystem[parentPath];\n                if (!parentNode || parentNode.type !== 'dir') {\n                    await typeLorelMessage(`bash: ${redirect.target}: No such file or directory`);\n                    return;\n                }\n                let targetNode = fileSystem[targetPath];\n                if (targetNode && targetNode.type === 'dir') {\n                    await typeLorelMessage(`bash: ${redirect.target}: Is a directory`);\n                    return;\n                }\n                const cleanOutput = String(outputBuffer).replace(/<[^>]*>/g, '');\n                if (redirect.operator === '>') {\n                     if (!targetNode) {\n                        parentNode.children.push(targetPath.split('/').pop());\n                        parentNode.children.sort();\n                     }\n                     fileSystem[targetPath] = { type: 'file', content: cleanOutput };\n                } else if (redirect.operator === '>>') {\n                    if (!targetNode) {\n                        parentNode.children.push(targetPath.split('/').pop());\n                        parentNode.children.sort();\n                        fileSystem[targetPath] = { type: 'file', content: cleanOutput };\n                    } else {\n                        fileSystem[targetPath].content += '\\n' + cleanOutput;\n                    }\n                }\n                await dbManager.saveFileSystem(fileSystem); // PERSIST\n            } else if (outputBuffer !== null) {\n                 if (['sysinfo', 'stats', 'help', 'sentiment', 'generate', 'ps', 'lax'].includes(parsed.command) || Object.keys(installedPackages).includes(parsed.command)) {\n                    await printSystemOutput(outputBuffer);\n                 } else if (isHtmlOutput) {\n                    addLorelMessage(outputBuffer, true);\n                 } else {\n                    await typeLorelMessage(outputBuffer);\n                 }\n            }\n        }\n\n        async function runRebootSequence() {\n            Object.values(processList).forEach(p => clearInterval(p.intervalId));\n            processList = {};\n            nextPid = 1;\n            await typeLorelMessage(\"[SYSTEM] Reboot sequence initiated... Terminating all processes and shutting down.\");\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            mainScreen.style.opacity = '0';\n            monitorBezel.style.display = 'none';\n            await new Promise(resolve => setTimeout(resolve, 500));\n            desktop.innerHTML = '';\n            taskbarApps.innerHTML = '';\n\n            biosOverlay.style.display = 'flex';\n            const biosLines = [ { text: 'LorelAxun BIOS v1.2', delay: 500 }, { text: 'Copyright (c) 2025 AleXsjsju Corp.', delay: 200 }, { text: '', delay: 500 }, { text: 'Initializing Core Memory.................... ', delay: 300 }, { text: '65536 KB OK', delay: 100, append: true, action: playBiosBeep }, { text: '\\nDetecting Primary Master.................. LAX-HD-01', delay: 800 }, { text: 'Detecting Primary Slave................. None', delay: 800 }, { text: 'Detecting Secondary Master................ None', delay: 800 }, { text: 'Detecting Secondary Slave................. None', delay: 800 }, { text: '', delay: 500 }, { text: 'Checking NVRAM............................ OK', delay: 400 }, { text: 'Initializing Web-Access Layer........... OK', delay: 600 }, { text: '', delay: 1000 }, { text: 'Booting from Primary Master (LAX-HD-01)...', delay: 500 }, ];\n            for (const line of biosLines) { await new Promise(resolve => setTimeout(resolve, line.delay)); if (line.append) { biosOverlay.textContent += line.text; } else { biosOverlay.textContent += line.text + '\\n'; } if (line.action) { await line.action(); } }\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            biosOverlay.style.display = 'none';\n            biosOverlay.textContent = '';\n\n            const logo = `\\n██╗      █████╗\\n██║     ██╔══██╗\\n██║     ███████║\\n██║     ██╔══██║\\n███████╗██║  ██║\\n╚══════╝╚═╝  ╚═╝\\n            `;\n            bootLogoOverlay.innerHTML = `<pre>${escapeHtml(logo)}</pre>`;\n            bootLogoOverlay.style.display = 'flex';\n            playSound('startup-sound');\n            await new Promise(resolve => setTimeout(resolve, 3500));\n            bootLogoOverlay.style.display = 'none';\n            bootLogoOverlay.innerHTML = '';\n\n            initLoginScreen();\n        }\n\n        async function analyzeSentiment(text) {\n            try {\n                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');\n\n                if (!sentimentPipeline) {\n                    await printSystemOutput('Loading sentiment analysis model (this may take a moment on first run)...');\n                    sentimentPipeline = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finuned-sst-2-english');\n                    await printSystemOutput('Model loaded successfully.');\n                }\n                await printSystemOutput(`Analyzing text: \\\"${text}\\\"`);\n                const result = await sentimentPipeline(text);\n                return `Analysis complete:\\n` +\n                    `  - LABEL: ${result[0].label}\\n` +\n                    `  - SCORE: ${result[0].score.toFixed(4)}`;\n            } catch (error) {\n                console.error('Sentiment Analysis Error:', error);\n                return 'Error during sentiment analysis. The model may have failed to load. Check the browser console.';\n            }\n        }\n\n        async function generateText(prompt) {\n            try {\n                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');\n\n                if (!textGenerationPipeline) {\n                    await printSystemOutput('Loading text generation model (this may take a moment on first run)...');\n                    textGenerationPipeline = await pipeline('text-generation', 'Xenova/distilgpt2');\n                    await printSystemOutput('Model loaded successfully.');\n                }\n                await printSystemOutput(`Generating text from prompt: \\\"${prompt}\\\"`);\n                const result = await textGenerationPipeline(prompt, { max_new_tokens: 50 });\n                return `Generation complete:\\n\\n${result[0].generated_text}`;\n            } catch (error) {\n                console.error('Text Generation Error:', error);\n                return 'Error during text generation. The model may have failed to load. Check the browser console.';\n            }\n        }\n\n        async function fetchWikipedia(term) { let output = `Ricerca su Wikipedia per \\\"${term}\\\"...`; try { const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`; const searchResponse = await fetch(searchUrl); if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`); const searchData = await searchResponse.json(); if (!searchData.query.search || searchData.query.search.length === 0) { throw new Error(`Nessun risultato trovato per \\\"${term}\\\".`); } const searchResults = searchData.query.search; if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) { let disambiguation = false; if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true; if(disambiguation || searchResults.length > 2) { let suggestionText = `\\nTrovati più risultati per \\\"${term}\\\". Essere più specifici:\\n`; searchResults.slice(0, 5).forEach(res => { suggestionText += `  - ${res.title}\\n`; }); suggestionText += `Esempio: wiki \\\"${searchResults[0].title}\\\"`; return output + suggestionText; } } const pageTitle = searchResults[0].title; output += `\\nTrovata pagina: \\\"${pageTitle}\\\".\\nRecupero riassunto...`; const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`; const summaryResponse = await fetch(summaryUrl); if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`); const summaryData = await summaryResponse.json(); const pages = summaryData.query.pages; const pageId = Object.keys(pages)[0]; const extract = pages[pageId].extract; if (extract) { return output + `\\n${extract}`; } else { throw new Error(`Nessun riassunto disponibile per \\\"${pageTitle}\\\".`); } } catch (error) { return output + `\\nErrore durante la ricerca su Wikipedia: ${error.message}`; } }\n        async function fetchWeather(city) { let output = `Ricerca coordinate per ${city}...`; try { const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`); if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`); const geoData = await geoResponse.json(); if (!geoData.results || geoData.results.length === 0) { throw new Error(`Località non trovata: ${city}`); } const uniqueLocations = []; const seen = new Set(); for (const loc of geoData.results) { const identifier = `${loc.name}, ${loc.admin1 || loc.country}`; if (!seen.has(identifier)) { uniqueLocations.push(loc); seen.add(identifier); } } let location; if (uniqueLocations.length > 1 && !city.includes(',')) { let suggestionText = `\\nTrovate più località per \\\"${city}\\\". Essere più specifici:\\n`; uniqueLocations.slice(0, 3).forEach(loc => { suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\\n`; }); suggestionText += `Esempio: weather \\\"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\\\"`; return output + suggestionText; } else { location = uniqueLocations[0]; } const { latitude, longitude, name, admin1, country_code } = location; const locationName = `${name}, ${admin1 || country_code}`; output += `\\nCoordinate trovate per ${locationName}.\\nRecupero dati meteo...`; const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`); if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`); const weatherData = await weatherResponse.json(); const { temperature, windspeed, weathercode } = weatherData.current_weather; const weatherDescription = getWeatherDescription(weathercode); return output + `\\nMeteo attuale per ${locationName}:\\n` + `  - Descrizione: ${weatherDescription}\\n` + `  - Temperatura: ${temperature}°C\\n` + `  - Vento: ${windspeed} km/h`; } catch (error) { return output + `\\nErrore durante il recupero del meteo: ${error.message}`; } }\n        function getWeatherDescription(code) { const descriptions = { 0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso', 45: 'Nebbia', 48: 'Nebbia con brina', 51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa', 61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte', 71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte', 80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento', 95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante' }; return descriptions[code] || 'Condizioni non specificate'; }\n        async function fetchNews(limit = 3) { let output = `Recupero ${limit} notizie dal web...`; try { const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); let newsHeadlines = '\\nUltime notizie recuperate:\\n'; data.forEach((article, index) => { const title = article.title.charAt(0).toUpperCase() + article.title.slice(1); newsHeadlines += `\\n[${index + 1}] ${title}`; }); return output + newsHeadlines; } catch (error) { return output + `\\nErrore durante il recupero delle notizie: ${error.message}`; } }\n        async function typeLorelMessage(text) { const history = document.getElementById('chat-history'); const messageDiv = document.createElement('div'); messageDiv.className = 'msg lorel'; history.appendChild(messageDiv); scrollToBottom(); const chunks = text.split('\\n'); for (let i = 0; i < chunks.length; i++) { const chunk = chunks[i]; if (i > 0) { messageDiv.innerText += '\\n'; const pauseDuration = 250 + Math.random() * 300; await new Promise(resolve => setTimeout(resolve, pauseDuration)); } for (let j = 0; j < chunk.length; j++) { const char = chunk.charAt(j); messageDiv.innerText += char; playKeySound(); scrollToBottom(); const speed = 30 + (Math.random() * 25); await new Promise(resolve => setTimeout(resolve, speed)); if (char === ',') { await new Promise(resolve => setTimeout(resolve, 250 + Math.random() * 100)); } else if (char === '.' || char === '!' || char === '?') { await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 150)); } } } saveChatHistory(); }\n        async function printSystemOutput(text) { const history = document.getElementById('chat-history'); const div = document.createElement('div'); div.className = 'msg lorel'; const pre = document.createElement('pre'); div.appendChild(pre); history.appendChild(div); scrollToBottom(); const lines = String(text).split('\\n'); for (const line of lines) { pre.textContent += line + '\\n'; scrollToBottom(); await new Promise(r => setTimeout(r, 50)); } saveChatHistory(); }\n        function addLorelMessage(text, isHtml = false) { const history = document.getElementById('chat-history'); const div = document.createElement('div'); div.className = 'msg lorel'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }\n        function addUserMessage(text, isHtml = false) { const history = document.getElementById('chat-history'); const div = document.createElement('div'); div.className = 'msg user'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }\n        function saveChatHistory() { const history = document.getElementById('chat-history'); if(history) localStorage.setItem('chatHistory', history.innerHTML); }\n        function loadHistory() { const savedCommandHistory = localStorage.getItem('commandHistory'); if(savedCommandHistory) { commandHistory = JSON.parse(savedCommandHistory); historyIndex = commandHistory.length; } const savedChat = localStorage.getItem('chatHistory'); if (savedChat) { document.getElementById('chat-history').innerHTML = savedChat; } }\n        function loadInstalledPackages() { \n            for (const pkgName in installedPackages) {\n                if (!availableCommands.includes(pkgName)) {\n                    availableCommands.push(pkgName);\n                }\n            }\n            availableCommands.sort();\n         }\n        \n        function displayInitialMessages() {\n            const initialMessagesContainer = document.getElementById('initial-messages');\n            const messages = [\n                '[SYSTEM] Initializing core memory... OK',\n                '[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span>',\n                '[AI CORE] Transformers.js library integrated. New `sentiment` & `generate` commands available.',\n                '[DEVELOPMENT] Internal scripting engine loaded with sandboxed File System API.',\n                '[DEVELOPMENT] Internal text editor implemented. Use the `edit` command.',\n                '[SYSTEM] Rudimentary Process Manager loaded. Use `bg`, `ps`, and `kill` to manage background tasks.',\n                '[SYSTEM] Live Process Monitor implemented. Use `top` for a real-time view of running processes.',\n                '[SYSTEM] Rudimentary Package Manager implemented. Use `lax` to install new commands like `cowsay`.',\n                '[SYSTEM] Persistence layer active. File system and packages now stored in IndexedDB.',\n                '[SYSTEM] Window Manager active. Windows are draggable and resizable.',\n                '[SYSTEM] Taskbar active for centralized window management.',\n                '[SYSTEM] Start Menu and System Clock added to taskbar.',\n                '[SYSTEM] NEW: Context Menu (right-click) added to desktop.'\n            ];\n            let content = '';\n            messages.forEach(msg => {\n                content += `<div class=\"sys-msg\">${msg}</div>`;\n            });\n            initialMessagesContainer.innerHTML = content;\n        }\n\n        function scrollToBottom() { const term = document.getElementById('terminal-container'); if(term) term.scrollTop = term.scrollHeight; }\n        function updateTaskbarClock() { \n             const now = new Date(); \n             const timeString = now.toLocaleTimeString('it-IT'); \n             taskbarClock.textContent = timeString; \n        }\n        \n        window.onload = () => {\n            initializeGlobalListeners();\n            initLoginScreen();\n        }\n\n    </script>\n</body>\n</html>