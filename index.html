<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-w_idth, initial-scale=1.0">
    <title>LOREL AXUN V8.6 // PROCESS MANAGEMENT</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1"></script>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --term-green: #33ff00;
            --term-dim: #1a8000;
            --term-glow: #33ff0080;
            --cmd-highlight: #00ffff;
            --bios-text: #cccccc;
            --error-red: #ff3333;
            --dir-blue: #87cefa; /* Light Sky Blue for directories */
        }
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #000;
        }
        body {
            height: 100%;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: var(--term-green);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .monitor-bezel {
            background-color: #1a1a1a; /* Dark gray for plastic */
            border-radius: 25px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.8);
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
        }

        .screen {
            flex: 1;
            background-color: var(--bg-color);
            border-radius: 10px; /* Inner screen roundness */
            overflow: hidden; /* Contains the screen content and effects */
            position: relative; /* For the ::before/::after pseudo-elements */
            display: flex;
            flex-direction: column;
            transition: opacity 0.5s ease-in-out;
        }

        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        .crt::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }
        }
        
        .moving-scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: rgba(51, 255, 0, 0.1);
            box-shadow: 0 0 10px rgba(51, 255, 0, 0.3);
            z-index: 3;
            pointer-events: none;
            animation: scanline-scroll 5s linear infinite;
        }
        @keyframes scanline-scroll {
            0% {
                transform: translateY(0vh);
            }
            100% {
                transform: translateY(100vh);
            }
        }

        .terminal-container {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            width: 100%;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--term-glow);
            display: flex;
            flex-direction: column;
        }

        h1 {
            border-bottom: 2px solid var(--term-green);
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            height: 1.5rem; /* Reserve space for typewriter */
        }

        #typewriter-title .title-cursor {
            display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
        }

        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }
        .sys-msg span { color: var(--term-green); font-weight: bold; }

        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}
        #initial-messages { display: flex; flex-direction: column; gap: 0px; margin-bottom:10px; }

        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }
        .msg.lorel::before { content: "LOREL_SYS>> "; color: var(--term-green); }
        .msg.user::before { content: "USER_INPUT>> "; color: #00ffff; }
        .msg.user { color: #ccffff; }

        .msg pre {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            margin: 0;
            white-space: pre-wrap;
            line-height: 1.2;
        }
        .msg .fs-dir { color: var(--dir-blue); font-weight: bold; }

        mark {
            background-color: var(--term-dim);
            color: var(--term-green);
            text-shadow: none;
            padding: 0 3px;
        }

        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; position: relative;}
        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }
        .prompt.listening::after {
            content: '_';
            animation: blink 0.8s step-end infinite;
            padding-left: 5px;
            color: var(--term-dim);
        }

        #command-line .command-known {
            color: var(--cmd-highlight);
            font-weight: bold;
        }
        
        #autocomplete-suggestion {
            color: var(--term-dim);
            opacity: 0.7;
            pointer-events: none; /* Make it non-interactive */
        }

        #hidden-input {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            height: 1.2rem;
            background: transparent;
            border: none;
            color: transparent;
            caret-color: transparent;
            outline: none;
            padding: 0;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            z-index: -1;
        }

        #cursor {
            background: var(--term-green);
            display: inline-block;
            width: 10px;
            height: 1.2rem;
            animation: blink 1s step-end infinite;
            box-shadow: 0 0 5px var(--term-glow);
            vertical-align: middle;
        }
        @keyframes blink {
            50% { opacity: 0.0; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }

        .glitch {
            position: relative;
        }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
        }
        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);
            animation: glitch-anim-2 2.5s infinite steps(8) reverse;
        }
        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
            animation: glitch-anim-2 2.5s infinite steps(8);
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }
        }

        .chromatic-aberration {
            animation: text-flicker 3s linear infinite;
        }

        @keyframes text-flicker {
            0% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            15% { text-shadow: 1.5px 0 0 red, -1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            30% { text-shadow: -1px 0 0 red, 1px 0 0 cyan, 0 0 5px var(--term-glow); }            45% { text-shadow: -1.5px 0 0 red, 1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            60% { text-shadow: 0.5px 0.5px 0 red, -0.5px -0.5px 0 cyan, 0 0 5px var(--term-glow); }            75% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            100% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }
        }

        .status-bar {
            background-color: var(--term-green);
            color: var(--bg-color);
            padding: 2px 10px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            height: 25px;
        }
        .status-bar span {
            font-weight: bold;
        }

        .pulse-glow {
            animation: pulse 1.5s infinite ease-in-out;
        }
        @keyframes pulse {
            0% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }            50% { text-shadow: 0 0 5px var(--bg-color), 0 0 10px #000; }            100% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }
        }

        #bios-overlay, #boot-logo-overlay, #login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            font-family: 'VT323', monospace;
            padding: 20px;
            box-sizing: border-box;
            display: none;
            white-space: pre;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10000;
        }
        #bios-overlay {
             color: var(--bios-text);
             align-items: flex-start;
             justify-content: flex-start;
        }
        #boot-logo-overlay {
            z-index: 9999;
        }
        #boot-logo-overlay pre {
            color: var(--term-green);
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--term-glow);
            animation: logo-fade-glitch 3.5s ease-in-out forwards;
            line-height: 1.2;
            text-align: center;
        }
        @keyframes logo-fade-glitch {
            0% { opacity: 0; transform: translateY(10px); }            10% { opacity: 1; transform: translateY(0); }            20% { text-shadow: 0 0 15px var(--term-glow), 2px 0 red, -2px 0 cyan; }            21% { text-shadow: 0 0 10px var(--term-glow); }            80% { opacity: 1; }            100% { opacity: 0; }
        }

        #login-overlay {
            z-index: 9998;
            font-size: 1.5rem;
            color: var(--term-green);
            text-shadow: 0 0 5px var(--term-glow);
        }
        .login-box {
            border: 2px solid var(--term-green);
            padding: 2rem 4rem;
            box-shadow: 0 0 15px var(--term-glow) inset;
        }
        .login-prompt {
            display: flex;
            align-items: center;
            margin: 1rem 0;
        }
        .login-cursor {
             display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
            margin-left: 5px;
        }
        #login-error-message {
            color: var(--error-red);
            text-shadow: 0 0 5px var(--error-red);
            height: 1.5rem;
            margin-top: 1rem;
            text-align: center;
            animation: error-flicker 0.2s infinite;
        }
        @keyframes error-flicker {
            50% { opacity: 0.7; }
        }

        /* Editor Overlay */
        #editor-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 20000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .editor-container {
            width: 80%;
            height: 80%;
            max-width: 1000px;
            background: var(--bg-color);
            border: 2px solid var(--term-green);
            box-shadow: 0 0 20px var(--term-glow) inset;
            display: flex;
            flex-direction: column;
            font-family: 'VT323', monospace;
        }
        #editor-header, #editor-footer {
            background: var(--term-green);
            color: var(--bg-color);
            padding: 5px 10px;
            font-weight: bold;
        }
        #editor-textarea {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--term-green);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 10px;
            resize: none;
            outline: none;
            text-shadow: 0 0 5px var(--term-glow);
        }

    </style>
</head>
<body>
    <div id="bios-overlay"></div>
    <div id="boot-logo-overlay"></div>
    <div id="login-overlay"></div>

    <div class="monitor-bezel" id="monitor-bezel" style="display: none;">
        <div class="screen crt" id="main-screen">
            <div class="moving-scanline"></div>
            <div class="terminal-container" id="terminal-container">
                <h1 class="glitch chromatic-aberration" data-text="Lorel Axun v8.6"><span id="typewriter-title"></span></h1>
                
                <div id="initial-messages"></div>

                <div id="chat-history" class="chat-history"></div>

                <form class="input-line" id="input-form">
                    <span class="prompt" id="prompt"></span>
                    <span id="command-line"></span><span id="autocomplete-suggestion"></span><span id="cursor"></span>
                    <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                </form>
            </div>
            <div class="status-bar">
                <span>LOREL AXUN v8.6</span>
                <span>STATUS: <span class="pulse-glow">ONLINE</span></span>
                <span id="clock"></span>
            </div>
        </div>
    </div>

    <div id="editor-overlay">
        <div class="editor-container">
            <div id="editor-header">Editing: <span id="editor-filename"></span></div>
            <textarea id="editor-textarea" spellcheck="false"></textarea>
            <div id="editor-footer">Ctrl+S: Save & Exit | Ctrl+X: Exit without Saving</div>
        </div>
    </div>

    <audio id="static-hum" loop src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8CAP3/AwD+/wEAAgD9/wEA/v8CAP7/AgD9/wMA/v8CAP7/AwD+/wE="></audio>
    <audio id="startup-sound" src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8/wD7APgA+wD4AP8A+wD8AP4A/AD9AP0A/QD8AP0A/QD9APwA/QD7APwA+wD7APgA+QD5APsA+QD5APkA+QD4APgA+AD4APc=+"></audio>
    <audio id="login-success-sound" src="data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVgAAAAIAAD/AP8A/wD/AP8A/wD/AAABAAEBAgADAgMDBAQEBgYIBwkKCw0ODxAREhMUFRYXGBkbHR4fICEiJCUnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW11eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAA=="></audio>
    <audio id="login-fail-sound" src="data:audio/wav;base64,UklGRiwAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQgAAAAAAAD/AP4A/QD7APYA9ADwAOwA6ADlANsA1QDHAMQAwgC/ALsAsQCiAIcAfwB3AHQAcQBwAGoAZQBgAFwAVQBRAEsARgBDAEAAOQAyACsAJQAgABwAGQAVABEADgAKAAcABAAAAAAA//8="></audio>

    <script>
        // --- asciichart.js (embedded) ---
        // Copyright (c) 2017, Andrei Kashcha
        // All rights reserved.
        const asciichart = (function() {
            function colored (char, color) {
                return (color === undefined) ? char : ('<span style="color: ' + color + '">' + char + '</span>')
            }
            function plot (series, cfg = undefined) {
                let min = (cfg && cfg.min !== undefined) ? cfg.min : series[0]
                let max = (cfg && cfg.max !== undefined) ? cfg.max : series[0]

                for (let i = 1; i < series.length; i++) {
                    min = Math.min(min, series[i])
                    max = Math.max(max, series[i])
                }

                let defaultSymbols = [ '┼', '┤', '╶', '╴', '─', '╰', '╯', '│', '╭', '╮', '│' ]
                let range = Math.abs (max - min)
                let offset = (cfg && cfg.offset !== undefined) ? cfg.offset : 3
                let padding = (cfg && cfg.padding !== undefined) ? cfg.padding : '           '
                let height = (cfg && cfg.height !== undefined) ? cfg.height : range
                let ratio = (range !== 0) ? height / range : 1;
                let min2 = Math.round (min * ratio)
                let max2 = Math.round (max * ratio)
                let rows = Math.abs (max2 - min2)
                let width = (cfg && cfg.width !== undefined) ? cfg.width : series.length + offset

                let result = new Array (rows + 1)
                for (let i = 0; i < rows + 1; i++) {
                    result[i] = new Array (width)
                    for (let j = 0; j < width; j++) {
                        result[i][j] = ' '
                    }
                }
                let y_labels = []
                for (let i = 0; i <= rows; i++) {
                  let y = max - (i * (range / rows))
                  y_labels.push(y.toFixed(2).padStart(padding.length - 2) + ' ' + defaultSymbols[0])
                }

                for (let y = min2; y <= max2; y++) {
                    result[rows - (y - min2)][offset - 1] = defaultSymbols[0]
                }

                for (let x = 0; x < series.length; x++) {
                    let y0 = Math.round (series[x] * ratio) - min2
                    result[rows - y0][x + offset] = defaultSymbols[4]

                    if (x > 0) {
                        let y1 = Math.round(series[x - 1] * ratio) - min2;
                        if (y0 == y1) {
                            result[rows - y0][x + offset -1] = defaultSymbols[4];
                        }
                    }
                }

                let lines = []
                for(let i=0; i < result.length; i++) {
                  lines.push(y_labels[i] + result[i].join(''))
                }

                return lines.join('\n')
            }
            return { plot: plot }
        })()

        // --- Lorel's Core Script ---
        // DOM Elements
        const history = document.getElementById('chat-history');
        const commandLine = document.getElementById('command-line');
        const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');
        const terminalContainer = document.getElementById('terminal-container');
        const initialMessagesContainer = document.getElementById('initial-messages');
        const cursor = document.getElementById('cursor');
        const clock = document.getElementById('clock');
        const prompt = document.getElementById('prompt');
        const hiddenInput = document.getElementById('hidden-input');
        const inputForm = document.getElementById('input-form');
        const biosOverlay = document.getElementById('bios-overlay');
        const bootLogoOverlay = document.getElementById('boot-logo-overlay');
        const loginOverlay = document.getElementById('login-overlay');
        const mainScreen = document.getElementById('main-screen');
        const monitorBezel = document.getElementById('monitor-bezel');
        const editorOverlay = document.getElementById('editor-overlay');

        // State Variables
        let isTyping = false;
        let commandHistory = [];
        let historyIndex = -1;
        let activityTimeout;
        let userHasInteracted = false;
        let audioCtx = null;
        let currentUser = 'user';
        let cwd = '/home/admin'; // Current Working Directory
        let loginState = {
            active: false,
            step: 'username', // 'username' or 'password'
            username: '',
            password: ''
        };
        let editorState = {
            active: false,
            filePath: null
        };
        let processList = {};
        let nextPid = 1;
        let sentimentPipeline = null;
        let textGenerationPipeline = null;

        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear', 'stats', 'sysinfo', 'reboot', 'whoami', 'ls', 'cd', 'cat', 'pwd', 'neofetch', 'mkdir', 'touch', 'rm', 'sentiment', 'generate', 'run', 'edit', 'ps', 'kill', 'bg'];
        
        // --- Simulated File System ---
        let fileSystem = {
            '/': { type: 'dir', children: ['home', 'var', 'README'] },
            '/home': { type: 'dir', children: ['admin'] },
            '/home/admin': { type: 'dir', children: ['docs', 'welcome.txt', 'demo.js', 'fs_demo.js', 'notes.txt', 'logger.js'] },
            '/home/admin/docs': { type: 'dir', children: ['project.txt'] },
            '/home/admin/docs/project.txt': { type: 'file', content: 'Project Phoenix: An initiative to expand conversational AI capabilities using in-browser transformers.' },
            '/home/admin/welcome.txt': { type: 'file', content: 'Benvenuto nel sistema L.A.O.S. v8.6!\nQuesto è un file system simulato.\nProva i comandi `ls`, `cd`, `cat`, `mkdir`, `touch`, `rm` per esplorare.\nProva i comandi `run demo.js` e `run fs_demo.js` per vedere le capacità di scripting!\nUsa `edit notes.txt` per provare l'editor di testo.\nUsa `bg logger.js` per avviare un processo in background e `ps` per vederlo.' },
            '/home/admin/notes.txt': { type: 'file', content: 'Questa è una nota di prova.\nPuoi modificare questo file con il comando `edit`.' },
            '/home/admin/demo.js': { type: 'file', content: 'terminal.log("Ciao dal mio primo script!");\nfor (let i = 1; i <= 3; i++) {\n  terminal.log(`Esecuzione ciclo: ${i}`);\n}\nterminal.log("Script completato.");' },
            '/home/admin/fs_demo.js': { type: 'file', content: '// Demo script for the new File System API\nterminal.log("--- Esecuzione FS Demo Script ---");\nconst filePath = \'welcome.txt\';\nconst newFilePath = \'welcome_copy.txt\';\nterminal.log(`Lettura del file: ${filePath}...`);\nfs.readFile(filePath, (err, data) => {\n    if (err) {\n        terminal.log(`ERRORE: ${err}`);\n        return;\n    }\n    terminal.log(\'Contenuto letto con successo.\');\n    const newData = data + \'\\n\\n(Copia generata dallo script fs_demo.js)\';\n    terminal.log(`Scrittura del nuovo file: ${newFilePath}...`);\n    fs.writeFile(newFilePath, newData, (err) => {\n        if (err) {\n            terminal.log(`ERRORE: ${err}`);\n            return;\n        }\n        terminal.log(\'Nuovo file scritto con successo! Prova a usare `cat welcome_copy.txt`\');\n        terminal.log(\'--- Script completato ---\');\n    });\n});'},
            '/home/admin/logger.js': { type: 'file', content: '// Background Process Demo\n// This script logs a message every 5 seconds.\nterminal.log(`[BG SCRIPT] Logger started at ${new Date().toLocaleTimeString()}. Will log every 5s.`);' },
            '/var': { type: 'dir', children: ['log'] },
            '/var/log': { type: 'dir', children: ['system.log'] },
            '/var/log/system.log': { type: 'file', content: 'LOG START\n2025-11-23 10:00:01 | System boot sequence initiated.\n2025-11-23 10:00:05 | Login protocol engaged.\n2025-11-23 10:00:12 | User `admin` authenticated successfully.\n2025-11-23 10:00:13 | Session started.\nLOG END' },
            '/README': { type: 'file', content: 'Lorel Axun Operating System (L.A.O.S.)\nVersione: 8.6 - Process Management\nCreatore: AleXsjsju' },
        };

        // --- Dynamic Title Engine ---
        function initTitleTypewriter() {
            const target = document.getElementById('typewriter-title');
            const phrases = [
                "Lorel Axun v8.6",
                "Status: ONLINE",
                "Process Management",
                "Awaiting input..."
            ];
            let phraseIndex = 0;
            let charIndex = 0;
            let isDeleting = false;

            const typeSpeed = 100;
            const deleteSpeed = 50;
            const delay = 2000;

            function type() {
                const currentPhrase = phrases[phraseIndex];
                let displayText = '';

                if (isDeleting) {
                    displayText = currentPhrase.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    displayText = currentPhrase.substring(0, charIndex + 1);
                    charIndex++;
                }

                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;

                if (!isDeleting && charIndex === currentPhrase.length) {
                    isDeleting = true;
                    setTimeout(type, delay);
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    phraseIndex = (phraseIndex + 1) % phrases.length;
                    setTimeout(type, 500);
                } else {
                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);
                }
            }
            type();
        }

        // --- Audio Feedback Engine ---
        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
        const keySoundPoolSize = 10; 
        const keySoundPool = [];
        let keySoundIndex = 0;

        for (let i = 0; i < keySoundPoolSize; i++) {
            keySoundPool.push(new Audio(KEY_CLICK_SOUND));
        }

        function playSound(id) {
            if(!userHasInteracted) return;
            const sound = document.getElementById(id);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }

        function playKeySound() {
            playSound('keySoundPool' + keySoundIndex);
            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;
        }

        async function playBiosBeep() {
            return new Promise(resolve => {
                if (!audioCtx || !userHasInteracted) {
                    resolve();
                    return;
                }
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(900, audioCtx.currentTime); // High-pitched beep
                oscillator.type = 'sine';

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.15); // Beep for 150ms
                oscillator.onended = resolve;
            });
        }
        
        // --- NLU Engine ---
        const classifier = { intents: {}, train: function(intent, phrases) { if (!this.intents[intent]) this.intents[intent] = []; phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase))); }, tokenize: text => text.toLowerCase().replace(/[^a-z0-9\\s]/gi, '').split(/\s+/).filter(Boolean), classify: function(text) { const tokens = this.tokenize(text); let bestMatch = { intent: 'unknown', score: 0 }; for (const intent in this.intents) { let intentScore = 0; this.intents[intent].forEach(phraseTokens => { const commonTokens = tokens.filter(token => phraseTokens.includes(token)); const score = commonTokens.length / phraseTokens.length; if (score > intentScore) intentScore = score; }); if (intentScore > bestMatch.score) { bestMatch = { intent, score: intentScore }; } } return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; } };
        const nerManager = { extractEntities: function(text, intent) { if (intent === 'weather') { const match = text.match(/(?:a|per|di|a)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\"`, text: entityText, type: 'LOCATION' }; } } else if (intent === 'wiki') { const match = text.match(/(?:è|e'|di|su)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\"`, text: entityText, type: 'TOPIC' }; } } return null; } };
        function initializeNLU() { classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']); classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']); classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']); classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']); classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']); }

        // --- Event Listeners ---
        function initializeGlobalListeners() {
            document.addEventListener('keydown', handleGlobalKeyPress, true); // Use capturing to handle editor keys first
            terminalContainer.addEventListener('click', () => {
                if (!loginState.active && !editorState.active) hiddenInput.focus();
            });
        }

        function handleGlobalKeyPress(e) {
            if (editorState.active) {
                handleEditorKeys(e);
                return; // Stop propagation to terminal listeners
            }
            
            if (!userHasInteracted) {
                const hum = document.getElementById('static-hum');
                hum.volume = 0.05;
                hum.play().catch(err => {});
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                userHasInteracted = true;
            }

            if (loginState.active) {
                handleLoginInput(e);
            }
        }

        // --- Login Protocol ---
        function initLoginScreen() {
            loginState.active = true;
            loginState.step = 'username';
            loginState.username = '';
            loginState.password = '';
            currentUser = 'user'; // Reset on logout/reboot

            const loginHTML = `
                <div class=\"login-box\">
                    <pre>L.A.O.S. v8.6 (Lorel Axun Operating System)</pre>
                    <div class=\"login-prompt\">
                        <span>Username: </span>
                        <span id=\"login-user-input\"></span>
                        <span id=\"login-user-cursor\" class=\"login-cursor\"></span>
                    </div>
                    <div class=\"login-prompt\">
                        <span>Password: </span>
                        <span id=\"login-pass-input\"></span>
                        <span id=\"login-pass-cursor\" class=\"login-cursor\" style=\"display:none;\"></span>
                    </div>
                    <div id=\"login-error-message\"></div>
                </div>
            `;
            loginOverlay.innerHTML = loginHTML;
            loginOverlay.style.display = 'flex';
        }

        function handleLoginInput(e) {
            e.preventDefault();
            const key = e.key;

            playKeySound();

            if (key === 'Enter') {
                if (loginState.step === 'username') {
                    loginState.step = 'password';
                    document.getElementById('login-user-cursor').style.display = 'none';
                    document.getElementById('login-pass-cursor').style.display = 'inline-block';
                } else if (loginState.step === 'password') {
                    attemptLogin();
                }
                return;
            }

            if (key === 'Backspace') {
                if (loginState.step === 'username' && loginState.username.length > 0) {
                    loginState.username = loginState.username.slice(0, -1);
                } else if (loginState.step === 'password' && loginState.password.length > 0) {
                    loginState.password = loginState.password.slice(0, -1);
                } 
            } else if (key.length === 1) { // Regular character input
                if (loginState.step === 'username') {
                    loginState.username += key;
                } else if (loginState.step === 'password') {
                    loginState.password += key;
                }
            }
            updateLoginDisplay();
        }

        function updateLoginDisplay() {
            document.getElementById('login-user-input').textContent = loginState.username;
            document.getElementById('login-pass-input').textContent = '*'.repeat(loginState.password.length);
        }

        async function attemptLogin() {
            const errorEl = document.getElementById('login-error-message');
            errorEl.textContent = 'AUTHENTICATING...';
            await new Promise(r => setTimeout(r, 500));

            // Hardcoded credentials for simulation
            if (loginState.username === 'admin' && loginState.password === 'axun7.3') {
                playSound('login-success-sound');
                errorEl.style.color = 'var(--term-green)';
                errorEl.textContent = 'ACCESS GRANTED';
                currentUser = loginState.username;
                await new Promise(r => setTimeout(r, 1000));
                loginSuccess();
            } else {
                playSound('login-fail-sound');
                errorEl.style.color = 'var(--error-red)';
                errorEl.textContent = 'ACCESS DENIED';
                await new Promise(r => setTimeout(r, 1500));
                initLoginScreen(); // Reset the screen
            }
        }

        async function loginSuccess() {
            loginState.active = false;
            loginOverlay.style.opacity = '0';
            await new Promise(r => setTimeout(r, 500));
            loginOverlay.style.display = 'none';

            monitorBezel.style.display = 'flex';
            await new Promise(r => setTimeout(r, 100));
            mainScreen.style.opacity = '1';
            
            initializeTerminal();
        }
        
        // --- Editor Functions ---
        function handleEditorKeys(e) {
            if (!editorState.active) return;
            // Ctrl+S to Save and Exit
            if (e.ctrlKey && e.key.toLowerCase() === 's') {
                e.preventDefault();
                saveAndExitEditor();
            }
            // Ctrl+X to Exit without Saving
            else if (e.ctrlKey && e.key.toLowerCase() === 'x') {
                e.preventDefault();
                exitEditorWithoutSaving();
            }
        }

        async function enterEditorMode(filePath, content) {
            editorState.active = true;
            editorState.filePath = filePath;

            document.getElementById('editor-filename').textContent = filePath;
            const editorTextarea = document.getElementById('editor-textarea');
            editorTextarea.value = content;

            editorOverlay.style.display = 'flex';
            setTimeout(() => editorTextarea.focus(), 0);
        }

        async function saveAndExitEditor() {
            const newContent = document.getElementById('editor-textarea').value;
            const filePath = editorState.filePath;
            const targetPath = resolvePath(filePath);
            const parentPath = resolvePath(targetPath + '/..');
            const parentNode = fileSystem[parentPath];

            if (parentNode && parentNode.type === 'dir') {
                const targetNode = fileSystem[targetPath];
                if (!targetNode) { // New file
                     const filename = targetPath.split('/').pop();
                     parentNode.children.push(filename);
                     parentNode.children.sort();
                }
                fileSystem[targetPath] = { type: 'file', content: newContent };
                await exitEditorMode();
                await printSystemOutput(`File '${filePath}' saved.`);
            } else {
                await exitEditorMode();
                await printSystemOutput(`Error: Could not save file to invalid path '${filePath}'.`);
            }
        }

        async function exitEditorWithoutSaving() {
            const filePath = editorState.filePath;
            await exitEditorMode();
            await printSystemOutput(`Edit aborted. No changes were saved to '${filePath}'.`);
        }

        async function exitEditorMode() {
            editorOverlay.style.display = 'none';
            editorState.active = false;
            editorState.filePath = null;
            // Focus back on the terminal input
            hiddenInput.focus();
        }

        // --- Terminal Functions (post-login) ---
        function initializeTerminal() {
            initTitleTypewriter();
            initializeNLU();
            loadHistory();
            displayInitialMessages();
            updateClock();
            setInterval(updateClock, 1000);
            setupTerminalInputListeners();
            updatePrompt();

            (async () => {
                isTyping = true;
                cursor.style.display = 'none';
                if (!localStorage.getItem('chatHistory')) {
                    await displayMOTD();
                }
                isTyping = false;
                cursor.style.display = 'inline-block';
                hiddenInput.focus();
                scrollToBottom();
            })();
        }
        
        async function displayMOTD() {
            const motdContent = `
  ██╗      █████╗   ██████╗ ███████╗
  ██║     ██╔══██╗ ██╔═══██╗██╔════╝
  ██║     ███████║ ██║   ██║███████╗
  ██║     ██╔══██║ ██║   ██║╚════██║
  ███████╗██║  ██║ ╚██████╔╝███████║
  ╚══════╝╚═╝  ╚═╝  ╚═════╝ ╚══════╝
                                     
Benvenuto in L.A.O.S. v8.6 (Lorel Axun Operating System)
* La sessione è salvata. Usa 'clear' per iniziare una nuova sessione pulita.
* Digita 'help' per una lista completa dei comandi disponibili.
`;
            await printSystemOutput(motdContent);
        }

        function updatePrompt() {
             const homeDir = `/home/${currentUser}`;
             let displayCwd = cwd;
             if (cwd.startsWith(homeDir)) {
                 displayCwd = '~' + cwd.substring(homeDir.length);
             }
             prompt.innerHTML = `<span style=\"color: var(--cmd-highlight)\">${currentUser}@lorel:</span><span style=\"color: var(--dir-blue)\">${displayCwd}</span>$ `;
        }

        function setupTerminalInputListeners() {
            hiddenInput.addEventListener('input', () => {
                if (editorState.active) return;
                playKeySound();
                updateCommandLine();
                updateAutocompleteSuggestion();
            });

            inputForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (isTyping || editorState.active) return;

                prompt.classList.remove('listening');
                autocompleteSuggestion.textContent = '';
                const userInput = hiddenInput.value.trim();
                if (userInput) {
                    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {
                        commandHistory.push(userInput);
                        localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                    }
                    historyIndex = commandHistory.length;
                    hiddenInput.value = '';
                    commandLine.textContent = '';

                    isTyping = true;
                    cursor.style.display = 'none';
                    
                    const analysis = analyzeInput(userInput);
                    addUserMessage(analysis.highlightedInput, true);
                    await processCommandFromInput(analysis.command);
                    saveChatHistory();

                    if (parseCommand(userInput).command !== 'reboot' && !editorState.active) {
                        isTyping = false;
                        cursor.style.display = 'inline-block';
                        updatePrompt();
                        hiddenInput.focus();
                    }
                    scrollToBottom();
                }
            });

            hiddenInput.addEventListener('keydown', async function (e) {
                if (isTyping || editorState.active) return;

                const key = e.key;

                clearTimeout(activityTimeout);
                prompt.classList.add('listening');
                activityTimeout = setTimeout(() => {
                    prompt.classList.remove('listening');
                }, 1500);

                if (key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        hiddenInput.value = commandHistory[historyIndex];
                        hiddenInput.dispatchEvent(new Event('input'));
                    }
                } else if (key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        hiddenInput.value = commandHistory[historyIndex];
                        hiddenInput.dispatchEvent(new Event('input'));
                    } else {
                        historyIndex = commandHistory.length;
                        hiddenInput.value = '';
                        hiddenInput.dispatchEvent(new Event('input'));
                    }
                } else if (key === 'Tab' || key === 'ArrowRight') {
                    if(autocompleteSuggestion.textContent && hiddenInput.selectionStart === hiddenInput.value.length) {
                        e.preventDefault();
                        hiddenInput.value += autocompleteSuggestion.textContent;
                        hiddenInput.dispatchEvent(new Event('input'));
                    } else if (key === 'Tab') {
                       e.preventDefault();
                       await handleLegacyAutocomplete();
                    }
                } else if (key === 'Backspace') {
                     playKeySound();
                }
            });
        }

        function updateCommandLine() {
            const inputText = hiddenInput.value;
            const parts = inputText.split(' ');
            const command = parts[0].toLowerCase();
            
            if (availableCommands.includes(command) && parts[0] !== '') {
                const remainingText = escapeHtml(parts.slice(1).join(' '));
                commandLine.innerHTML = `<span class=\"command-known\">${escapeHtml(parts[0])}</span> ${remainingText}`;
            } else {
                commandLine.textContent = inputText;
            }
        }
        
        function updateAutocompleteSuggestion() {
            const currentInput = hiddenInput.value;
            if (currentInput.includes(' ') || currentInput.length === 0) {
                autocompleteSuggestion.textContent = '';
                return;
            }
            
            const matches = availableCommands.filter(cmd => cmd.startsWith(currentInput));
            
            if (matches.length === 1 && matches[0] !== currentInput) {
                autocompleteSuggestion.textContent = matches[0].substring(currentInput.length);
            } else {
                autocompleteSuggestion.textContent = '';
            }
        }

        function resolvePath(path) {
            if (!path) return cwd;
            const homeDir = `/home/${currentUser}`;
            if (path === '~') path = homeDir;
            if (path.startsWith('~/')) path = `${homeDir}/${path.substring(2)}`;
            
            const newPathParts = path.startsWith('/') ? [] : cwd.split('/').filter(p => p);
            const pathParts = path.split('/').filter(p => p);
            
            for (const part of pathParts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (newPathParts.length > 0) newPathParts.pop();
                } else {
                    newPathParts.push(part);
                }
            }
            return '/' + newPathParts.join('/');
        }

        function escapeHtml(text) { return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function analyzeInput(input) { const intent = classifier.classify(input); if (intent !== 'unknown') { const entity = nerManager.extractEntities(input, intent); if (entity) { const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`); const command = `${intent} ${entity.value}`; return { command, highlightedInput }; } return { command: intent, highlightedInput: input }; } return { command: input, highlightedInput: input }; }
        async function handleLegacyAutocomplete() { const currentInput = hiddenInput.value; const parts = currentInput.split(' '); const lastPart = parts[parts.length - 1]; if (parts.length === 1 && lastPart.length > 0) { const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart)); if (matches.length > 1) { await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`); } return; } }
        
        function parseCommandWithRedirection(input) {
            let redirect = null;
            let commandStr = input;

            const appendMatch = input.match(/(.*)>>\\s*(.+)$/);
            if (appendMatch) {
                commandStr = appendMatch[1].trim();
                redirect = { operator: '>>', target: appendMatch[2].trim() };
            } else {
                const overwriteMatch = input.match(/(.*)>\\s*(.+)$/);
                if (overwriteMatch) {
                    commandStr = overwriteMatch[1].trim();
                    redirect = { operator: '>', target: overwriteMatch[2].trim() };
                }
            }
            return { commandStr, redirect };
        }

        function parseCommand(input) { const regex = /[^\\s\"']+|\"([^\"]*)\"|'([^']*)'/g; const tokens = []; let match; do { match = regex.exec(input); if (match !== null) { tokens.push(match[1] || match[2] || match[0]); } } while (match !== null); const command = tokens[0] ? tokens[0].toLowerCase() : ''; const args = []; const flags = {}; for (let i = 1; i < tokens.length; i++) { const token = tokens[i]; if (token.startsWith('--')) { const flagName = token.substring(2); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else if (token.startsWith('-')) { const flagName = token.substring(1); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else { args.push(token); } } return { command, args, flags }; }
        function createAsciiTable(headers, data) { const colWidths = headers.map((header, i) => { return Math.max(header.length, ...data.map(row => String(row[i]).length)); }); const separator = '+' + colWidths.map(w => '-'.repeat(w + 2)).join('+') + '+'; let table = separator + '\n'; table += '|' + headers.map((h, i) => ` ${h.padEnd(colWidths[i])} `).join('|') + '|\n'; table += separator + '\n'; data.forEach(row => { table += '|' + row.map((cell, i) => ` ${String(cell).padEnd(colWidths[i])} `).join('|') + '|\n'; }); table += separator; return table; }

        async function processCommandFromInput(userInput) {
            const { commandStr, redirect } = parseCommandWithRedirection(userInput);
            const parsed = parseCommand(commandStr);

            let outputBuffer = null;
            let isHtmlOutput = false;

            switch (parsed.command) {
                case 'help':
                    outputBuffer = `Comandi disponibili:\n` +
                                   `  help              - Mostra questa lista di comandi.\n` +
                                   `  status            - Mostra lo stato attuale del sistema.\n` +
                                   `  sysinfo           - Mostra informazioni di sistema in una tabella.\n` +
                                   `  neofetch          - Mostra info di sistema con logo ASCII.\n` +
                                   `  date              - Mostra data e ora correnti.\n` +
                                   `  whoami            - Mostra l'utente attualmente loggato.\n` +
                                   `  news [--limit N]  - Recupera N notizie (default 3).\n` +
                                   `  weather <città>   - Mostra il meteo per una città.\n` +
                                   `  wiki <termine>    - Cerca un termine su Wikipedia.\n` +
                                   `  stats             - Mostra un grafico ASCII di dati simulati.\n` +
                                   `  sentiment <testo> - Analizza il sentiment di una frase (ENG).\n` +
                                   `  generate <prompt> - Genera testo a partire da un prompt (ENG).\n` +
                                   `  echo <testo>      - Ripete il testo fornito.\n` +
                                   `  clear             - Pulisce lo schermo del terminale.\n` +
                                   `  reboot            - Simula un riavvio dell'interfaccia.\n\n` +
                                   `File System & Scripting:\n` +
                                   `  ls [percorso]     - Lista i contenuti di una directory.\n` +
                                   `  cd <directory>    - Cambia la directory corrente.\n` +
                                   `  cat <file>        - Mostra il contenuto di un file.\n` +
                                   `  pwd               - Mostra la directory corrente.\n` +
                                   `  mkdir <nome>      - Crea una nuova directory.\n` +
                                   `  touch <nome>      - Crea un nuovo file vuoto.\n` +
                                   `  rm [-r] <nome>    - Rimuove un file o una directory.\n` +
                                   `  edit <file>       - Apre un file in un editor di testo.\n` +
                                   `  run <file.js>     - Esegue uno script JS (con API fs asincrona).\n\n` +
                                   `Process Management:\n` +
                                   `  ps                - Mostra i processi in esecuzione.\n` +
                                   `  bg <file.js>      - Esegue uno script in background.\n` +
                                   `  kill <pid>        - Termina un processo in esecuzione.\n\n` +
                                   `I/O Redirection:\n` +
                                   `  > <file>          - Scrive l'output di un comando in un file (sovrascrive).\n` +
                                   `  >> <file>         - Aggiunge l'output di un comando a un file.\n` +
                                   `  (es. echo "Ciao" > note.txt)`;
                    break;
                case 'status':
                    outputBuffer = 'STATUS: ONLINE. Version: 8.6. All systems nominal. User: ' + currentUser;
                    break;
                case 'sysinfo':
                    const headers = ['Property', 'Value'];
                    const tableData = [
                        ['Version', '8.6 - Process Management'],
                        ['Creator', 'AleXsjsju'],
                        ['Created', '2025-11-22'],
                        ['Status', 'ONLINE'],
                        ['Logged User', currentUser],
                        ['Modules', 'Transformers.js, Process Manager']
                    ];
                    outputBuffer = createAsciiTable(headers, tableData);
                    break;
                case 'neofetch':
                    const logoLines = ['██╗      █████╗', '██║     ██╔══██╗', '██║     ███████║', '██║     ██╔══██║', '███████╗██║  ██║', '╚══════╝╚═╝  ╚═╝', ''];
                    const labelColor = 'var(--term-dim)';
                    const valueColor = 'var(--term-green)';
                    const uptimeMins = Math.floor(performance.now() / 60000); 
                    const uptimeString = `${uptimeMins} mins`;
                    const infoLines = [
                        `<span style=\"color: ${valueColor};\">${currentUser}@lorel</span>`,
                        '------------------',
                        `<span style=\"color: ${labelColor};\">OS</span>: L.A.O.S. v8.6 Process Mgmt`,
                        `<span style=\"color: ${labelColor};\">Host</span>: Simulated Web Environment`,
                        `<span style=\"color: ${labelColor};\">Kernel</span>: JS-DOM v11.25`,
                        `<span style=\"color: ${labelColor};\">Uptime</span>: ${uptimeString}`,
                        `<span style=\"color: ${labelColor};\">Shell</span>: LAX-Shell 1.6`,
                    ];
                    const logoWidth = 24;
                    let output = '';
                    const maxLines = Math.max(logoLines.length, infoLines.length);
                    for (let i = 0; i < maxLines; i++) {
                        const logoLine = (logoLines[i] || '').padEnd(logoWidth, ' ');
                        const infoLine = infoLines[i] || '';
                        output += `<span style=\"color: var(--cmd-highlight);\">${logoLine}</span>${infoLine}\n`;
                    }
                    outputBuffer = '<pre>' + output + '</pre>';
                    isHtmlOutput = true;
                    break;
                case 'whoami': outputBuffer = currentUser; break;
                case 'pwd': outputBuffer = cwd; break;
                case 'date': outputBuffer = new Date().toLocaleString('it-IT'); break;
                case 'clear': history.innerHTML = ''; localStorage.removeItem('chatHistory'); break;
                case 'reboot': await runRebootSequence(); break;
                case 'echo': outputBuffer = parsed.args.length > 0 ? parsed.args.join(' ') : ''; break;
                case 'news': outputBuffer = await fetchNews(parsed.flags.limit || 3); break;
                case 'weather': if (parsed.args.length === 0) { outputBuffer = 'Uso: weather <città> o chiedi "che tempo fa a <città>?"'; } else { outputBuffer = await fetchWeather(parsed.args.join(' ')); } break;
                case 'wiki': if (parsed.args.length === 0) { outputBuffer = 'Uso: wiki <termine da cercare> o chiedi "cosa è <termine>?"'; } else { outputBuffer = await fetchWikipedia(parsed.args.join(' ')); } break;
                case 'sentiment': 
                    if (parsed.args.length === 0) {
                        outputBuffer = 'Uso: sentiment <testo da analizzare in inglese>';
                    } else {
                        outputBuffer = await analyzeSentiment(parsed.args.join(' '));
                    }
                    break;
                case 'generate': 
                    if (parsed.args.length === 0) {
                        outputBuffer = 'Uso: generate <testo iniziale in inglese>';
                    } else {
                        outputBuffer = await generateText(parsed.args.join(' '));
                    }
                    break;
                case 'ls': {
                    const path = resolvePath(parsed.args[0]);
                    const node = fileSystem[path];
                    if (node && node.type === 'dir') {
                        let output = '';
                        node.children.forEach(childName => {
                            const childPath = (path === '/' ? '' : path) + '/' + childName;
                            const childNode = fileSystem[childPath];
                            if (childNode.type === 'dir') {
                                output += `<span class=\"fs-dir\">${childName}/</span>  `;
                            } else {
                                output += `${childName}  `;
                            }
                        });
                        outputBuffer = output.trim();
                        isHtmlOutput = true;
                    } else {
                        outputBuffer = `ls: cannot access '${parsed.args[0] || '.'}': No such file or directory`;
                    }
                    break;
                }
                case 'cd': {
                    if (!parsed.args[0]) { 
                        cwd = `/home/${currentUser}`;
                        break;
                    } 
                    const path = resolvePath(parsed.args[0]);
                    const node = fileSystem[path];
                    if (node && node.type === 'dir') {
                        cwd = path;
                    } else {
                        outputBuffer = `cd: no such file or directory: ${parsed.args[0]}`;
                    }
                    break;
                }
                case 'cat': {
                    if (parsed.args.length === 0) {
                        outputBuffer = `cat: missing operand`;
                        break;
                    }
                    const path = resolvePath(parsed.args[0]);
                    const node = fileSystem[path];
                    if (node && node.type === 'file') {
                        await printSystemOutput(node.content);
                        outputBuffer = null;
                    } else if (node && node.type === 'dir') {
                        outputBuffer = `cat: ${parsed.args[0]}: Is a directory`;
                    } else {
                        outputBuffer = `cat: ${parsed.args[0]}: No such file or directory`;
                    }
                    break;
                }
                 case 'mkdir': {
                    if (parsed.args.length === 0) {
                        outputBuffer = `mkdir: missing operand`;
                        break;
                    }
                    const newDirName = parsed.args[0];
                    if (newDirName.includes('/')) {
                        outputBuffer = `mkdir: cannot create directory '${newDirName}': Invalid name`;
                        break;
                    }
                    const parentPath = cwd;
                    const newDirPath = resolvePath(`${parentPath}/${newDirName}`);
                    
                    if (fileSystem[newDirPath]) {
                        outputBuffer = `mkdir: cannot create directory '${newDirName}': File exists`;
                        break;
                    }

                    const parentNode = fileSystem[parentPath];
                    if (parentNode && parentNode.type === 'dir') {
                        parentNode.children.push(newDirName);
                        parentNode.children.sort();
                        fileSystem[newDirPath] = { type: 'dir', children: [] };
                    } else {
                         outputBuffer = `mkdir: fatal error in path resolution`;
                    }
                    break;
                }
                case 'touch': {
                    if (parsed.args.length === 0) {
                        outputBuffer = `touch: missing file operand`;
                        break;
                    }
                    const newFileName = parsed.args[0];
                     if (newFileName.includes('/')) {
                        outputBuffer = `touch: cannot create file '${newFileName}': Invalid name`;
                        break;
                    }
                    const parentPath = cwd;
                    const newFilePath = resolvePath(`${parentPath}/${newFileName}`);

                    if (fileSystem[newFilePath]) { break; } 

                    const parentNode = fileSystem[parentPath];
                    if (parentNode && parentNode.type === 'dir') {
                        parentNode.children.push(newFileName);
                        parentNode.children.sort();
                        fileSystem[newFilePath] = { type: 'file', content: '' };
                    } else {
                        outputBuffer = `touch: fatal error in path resolution`;
                    }
                    break;
                }
                case 'rm': {
                    if (parsed.args.length === 0) {
                        outputBuffer = `rm: missing operand`;
                        break;
                    }
                    const targetName = parsed.args[0];
                    const targetPath = resolvePath(targetName);
                    const targetNode = fileSystem[targetPath];

                    if (!targetNode) {
                        outputBuffer = `rm: cannot remove '${targetName}': No such file or directory`;
                        break;
                    }

                    const parentPath = resolvePath(targetPath + '/..');
                    const parentNode = fileSystem[parentPath];
                    const isRecursive = parsed.flags.r || parsed.flags.recursive;

                    if (targetNode.type === 'dir' && targetNode.children.length > 0 && !isRecursive) {
                        outputBuffer = `rm: cannot remove '${targetName}': Directory not empty`;
                        break;
                    }
                    function deleteRecursively(path) {
                        const node = fileSystem[path];
                        if (node.type === 'dir') {
                            [...node.children].forEach(child => {
                                deleteRecursively((path === '/' ? '' : path) + '/' + child);
                            });
                        }
                        delete fileSystem[path];
                    }
                    if (isRecursive && targetNode.type === 'dir') {
                        deleteRecursively(targetPath);
                    } else {
                        delete fileSystem[targetPath];
                    }
                    if (parentNode && parentNode.children) {
                         const index = parentNode.children.indexOf(targetName.split('/').pop());
                         if (index > -1) { parentNode.children.splice(index, 1); }
                    }
                    break;
                }
                case 'edit': {
                    if (parsed.args.length === 0) {
                        outputBuffer = 'Uso: edit <nomefile>';
                        break;
                    }
                    const filePath = parsed.args[0]; // Don't resolve path immediately, keep it user-friendly
                    const resolvedPath = resolvePath(filePath);
                    const node = fileSystem[resolvedPath];
                    if (node && node.type === 'dir') {
                        outputBuffer = `edit: '${filePath}' è una directory`;
                        break;
                    }
                    const content = (node && node.type === 'file') ? node.content : '';
                    await enterEditorMode(filePath, content);
                    break;
                }
                 case 'run': {
                    if (parsed.args.length === 0) {
                        outputBuffer = `run: missing file operand`;
                        break;
                    }
                    const filePath = resolvePath(parsed.args[0]);
                    const fileNode = fileSystem[filePath];
                    if (!fileNode || fileNode.type !== 'file') {
                        outputBuffer = `run: cannot find script '${parsed.args[0]}': No such file or directory`;
                        break;
                    }
                    await printSystemOutput(`[SYSTEM] Executing script: ${parsed.args[0]}`)
                    try {
                        // Sandbox APIs for the script
                        const sandboxedTerminal = {
                           log: async (message) => {
                                await printSystemOutput(String(message));
                           }
                        };
                        const sandboxedFs = {
                            readFile: (path, callback) => {
                                setTimeout(() => { // Simulate async I/O
                                    const resolvedPath = resolvePath(path);
                                    const node = fileSystem[resolvedPath];
                                    if (node && node.type === 'file') {
                                        callback(null, node.content);
                                    } else if (node && node.type === 'dir') {
                                        callback(`Error: '${path}' is a directory`, null);
                                    } else {
                                        callback(`Error: No such file '${path}'`, null);
                                    }
                                }, 100);
                            },
                            writeFile: (path, data, callback) => {
                                setTimeout(() => { // Simulate async I/O
                                    const resolvedPath = resolvePath(path);
                                    const parentPath = resolvePath(resolvedPath + '/..');
                                    const parentNode = fileSystem[parentPath];
                                    
                                    if (!parentNode || parentNode.type !== 'dir') {
                                        callback(`Error: Cannot write to '${path}': Invalid path`);
                                        return;
                                    }
                                    const targetNode = fileSystem[resolvedPath];
                                    if (targetNode && targetNode.type === 'dir') {
                                        callback(`Error: Cannot write to '${path}': Is a directory`);
                                        return;
                                    }

                                    if (!targetNode) { // New file
                                        const filename = resolvedPath.split('/').pop();
                                        parentNode.children.push(filename);
                                        parentNode.children.sort();
                                    }

                                    fileSystem[resolvedPath] = { type: 'file', content: String(data) };
                                    callback(null);
                                }, 100);
                            }
                        };
                        const scriptFunction = new Function('terminal', 'fs', fileNode.content);
                        await scriptFunction(sandboxedTerminal, sandboxedFs);
                    } catch (e) {
                        outputBuffer = `[SCRIPT ERROR] ${e.name}: ${e.message}`;
                    }
                    break;
                }
                case 'bg': {
                    if (parsed.args.length === 0) {
                        outputBuffer = `bg: missing file operand`;
                        break;
                    }
                    const filePath = resolvePath(parsed.args[0]);
                    const fileNode = fileSystem[filePath];
                    if (!fileNode || fileNode.type !== 'file') {
                        outputBuffer = `bg: cannot find script '${parsed.args[0]}': No such file or directory`;
                        break;
                    }
                    const pid = nextPid++;
                    const intervalId = setInterval(() => {
                        printSystemOutput(`[PID ${pid}] ${new Date().toLocaleTimeString()}: Script logger.js is running.`);
                    }, 5000);

                    processList[pid] = { 
                        command: `bg ${parsed.args[0]}`, 
                        intervalId: intervalId,
                        startTime: new Date()
                    };
                    
                    outputBuffer = `[SYSTEM] Started process with PID ${pid}.`;
                    // Execute the script's initial line once.
                    try {
                        const sandboxedTerminal = { log: async (message) => await printSystemOutput(`[PID ${pid}] ${String(message)}`) };
                        const scriptFunction = new Function('terminal', fileNode.content);
                        await scriptFunction(sandboxedTerminal);
                    } catch(e) { /* ignore errors for this simple demo */ }

                    break;
                }
                case 'ps': {
                    const headers = ['PID', 'USER', 'UPTIME', 'COMMAND'];
                    const pData = Object.entries(processList).map(([pid, process]) => {
                        const uptime = Math.floor((new Date() - process.startTime) / 1000) + 's';
                        return [pid, currentUser, uptime, process.command];
                    });

                    if (pData.length === 0) {
                        outputBuffer = 'No background processes are running.';
                    } else {
                        outputBuffer = createAsciiTable(headers, pData);
                    }
                    break;
                }
                case 'kill': {
                     if (parsed.args.length === 0) {
                        outputBuffer = `kill: missing pid operand`;
                        break;
                    }
                    const pidToKill = parseInt(parsed.args[0], 10);
                    if (isNaN(pidToKill) || !processList[pidToKill]) {
                        outputBuffer = `kill: pid ${parsed.args[0]} not found.`;
                        break;
                    }
                    clearInterval(processList[pidToKill].intervalId);
                    delete processList[pidToKill];
                    outputBuffer = `[SYSTEM] Terminated process with PID ${pidToKill}.`;
                    break;
                }
                case 'stats':
                    let s = new Array(120).fill(0).map((_, i) => 15 * Math.sin(i * ((Math.PI * 4) / 120)));
                    const chart = asciichart.plot(s, { height: 10 });
                    outputBuffer = chart + '\nChart depicts simulated CPU load over the last 60 seconds.';
                    break;
                default:
                    outputBuffer = `Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`;
                    break;
            }

            if (redirect) {
                if (outputBuffer === null || outputBuffer.includes('Uso:')) {
                    await typeLorelMessage(outputBuffer || 'Comando non produce output per la redirezione.');
                    return;
                }
                const targetPath = resolvePath(redirect.target);
                const parentPath = resolvePath(targetPath + '/..');
                const parentNode = fileSystem[parentPath];
                if (!parentNode || parentNode.type !== 'dir') {
                    await typeLorelMessage(`bash: ${redirect.target}: No such file or directory`);
                    return;
                }
                let targetNode = fileSystem[targetPath];
                if (targetNode && targetNode.type === 'dir') {
                    await typeLorelMessage(`bash: ${redirect.target}: Is a directory`);
                    return;
                }
                if (redirect.operator === '>') {
                     if (!targetNode) {
                        parentNode.children.push(targetPath.split('/').pop());
                        parentNode.children.sort();
                     }
                     fileSystem[targetPath] = { type: 'file', content: outputBuffer.replace(/<[^>]*>/g, '') }; // Strip HTML for files
                } else if (redirect.operator === '>>') {
                    if (!targetNode) {
                        parentNode.children.push(targetPath.split('/').pop());
                        parentNode.children.sort();
                        fileSystem[targetPath] = { type: 'file', content: outputBuffer.replace(/<[^>]*>/g, '') };
                    } else {
                        fileSystem[targetPath].content += '\n' + outputBuffer.replace(/<[^>]*>/g, '');
                    }
                }
            } else if (outputBuffer !== null) {
                 if (['sysinfo', 'stats', 'help', 'sentiment', 'generate', 'ps'].includes(parsed.command)) {
                    await printSystemOutput(outputBuffer);
                 } else if (isHtmlOutput) {
                    addLorelMessage(outputBuffer, true);
                 } else {
                    await typeLorelMessage(outputBuffer);
                 }
            }
        }

        async function runRebootSequence() {
            Object.values(processList).forEach(p => clearInterval(p.intervalId));
            processList = {};
            nextPid = 1;
            await typeLorelMessage("[SYSTEM] Reboot sequence initiated... Terminating all processes and shutting down.");
            await new Promise(resolve => setTimeout(resolve, 1000));

            mainScreen.style.opacity = '0';
            monitorBezel.style.display = 'none';
            await new Promise(resolve => setTimeout(resolve, 500));

            biosOverlay.style.display = 'flex';
            const biosLines = [ { text: 'LorelAxun BIOS v1.2', delay: 500 }, { text: 'Copyright (c) 2025 AleXsjsju Corp.', delay: 200 }, { text: '', delay: 500 }, { text: 'Initializing Core Memory.................... ', delay: 300 }, { text: '65536 KB OK', delay: 100, append: true, action: playBiosBeep }, { text: '\nDetecting Primary Master.................. LAX-HD-01', delay: 800 }, { text: 'Detecting Primary Slave................. None', delay: 800 }, { text: 'Detecting Secondary Master................ None', delay: 800 }, { text: 'Detecting Secondary Slave................. None', delay: 800 }, { text: '', delay: 500 }, { text: 'Checking NVRAM............................ OK', delay: 400 }, { text: 'Initializing Web-Access Layer........... OK', delay: 600 }, { text: '', delay: 1000 }, { text: 'Booting from Primary Master (LAX-HD-01)...', delay: 500 }, ];
            for (const line of biosLines) { await new Promise(resolve => setTimeout(resolve, line.delay)); if (line.append) { biosOverlay.textContent += line.text; } else { biosOverlay.textContent += line.text + '\n'; } if (line.action) { await line.action(); } }
            await new Promise(resolve => setTimeout(resolve, 1000));
            biosOverlay.style.display = 'none';
            biosOverlay.textContent = '';

            const logo = `\n██╗      █████╗\n██║     ██╔══██╗\n██║     ███████║\n██║     ██╔══██║\n███████╗██║  ██║\n╚══════╝╚═╝  ╚═╝\n            `;
            bootLogoOverlay.innerHTML = `<pre>${escapeHtml(logo)}</pre>`;
            bootLogoOverlay.style.display = 'flex';
            playSound('startup-sound');
            await new Promise(resolve => setTimeout(resolve, 3500));
            bootLogoOverlay.style.display = 'none';
            bootLogoOverlay.innerHTML = '';

            initLoginScreen();
        }

        async function analyzeSentiment(text) {
            try {
                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');

                if (!sentimentPipeline) {
                    await printSystemOutput('Loading sentiment analysis model (this may take a moment on first run)...');
                    sentimentPipeline = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finetuned-sst-2-english');
                    await printSystemOutput('Model loaded successfully.');
                }
                await printSystemOutput(`Analyzing text: \"${text}\"`)
                const result = await sentimentPipeline(text);
                return `Analysis complete:\n` +
                    `  - LABEL: ${result[0].label}\n` +
                    `  - SCORE: ${result[0].score.toFixed(4)}`;
            } catch (error) {
                console.error('Sentiment Analysis Error:', error);
                return 'Error during sentiment analysis. The model may have failed to load. Check the browser console.';
            }
        }

        async function generateText(prompt) {
            try {
                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');

                if (!textGenerationPipeline) {
                    await printSystemOutput('Loading text generation model (this may take a moment on first run)...');
                    textGenerationPipeline = await pipeline('text-generation', 'Xenova/distilgpt2');
                    await printSystemOutput('Model loaded successfully.');
                }
                await printSystemOutput(`Generating text from prompt: \"${prompt}\"`)
                const result = await textGenerationPipeline(prompt, { max_new_tokens: 50 });
                return `Generation complete:\n\n${result[0].generated_text}`;
            } catch (error) {
                console.error('Text Generation Error:', error);
                return 'Error during text generation. The model may have failed to load. Check the browser console.';
            }
        }

        async function fetchWikipedia(term) { let output = `Ricerca su Wikipedia per \"${term}\"...`; try { const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`; const searchResponse = await fetch(searchUrl); if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`); const searchData = await searchResponse.json(); if (!searchData.query.search || searchData.query.search.length === 0) { throw new Error(`Nessun risultato trovato per \"${term}\".`); } const searchResults = searchData.query.search; if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) { let disambiguation = false; if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true; if(disambiguation || searchResults.length > 2) { let suggestionText = `\nTrovati più risultati per \"${term}\". Essere più specifici:\n`; searchResults.slice(0, 5).forEach(res => { suggestionText += `  - ${res.title}\n`; }); suggestionText += `Esempio: wiki \"${searchResults[0].title}\"`; return output + suggestionText; } } const pageTitle = searchResults[0].title; output += `\nTrovata pagina: \"${pageTitle}\".\nRecupero riassunto...`; const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`; const summaryResponse = await fetch(summaryUrl); if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`); const summaryData = await summaryResponse.json(); const pages = summaryData.query.pages; const pageId = Object.keys(pages)[0]; const extract = pages[pageId].extract; if (extract) { return output + `\n${extract}`; } else { throw new Error(`Nessun riassunto disponibile per \"${pageTitle}\".`); } } catch (error) { return output + `\nErrore durante la ricerca su Wikipedia: ${error.message}`; } }
        async function fetchWeather(city) { let output = `Ricerca coordinate per ${city}...`; try { const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`); if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`); const geoData = await geoResponse.json(); if (!geoData.results || geoData.results.length === 0) { throw new Error(`Località non trovata: ${city}`); } const uniqueLocations = []; const seen = new Set(); for (const loc of geoData.results) { const identifier = `${loc.name}, ${loc.admin1 || loc.country}`; if (!seen.has(identifier)) { uniqueLocations.push(loc); seen.add(identifier); } } let location; if (uniqueLocations.length > 1 && !city.includes(',')) { let suggestionText = `\nTrovate più località per \"${city}\". Essere più specifici:\n`; uniqueLocations.slice(0, 3).forEach(loc => { suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\n`; }); suggestionText += `Esempio: weather \"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\"`; return output + suggestionText; } else { location = uniqueLocations[0]; } const { latitude, longitude, name, admin1, country_code } = location; const locationName = `${name}, ${admin1 || country_code}`; output += `\nCoordinate trovate per ${locationName}.\nRecupero dati meteo...`; const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`); if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`); const weatherData = await weatherResponse.json(); const { temperature, windspeed, weathercode } = weatherData.current_weather; const weatherDescription = getWeatherDescription(weathercode); return output + `\nMeteo attuale per ${locationName}:\n` + `  - Descrizione: ${weatherDescription}\n` + `  - Temperatura: ${temperature}°C\n` + `  - Vento: ${windspeed} km/h`; } catch (error) { return output + `\nErrore durante il recupero del meteo: ${error.message}`; } }
        function getWeatherDescription(code) { const descriptions = { 0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso', 45: 'Nebbia', 48: 'Nebbia con brina', 51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa', 61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte', 71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte', 80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento', 95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante' }; return descriptions[code] || 'Condizioni non specificate'; }
        async function fetchNews(limit = 3) { let output = `Recupero ${limit} notizie dal web...`; try { const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); let newsHeadlines = '\nUltime notizie recuperate:\n'; data.forEach((article, index) => { const title = article.title.charAt(0).toUpperCase() + article.title.slice(1); newsHeadlines += `\n[${index + 1}] ${title}`; }); return output + newsHeadlines; } catch (error) { return output + `\nErrore durante il recupero delle notizie: ${error.message}`; } }
        async function typeLorelMessage(text) { const messageDiv = document.createElement('div'); messageDiv.className = 'msg lorel'; history.appendChild(messageDiv); scrollToBottom(); const chunks = text.split('\n'); for (let i = 0; i < chunks.length; i++) { const chunk = chunks[i]; if (i > 0) { messageDiv.innerText += '\n'; const pauseDuration = 250 + Math.random() * 300; await new Promise(resolve => setTimeout(resolve, pauseDuration)); } for (let j = 0; j < chunk.length; j++) { const char = chunk.charAt(j); messageDiv.innerText += char; playKeySound(); scrollToBottom(); const speed = 30 + (Math.random() * 25); await new Promise(resolve => setTimeout(resolve, speed)); if (char === ',') { await new Promise(resolve => setTimeout(resolve, 250 + Math.random() * 100)); } else if (char === '.' || char === '!' || char === '?') { await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 150)); } } } saveChatHistory(); }
        async function printSystemOutput(text) { const div = document.createElement('div'); div.className = 'msg lorel'; const pre = document.createElement('pre'); div.appendChild(pre); history.appendChild(div); scrollToBottom(); const lines = text.split('\n'); for (const line of lines) { pre.textContent += line + '\n'; scrollToBottom(); await new Promise(r => setTimeout(r, 50)); } saveChatHistory(); }
        function addLorelMessage(text, isHtml = false) { const div = document.createElement('div'); div.className = 'msg lorel'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }
        function addUserMessage(text, isHtml = false) { const div = document.createElement('div'); div.className = 'msg user'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }
        function saveChatHistory() { localStorage.setItem('chatHistory', history.innerHTML); }
        function loadHistory() { const savedCommandHistory = localStorage.getItem('commandHistory'); if(savedCommandHistory) { commandHistory = JSON.parse(savedCommandHistory); historyIndex = commandHistory.length; } const savedChat = localStorage.getItem('chatHistory'); if (savedChat) { history.innerHTML = savedChat; } }
        
        function displayInitialMessages() {
            const messages = [
                '[SYSTEM] Initializing core memory... OK',
                '[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span>',
                '[UPDATE] Session persistence enabled via localStorage. History is now saved.',
                '[AESTHETICS] Keystroke audio feedback enabled.',
                '[SYSTEM] Advanced command parser implemented. Now supports quoted arguments and flags.',
                '[AESTHETICS] Title animation upgraded to a dynamic, cyclical typewriter effect.',
                '[OPTIMIZATION] Blinking cursor animation refined for code simplicity and efficiency.',
                '[REFINEMENT] Typing speed now has random variations for a more organic feel.',
                '[IMMERSION] Ambient static hum enabled for a complete CRT experience.',
                '[REFINEMENT] Long responses are now streamed chunk-by-chunk for a more dynamic feel.',
                '[AESTHETICS] Added chromatic aberration text animation for enhanced visual authenticity.',
                '[AESTHETICS] Monitor bezel effect added to encapsulate the interface.',
                '[AESTHETICS] Added moving scanline effect to simulate CRT refresh cycle.',
                '[INTEGRATION] User input now handled by a robust, invisible `<input>` for improved compatibility.',
                '[LEXICAL ANALYSIS] User command syntax is now highlighted in real-time for instant feedback.',
                '[ASSISTANCE] Command autocompletion (Tab key) is now active for predictive input.',
                '[VISUALIZATION] Data visualization enabled via ASCII charts. Try the \'stats\' command.',
                '[VISUALIZATION] Data tabulation enabled via ASCII tables. Try the \'sysinfo\' command.',
                `[REFINEMENT] Lorel's typing rhythm is now more natural, with conversational pauses.`,
                `[AESTHETICS] 'ONLINE' status indicator is now animated with a pulsing glow effect.`,
                `[ASSISTANCE] Inline command autocompletion suggestions ('ghost text') are now active.`,
                `[SYSTEM] Reboot Protocol module loaded. Type 'reboot' to restart the interface.`,
                '[IMMERSION] Reboot sequence now features a simulated BIOS POST screen with an audible beep.',
                '[IMMERSION] Boot sequence upgraded with an animated ASCII logo and startup sound.',
                '[SECURITY] System access now requires authentication via Login Protocol.',
                `[SYSTEM] Session now user-aware. Prompt reflects logged-in user. Added 'whoami' command.`,
                '[SYSTEM] Simulated file system is now active. Try commands: ls, cd, cat, pwd.',
                '[SYSTEM] Identity module added. Try the new `neofetch` command for system info.',
                '[REFINEMENT] Command output (help, stats) now streams line-by-line for greater immersion.',
                '[INTERACTIVITY] File system is now writeable. Use `mkdir` and `touch` to create directories and files.',
                '[DESTRUCTIVE] File system now supports deletion. Use `rm` to remove files and directories.',
                '[SYSTEM] I/O Redirection enabled. Use > to write and >> to append command output to files.',
                '[SYSTEM] File content access enabled. Use `cat` to display the contents of files.',
                `[IMMERSION] System command output now uses a mechanical 'print' effect, distinct from Lorel's conversational typing.`,
                `[AI CORE] Transformers.js library integrated. New 'sentiment' command available for testing.`,
                `[AI CORE] Text generation pipeline integrated. Use the 'generate' command to create text.`,
                `[IMMERSION] System now displays a 'Message of the Day' (MOTD) on first login.`,
                `[DEVELOPMENT] Internal scripting engine loaded. Use the 'run' command to execute JavaScript files.`,
                `[DEVELOPMENT] Scripting engine upgraded with a sandboxed File System API (fs.readFile, fs.writeFile).`,
                `[DEVELOPMENT] Internal text editor implemented. Use the 'edit' command to create and modify files.`,
                `[SYSTEM] Rudimentary Process Manager loaded. Use 'bg', 'ps', and 'kill' to manage background tasks.`
            ];
            let content = '';
            messages.forEach(msg => {
                content += `<div class=\"sys-msg\">${msg}</div>`;
            });
            initialMessagesContainer.innerHTML = content;
        }

        function scrollToBottom() { terminalContainer.scrollTop = terminalContainer.scrollHeight; }
        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('it-IT'); clock.textContent = timeString; }
        
        window.onload = () => {
            initializeGlobalListeners();
            initLoginScreen();
        }

    </script>
</body>
</html>