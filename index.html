<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-w_idth, initial-scale=1.0">
    <title>LOREL AXUN V9.8 // DESKTOP SELECTION BOX</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1"></script>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --term-green: #33ff00;
            --term-dim: #1a8000;
            --term-glow: #33ff0080;
            --cmd-highlight: #00ffff;
            --bios-text: #cccccc;
            --error-red: #ff3333;
            --dir-blue: #87cefa; /* Light Sky Blue for directories */
            --window-bg: #111111;
            --window-border: #222222;
            --header-bg: var(--term-green);
            --header-text: var(--bg-color);
        }
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #000;
        }
        body {
            height: 100%;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: var(--term-green);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .monitor-bezel {
            background-color: #1a1a1a; /* Dark gray for plastic */
            border-radius: 25px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.8);
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
        }

        .screen {
            flex: 1;
            background-color: var(--bg-color);
            border-radius: 10px; /* Inner screen roundness */
            overflow: hidden; /* Contains the screen content and effects */
            position: relative; /* For the ::before/::after pseudo-elements */
            display: flex;
            flex-direction: column;
            transition: opacity 0.5s ease-in-out;
        }

        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        .crt::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }
        }
        
        .moving-scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: rgba(51, 255, 0, 0.1);
            box-shadow: 0 0 10px rgba(51, 255, 0, 0.3);
            z-index: 3;
            pointer-events: none;
            animation: scanline-scroll 5s linear infinite;
        }
        @keyframes scanline-scroll {
            0% {
                transform: translateY(0vh);
            }
            100% {
                transform: translateY(100vh);
            }
        }

        #desktop {
            width: 100%;
            height: calc(100% - 30px); /* Leave space for taskbar */
            position: relative;
        }
        
        #desktop-icons {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .desktop-icon {
            position: absolute;
            width: 80px;
            text-align: center;
            cursor: pointer;
            user-select: none;
            padding: 5px;
        }
        .desktop-icon.selected .icon-label, .desktop-icon:hover .icon-label {
            background-color: var(--term-green);
            color: var(--bg-color);
        }
        .desktop-icon.selected {
            outline: 1px dotted var(--cmd-highlight);
        }
        .desktop-icon pre {
            font-size: 2.5rem;
            margin: 0;
            line-height: 1;
            text-shadow: 0 0 5px var(--term-glow);
        }
        .desktop-icon .icon-label {
            font-size: 0.9rem;
            word-wrap: break-word;
            margin-top: 5px;
        }

        #selection-box {
            position: absolute;
            border: 1px dashed var(--term-green);
            background-color: rgba(51, 255, 0, 0.2);
            z-index: 5000;
            display: none;
        }

        .window {
            position: absolute;
            background: var(--window-bg);
            border: 2px solid var(--window-border);
            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 10px var(--term-glow);
            display: flex;
            flex-direction: column;
            z-index: 100;
            resize: both;
            overflow: auto;
            min-width: 200px; /* Prevent shrinking too much */
            min-height: 100px; /* Prevent shrinking too much */
        }
        
        .window-header {
            background: var(--header-bg);
            color: var(--header-text);
            padding: 3px 8px;
            font-weight: bold;
            cursor: move;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 25px;
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        
        .window-title { white-space: pre; }
        
        .window-controls span {
            display: inline-block;
            width: 15px;
            height: 15px;
            text-align: center;
            line-height: 15px;
            margin-left: 5px;
            border: 1px solid var(--header-text);
            cursor: pointer;
        }
        .window-controls span:hover { background: rgba(0,0,0,0.2); }

        .window-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .terminal-container {
            padding: 10px;
            flex: 1;
            overflow-y: auto;
            width: 100%;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--term-glow);
            display: flex;
            flex-direction: column;
        }

        h1 {
            border-bottom: 2px solid var(--term-green);
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            height: 1.5rem; /* Reserve space for typewriter */
        }

        #typewriter-title .title-cursor {
            display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
        }

        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }
        .sys-msg span { color: var(--term-green); font-weight: bold; }

        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}
        #initial-messages { display: flex; flex-direction: column; gap: 0px; margin-bottom:10px; }

        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }
        .msg.lorel::before { content: "LOREL_SYS>> "; color: var(--term-green); }
        .msg.user::before { content: "USER_INPUT>> "; color: #00ffff; }
        .msg.user { color: #ccffff; }

        .msg pre {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            margin: 0;
            white-space: pre-wrap;
            line-height: 1.2;
        }
        .msg .fs-dir { color: var(--dir-blue); font-weight: bold; }

        mark {
            background-color: var(--term-dim);
            color: var(--term-green);
            text-shadow: none;
            padding: 0 3px;
        }

        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; position: relative;}
        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }
        .prompt.listening::after {
            content: '_';
            animation: blink 0.8s step-end infinite;
            padding-left: 5px;
            color: var(--term-dim);
        }

        #command-line .command-known {
            color: var(--cmd-highlight);
            font-weight: bold;
        }
        
        #autocomplete-suggestion {
            color: var(--term-dim);
            opacity: 0.7;
            pointer-events: none; /* Make it non-interactive */
        }

        #hidden-input {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            height: 1.2rem;
            background: transparent;
            border: none;
            color: transparent;
            caret-color: transparent;
            outline: none;
            padding: 0;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            z-index: -1;
        }

        #cursor {
            background: var(--term-green);
            display: inline-block;
            width: 10px;
            height: 1.2rem;
            animation: blink 1s step-end infinite;
            box-shadow: 0 0 5px var(--term-glow);
            vertical-align: middle;
        }
        @keyframes blink {
            50% { opacity: 0.0; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }

        .glitch {
            position: relative;
        }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
        }
        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);
            animation: glitch-anim-2 2.5s infinite steps(8) reverse;
        }
        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
            animation: glitch-anim-2 2.5s infinite steps(8);
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }
        }

        .chromatic-aberration {
            animation: text-flicker 3s linear infinite;
        }

        @keyframes text-flicker {
            0% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            15% { text-shadow: 1.5px 0 0 red, -1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            30% { text-shadow: -1px 0 0 red, 1px 0 0 cyan, 0 0 5px var(--term-glow); }            45% { text-shadow: -1.5px 0 0 red, 1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            60% { text-shadow: 0.5px 0.5px 0 red, -0.5px -0.5px 0 cyan, 0 0 5px var(--term-glow); }            75% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            100% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }
        }

        .status-bar {
            background-color: var(--term-green);
            color: var(--bg-color);
            padding: 2px 10px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            height: 25px;
        }
        .status-bar span {
            font-weight: bold;
        }

        .pulse-glow {
            animation: pulse 1.5s infinite ease-in-out;
        }
        @keyframes pulse {
            0% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }            50% { text-shadow: 0 0 5px var(--bg-color), 0 0 10px #000; }            100% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }
        }

        #bios-overlay, #boot-logo-overlay, #login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            font-family: 'VT323', monospace;
            padding: 20px;
            box-sizing: border-box;
            display: none;
            white-space: pre;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10000;
        }
        #bios-overlay {
             color: var(--bios-text);
             align-items: flex-start;
             justify-content: flex-start;
        }
        #boot-logo-overlay {
            z-index: 9999;
        }
        #boot-logo-overlay pre {
            color: var(--term-green);
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--term-glow);
            animation: logo-fade-glitch 3.5s ease-in-out forwards;
            line-height: 1.2;
            text-align: center;
        }
        @keyframes logo-fade-glitch {
            0% { opacity: 0; transform: translateY(10px); }            10% { opacity: 1; transform: translateY(0); }            20% { text-shadow: 0 0 15px var(--term-glow), 2px 0 red, -2px 0 cyan; }            21% { text-shadow: 0 0 10px var(--term-glow); }            80% { opacity: 1; }            100% { opacity: 0; }
        }

        #login-overlay {
            z-index: 9998;
            font-size: 1.5rem;
            color: var(--term-green);
            text-shadow: 0 0 5px var(--term-glow);
        }
        .login-box {
            border: 2px solid var(--term-green);
            padding: 2rem 4rem;
            box-shadow: 0 0 15px var(--term-glow) inset;
        }
        .login-prompt {
            display: flex;
            align-items: center;
            margin: 1rem 0;
        }
        .login-cursor {
             display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
            margin-left: 5px;
        }
        #login-error-message {
            color: var(--error-red);
            text-shadow: 0 0 5px var(--error-red);
            height: 1.5rem;
            margin-top: 1rem;
            text-align: center;
            animation: error-flicker 0.2s infinite;
        }
        @keyframes error-flicker {
            50% { opacity: 0.7; }
        }

        #editor-textarea {
            background: transparent;
            border: none;
            color: var(--term-green);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 10px;
            resize: none;
            outline: none;
            text-shadow: 0 0 5px var(--term-glow);
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        #top-content {
            padding: 10px;
            overflow: hidden;
            white-space: pre;
            text-shadow: 0 0 5px var(--term-glow);
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        #taskbar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            background: var(--window-border);
            border-top: 2px solid var(--term-green);
            display: flex;
            align-items: center;
            padding: 0;
            z-index: 9000;
        }
        #start-button {
            background: var(--term-green);
            color: var(--bg-color);
            font-weight: bold;
            padding: 0 15px;
            height: 100%;
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            border-right: 2px solid var(--term-green);
        }
        #start-button:hover { background: #8eff7f; }

        #taskbar-apps {
            flex-grow: 1;
            display: flex;
            align-items: center;
            height: 100%;
            overflow-x: auto;
            padding: 0 5px;
        }

        #system-tray {
            height: 100%;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-left: 2px solid var(--term-dim);
        }
        #taskbar-clock { font-size: 1.1rem; }

        .taskbar-item {
            background: var(--term-dim);
            color: var(--term-green);
            border: 1px solid var(--term-green);
            padding: 2px 10px;
            margin-right: 5px;
            cursor: pointer;
            white-space: nowrap;
            flex-shrink: 0;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background 0.2s;
        }
        .taskbar-item:hover { background: var(--term-green); color: var(--bg-color); }
        .taskbar-item.active { background: var(--term-green); color: var(--bg-color); font-weight: bold; }
        .taskbar-item.minimized { background: var(--window-bg); color: var(--term-dim); border-style: dashed; }

        #start-menu, #context-menu {
            position: absolute;
            background: var(--window-bg);
            border: 2px solid var(--term-green);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 9999;
            padding: 10px;
            min-width: 250px;
            display: none;
        }
        #start-menu {
            bottom: 30px; /* Height of the taskbar */
            left: 0;
        }
        .start-menu-section {
            margin-bottom: 10px;
        }
        .start-menu-header {
            color: var(--cmd-highlight);
            border-bottom: 1px solid var(--term-dim);
            padding-bottom: 5px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .start-menu-item, .context-menu-item {
            padding: 4px 8px;
            cursor: pointer;
            display: block;
            user-select: none;
        }
        .start-menu-item:hover, .context-menu-item:hover {
            background: var(--term-green);
            color: var(--bg-color);
        }

    </style>
</head>
<body>
    <div id="bios-overlay"></div>
    <div id="boot-logo-overlay"></div>
    <div id="login-overlay"></div>

    <div class="monitor-bezel" id="monitor-bezel" style="display: none;">
        <div class="screen crt" id="main-screen">
            <div class="moving-scanline"></div>
            <div id="desktop">
                <div id="desktop-icons"></div>
                <div id="selection-box"></div>
                <!-- Windows will be injected here by JS -->
            </div>
            <div id="taskbar">
                <div id="start-button">L.A.O.S.</div>
                <div id="taskbar-apps">
                    <!-- Taskbar items will be injected here -->
                </div>
                <div id="system-tray">
                    <span id="taskbar-clock"></span>
                </div>
            </div>
             <div id="start-menu"></div>
             <div id="context-menu"></div>
        </div>
    </div>

    <audio id="static-hum" loop src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8CAP3/AwD+/wEAAgD9/wEA/v8CAP7/AgD9/wMA/v8CAP7/AwD+/wE="></audio>
    <audio id="startup-sound" src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8/wD7APgA+wD4AP8A+wD8AP4A/AD9AP0A/QD8AP0A/QD9APwA/QD7APwA+wD7APgA+QD5APsA+QD5APkA+QD4APgA+AD4APc=+"></audio>
    <audio id="login-success-sound" src="data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVgAAAAIAAD/AP8A/wD/AP8A/wD/AAABAAEBAgADAgMDBAQEBgYIBwkKCw0ODxAREhMUFRYXGBkbHR4fICEiJCUnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW11eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAA=="></audio>
    <audio id="login-fail-sound" src="data:audio/wav;base64,UklGRiwAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQgAAAAAAAD/AP4A/QD7APYA9ADwAOwA6ADlANsA1QDHAMQAwgC/ALsAsQCiAIcAfwB3AHQAcQBwAGoAZQBgAFwAVQBRAEsARgBDAEAAOQAyACsAJQAgABwAGQAVABEADgAKAAcABAAAAAAA//8="></audio>

    <script>
        // --- asciichart.js (embedded) ---
        // Copyright (c) 2017, Andrei Kashcha
        // All rights reserved.
        const asciichart = (function() {
            function colored (char, color) {
                return (color === undefined) ? char : ('<span style="color: ' + color + '">' + char + '</span>')
            }
            function plot (series, cfg = undefined) {
                let min = (cfg && cfg.min !== undefined) ? cfg.min : series[0]
                let max = (cfg && cfg.max !== undefined) ? cfg.max : series[0]

                for (let i = 1; i < series.length; i++) {
                    min = Math.min(min, series[i])
                    max = Math.max(max, series[i])
                }

                let defaultSymbols = [ '┼', '┤', '╶', '╴', '─', '╰', '╯', '│', '╭', '╮', '│' ]
                let range = Math.abs (max - min)
                let offset = (cfg && cfg.offset !== undefined) ? cfg.offset : 3
                let padding = (cfg && cfg.padding !== undefined) ? cfg.padding : '           '
                let height = (cfg && cfg.height !== undefined) ? cfg.height : range
                let ratio = (range !== 0) ? height / range : 1;
                let min2 = Math.round (min * ratio)
                let max2 = Math.round (max * ratio)
                let rows = Math.abs (max2 - min2)
                let width = (cfg && cfg.width !== undefined) ? cfg.width : series.length + offset

                let result = new Array (rows + 1)
                for (let i = 0; i < rows + 1; i++) {
                    result[i] = new Array (width)
                    for (let j = 0; j < width; j++) {
                        result[i][j] = ' '
                    }
                }
                let y_labels = []
                for (let i = 0; i <= rows; i++) {
                  let y = max - (i * (range / rows))
                  y_labels.push(y.toFixed(2).padStart(padding.length - 2) + ' ' + defaultSymbols[0])
                }

                for (let y = min2; y <= max2; y++) {
                    result[rows - (y - min2)][offset - 1] = defaultSymbols[0]
                }

                for (let x = 0; x < series.length; x++) {
                    let y0 = Math.round (series[x] * ratio) - min2
                    result[rows - y0][x + offset] = defaultSymbols[4]

                    if (x > 0) {
                        let y1 = Math.round(series[x - 1] * ratio) - min2;
                        if (y0 == y1) {
                            result[rows - y0][x + offset -1] = defaultSymbols[4];
                        }
                    }
                }

                let lines = []
                for(let i=0; i < result.length; i++) {
                  lines.push(y_labels[i] + result[i].join(''))
                }

                return lines.join('\n')
            }
            return { plot: plot }
        })()

        // --- Lorel's Core Script ---
        // DOM Elements
        const desktop = document.getElementById('desktop');
        const taskbar = document.getElementById('taskbar');
        const taskbarApps = document.getElementById('taskbar-apps');
        const startButton = document.getElementById('start-button');
        const startMenu = document.getElementById('start-menu');
        const contextMenu = document.getElementById('context-menu');
        const taskbarClock = document.getElementById('taskbar-clock');
        const biosOverlay = document.getElementById('bios-overlay');
        const bootLogoOverlay = document.getElementById('boot-logo-overlay');
        const loginOverlay = document.getElementById('login-overlay');
        const mainScreen = document.getElementById('main-screen');
        const monitorBezel = document.getElementById('monitor-bezel');

        // State Variables
        let commandHistory = [];
        let historyIndex = -1;
        let userHasInteracted = false;
        let audioCtx = null;
        let currentUser = 'user';
        let cwd = '/home/admin'; // Current Working Directory
        let loginState = { active: false, step: 'username', username: '', password: '' };
        let editorState = { active: false, filePath: null, windowEl: null };
        let topState = { active: false, intervalId: null, windowEl: null };
        let processList = {};
        let nextPid = 1;
        let sentimentPipeline = null;
        let textGenerationPipeline = null;
        let installedPackages = {};
        let highestZ = 100;

        // --- Window Manager --- 
        function createDraggableWindow(id, title, width, height, top, left) {
            highestZ++;
            const win = document.createElement('div');
            win.id = id;
            win.className = 'window';
            win.style.width = width + 'px';
            win.style.height = height + 'px';
            win.style.top = top + 'px';
            win.style.left = left + 'px';

            const header = document.createElement('div');
            header.className = 'window-header';
            header.innerHTML = `<span class=\"window-title\">${title}</span><div class=\"window-controls\"><span class=\"wc-minimize\">_</span><span class=\"wc-close\">x</span></div>`;

            const content = document.createElement('div');
            content.className = 'window-content';

            win.appendChild(header);
            win.appendChild(content);
            desktop.appendChild(win);

            // Taskbar integration
            const taskbarItem = document.createElement('div');
            taskbarItem.className = 'taskbar-item';
            taskbarItem.textContent = title;
            taskbarItem.dataset.windowId = id;
            taskbarApps.appendChild(taskbarItem);

            win.dataset.taskbarId = id; // Link window to taskbar item

            function focusWindow() {
                win.style.zIndex = ++highestZ;
                document.querySelectorAll('.taskbar-item').forEach(item => item.classList.remove('active'));
                taskbarItem.classList.add('active');
                taskbarItem.classList.remove('minimized');
            }
            
            focusWindow(); // Focus on creation

            // Make draggable
            let isDragging = false;
            let offsetX, offsetY;

            const onMouseDown = (e) => {
                if (e.target.classList.contains('window-controls') || e.target.parentElement.classList.contains('window-controls')) return;
                isDragging = true;
                offsetX = e.clientX - win.offsetLeft;
                offsetY = e.clientY - win.offsetTop;
                focusWindow();
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };

            const onMouseMove = (e) => {
                if (isDragging) {
                    win.style.left = `${e.clientX - offsetX}px`;
                    win.style.top = `${e.clientY - offsetY}px`;
                }
            };

            const onMouseUp = () => {
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            
            header.addEventListener('mousedown', onMouseDown);
            win.addEventListener('mousedown', () => {
                focusWindow();
                hideStartMenu();
                hideContextMenu();
            });

            // Window Controls
            win.querySelector('.wc-close').onclick = () => {
                if (win.id === 'top-window') exitTopMode();
                else if (win.id === 'editor-window') exitEditorWithoutSaving();
                else {
                    win.remove();
                    taskbarItem.remove();
                }
            };

            win.querySelector('.wc-minimize').onclick = () => {
                win.style.display = 'none';
                taskbarItem.classList.add('minimized');
                taskbarItem.classList.remove('active');
            };

            taskbarItem.onclick = () => {
                if (win.style.display === 'none') { // Is minimized
                    win.style.display = 'flex';
                    focusWindow();
                } else { // Is visible
                    if (taskbarItem.classList.contains('active')) {
                        win.style.display = 'none';
                        taskbarItem.classList.add('minimized');
                        taskbarItem.classList.remove('active');
                    } else {
                        focusWindow();
                    }
                }
                hideStartMenu();
                hideContextMenu();
            };

            return { windowEl: win, contentEl: content };
        }

        // --- Persistence Layer (IndexedDB) ---
        const dbManager = (() => {
            const DB_NAME = 'LorelAxunOS_V9';
            const DB_VERSION = 1;
            const FS_STORE = 'fileSystem';
            const PKG_STORE = 'packages';
            let db;

            const init = () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = (event) => {
                        const dbInstance = event.target.result;
                        if (!dbInstance.objectStoreNames.contains(FS_STORE)) {
                            dbInstance.createObjectStore(FS_STORE);
                        }
                        if (!dbInstance.objectStoreNames.contains(PKG_STORE)) {
                            dbInstance.createObjectStore(PKG_STORE);
                        }
                    };
                    request.onsuccess = (event) => {
                        db = event.target.result;
                        resolve(db);
                    };
                    request.onerror = (event) => {
                        console.error('IndexedDB error:', event.target.errorCode);
                        reject(event.target.errorCode);
                    };
                });
            };

            const saveData = (storeName, key, data) => {
                if (!db) return Promise.reject('DB not initialized');
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data, key);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            };

            const loadData = (storeName, key) => {
                if (!db) return Promise.reject('DB not initialized');
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            };

            return {
                init,
                saveFileSystem: (fsData) => saveData(FS_STORE, 'mainFileSystem', fsData),
                loadFileSystem: () => loadData(FS_STORE, 'mainFileSystem'),
                savePackages: (pkgData) => saveData(PKG_STORE, 'installedPackages', pkgData),
                loadPackages: () => loadData(PKG_STORE, 'installedPackages')
            };
        })();

        // Simulated Resource Monitor
        setInterval(() => {
            for (const pid in processList) {
                let process = processList[pid];
                // Fluctuate CPU
                let cpuChange = (Math.random() - 0.5) * 0.5;
                process.cpu = Math.max(0.1, parseFloat(process.cpu) + cpuChange).toFixed(2);
                // Fluctuate Memory
                let memChange = (Math.random() - 0.5) * 0.2;
                process.mem = Math.max(1.0, parseFloat(process.mem) + memChange).toFixed(2);
            }
        }, 2000); // Update every 2 seconds

        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear', 'stats', 'sysinfo', 'reboot', 'whoami', 'ls', 'cd', 'cat', 'pwd', 'neofetch', 'mkdir', 'touch', 'rm', 'sentiment', 'generate', 'run', 'edit', 'ps', 'kill', 'bg', 'top', 'lax'];
        
        // --- Simulated File System (Default State) ---
        const defaultFileSystem = {
            '/': { type: 'dir', children: ['home', 'var', 'README'] },
            '/home': { type: 'dir', children: ['admin'] },
            '/home/admin': { type: 'dir', children: ['docs', 'welcome.txt', 'demo.js', 'fs_demo.js', 'notes.txt', 'logger.js'] },
            '/home/admin/docs': { type: 'dir', children: ['project.txt'] },
            '/home/admin/docs/project.txt': { type: 'file', content: 'Project Phoenix: An initiative to expand conversational AI capabilities using in-browser transformers.' },
            '/home/admin/welcome.txt': { type: 'file', content: 'Benvenuto nel sistema L.A.O.S. v9.8!\nQuesto è un file system persistente grazie a IndexedDB.\nFai doppio click su un\'icona del desktop per aprire un file.' },
            '/home/admin/notes.txt': { type: 'file', content: 'Questa è una nota di prova.\nPuoi modificare questo file con il comando `edit`.' },
            '/home/admin/demo.js': { type: 'file', content: 'terminal.log("Ciao dal mio primo script!");\nfor (let i = 1; i <= 3; i++) {\n  terminal.log(`Esecuzione ciclo: ${i}`);\n}\nterminal.log("Script completato.");' },
            '/home/admin/fs_demo.js': { type: 'file', content: '// Demo script for the new File System API\nterminal.log("--- Esecuzione FS Demo Script ---");\nconst filePath = \'welcome.txt\';\nconst newFilePath = \'welcome_copy.txt\';\nterminal.log(`Lettura del file: ${filePath}...`);\nfs.readFile(filePath, (err, data) => {\n    if (err) {\n        terminal.log(`ERRORE: ${err}`);\n        return;\n    }\n    terminal.log(\'Contenuto letto con successo.\');\n    const newData = data + \'\\n\\n(Copia generata dallo script fs_demo.js)\';\n    terminal.log(`Scrittura del nuovo file: ${newFilePath}...`);\n    fs.writeFile(newFilePath, newData, (err) => {\n        if (err) {\n            terminal.log(`ERRORE: ${err}`);\n            return;\n        }\n        terminal.log(\'Nuovo file scritto con successo! Prova a usare `cat welcome_copy.txt`\');\n        terminal.log(\'--- Script completato ---\'');\n    });\n});' },
            '/home/admin/logger.js': { type: 'file', content: '// Background Process Demo\n// This script logs a message every 5 seconds.\nterminal.log(`[BG SCRIPT] Logger started at ${new Date().toLocaleTimeString()}. Will log every 5s.`);' },
            '/var': { type: 'dir', children: ['log'] },
            '/var/log': { type: 'dir', children: ['system.log'] },
            '/var/log/system.log': { type: 'file', content: 'LOG START\n2025-11-23 10:00:01 | System boot sequence initiated.\n2025-11-23 10:00:05 | Login protocol engaged.\n2025-11-23 10:00:12 | User `admin` authenticated successfully.\n2025-11-23 10:00:13 | Session started.\nLOG END' },
            '/README': { type: 'file', content: 'Lorel Axun Operating System (L.A.O.S.)\nVersione: 9.8 - Desktop Selection Box\nCreatore: AleXsjsju' },
        };
        let fileSystem = {};
        
        // --- Simulated Package Manager ---
        const packageRepository = {
            'cowsay': {
                description: 'An ASCII cow says whatever you want.',
                version: '1.0.0',
                execute: (args) => {
                    const what = args.join(' ') || 'Moo-ve along!';
                    const len = what.length;
                    const top = ' ' + '_'.repeat(len + 2);
                    const bottom = ' ' + '-'.repeat(len + 2);
                    const cow = `\n ${top}\n< ${what} >\n ${bottom}\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n`;
                    return cow;
                }
            },
            'fortune': {
                description: 'Displays a random fortune cookie message.',
                version: '1.0.1',
                execute: () => {
                    const fortunes = [
                        "A beautiful, smart, and loving person will be coming into your life.",
                        "A dubious friend may be an enemy in camouflage.",
                        "Your success will astonish everyone.",
                        "You will travel to many exotic places in your lifetime.",
                        "The greatest risk is not taking one.",
                        "An alien of some sort will be appearing to you shortly.",
                        "Do not mistake temptation for opportunity."
                    ];
                    return fortunes[Math.floor(Math.random() * fortunes.length)];
                }
            }
        };

        // --- Dynamic Title Engine ---
        function initTitleTypewriter(target) {
            const phrases = [
                "Lorel Axun v9.8",
                "Status: ONLINE",
                "Selection Box Active",
                "Awaiting input..."
            ];
            let phraseIndex = 0;
            let charIndex = 0;
            let isDeleting = false;

            const typeSpeed = 100;
            const deleteSpeed = 50;
            const delay = 2000;

            function type() {
                const currentPhrase = phrases[phraseIndex];
                let displayText = '';

                if (isDeleting) {
                    displayText = currentPhrase.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    displayText = currentPhrase.substring(0, charIndex + 1);
                    charIndex++;
                }

                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;

                if (!isDeleting && charIndex === currentPhrase.length) {
                    isDeleting = true;
                    setTimeout(type, delay);
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    phraseIndex = (phraseIndex + 1) % phrases.length;
                    setTimeout(type, 500);
                } else {
                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);
                }
            }
            type();
        }

        // --- Audio Feedback Engine ---
        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
        const keySoundPoolSize = 10; 
        const keySoundPool = [];
        let keySoundIndex = 0;

        for (let i = 0; i < keySoundPoolSize; i++) {
            keySoundPool.push(new Audio(KEY_CLICK_SOUND));
        }

        function playSound(id) {
            if(!userHasInteracted) return;
            const sound = document.getElementById(id);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }

        function playKeySound() {
            playSound('keySoundPool' + keySoundIndex);
            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;
        }

        async function playBiosBeep() {
            return new Promise(resolve => {
                if (!audioCtx || !userHasInteracted) {
                    resolve();
                    return;
                }
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(900, audioCtx.currentTime); // High-pitched beep
                oscillator.type = 'sine';

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.15); // Beep for 150ms
                oscillator.onended = resolve;
            });
        }
        
        // --- NLU Engine ---
        const classifier = { intents: {}, train: function(intent, phrases) { if (!this.intents[intent]) this.intents[intent] = []; phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase))); }, tokenize: text => text.toLowerCase().replace(/[^a-z0-9\\s]/gi, '').split(/\\s+/).filter(Boolean), classify: function(text) { const tokens = this.tokenize(text); let bestMatch = { intent: 'unknown', score: 0 }; for (const intent in this.intents) { let intentScore = 0; this.intents[intent].forEach(phraseTokens => { const commonTokens = tokens.filter(token => phraseTokens.includes(token)); const score = commonTokens.length / phraseTokens.length; if (score > intentScore) intentScore = score; }); if (intentScore > bestMatch.score) { bestMatch = { intent, score: intentScore }; } } return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; } };
        const nerManager = { extractEntities: function(text, intent) { if (intent === 'weather') { const match = text.match(/(?:a|per|di|a)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'LOCATION' }; } } else if (intent === 'wiki') { const match = text.match(/(?:è|e'|di|su)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'TOPIC' }; } } return null; } };
        function initializeNLU() { classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']); classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']); classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']); classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']); classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']); }

        // --- Event Listeners ---
        function initializeGlobalListeners() {
            document.addEventListener('keydown', handleGlobalKeyPress, true);
            
            desktop.addEventListener('contextmenu', (e) => {
                if (e.target.id === 'desktop' || e.target.id === 'desktop-icons') {
                    showContextMenu(e);
                }
            });

            desktop.addEventListener('dragover', (e) => e.preventDefault());
            desktop.addEventListener('drop', handleDesktopDrop);

            document.addEventListener('click', (e) => {
                if (!startButton.contains(e.target) && !startMenu.contains(e.target)) {
                    hideStartMenu();
                }
                 if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });
            
            setupDesktopSelection();
        }
        
        function setupDesktopSelection() {
            let isSelecting = false;
            let selectionStartX, selectionStartY;

            desktop.addEventListener('mousedown', (e) => {
                if (e.target !== desktop && e.target !== document.getElementById('desktop-icons')) {
                    return;
                }
                
                document.querySelectorAll('.desktop-icon.selected').forEach(icon => icon.classList.remove('selected'));

                isSelecting = true;
                const desktopRect = desktop.getBoundingClientRect();
                selectionStartX = e.clientX - desktopRect.left;
                selectionStartY = e.clientY - desktopRect.top;

                const selectionBox = document.getElementById('selection-box');
                selectionBox.style.left = `${selectionStartX}px`;
                selectionBox.style.top = `${selectionStartY}px`;
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                selectionBox.style.display = 'block';

                document.addEventListener('mousemove', handleSelectionMove);
                document.addEventListener('mouseup', handleSelectionEnd);
            });

            function handleSelectionMove(e) {
                if (!isSelecting) return;

                const desktopRect = desktop.getBoundingClientRect();
                const currentX = e.clientX - desktopRect.left;
                const currentY = e.clientY - desktopRect.top;
                
                const selectionBox = document.getElementById('selection-box');
                const x = Math.min(selectionStartX, currentX);
                const y = Math.min(selectionStartY, currentY);
                const width = Math.abs(currentX - selectionStartX);
                const height = Math.abs(currentY - selectionStartY);

                selectionBox.style.left = `${x}px`;
                selectionBox.style.top = `${y}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;

                const selectionRect = selectionBox.getBoundingClientRect();
                const icons = document.querySelectorAll('.desktop-icon');

                icons.forEach(icon => {
                    const iconRect = icon.getBoundingClientRect();
                    const isIntersecting = !(
                        selectionRect.right < iconRect.left ||
                        selectionRect.left > iconRect.right ||
                        selectionRect.bottom < iconRect.top ||
                        selectionRect.top > iconRect.bottom
                    );

                    if (isIntersecting) {
                        icon.classList.add('selected');
                    } else {
                        icon.classList.remove('selected');
                    }
                });
            }

            function handleSelectionEnd(e) {
                isSelecting = false;
                const selectionBox = document.getElementById('selection-box');
                selectionBox.style.display = 'none';

                document.removeEventListener('mousemove', handleSelectionMove);
                document.removeEventListener('mouseup', handleSelectionEnd);
            }
        }

        function handleGlobalKeyPress(e) {
            if (e.key === 'Escape') {
                hideStartMenu();
                hideContextMenu();
            }

            if (editorState.active) {
                handleEditorKeys(e);
                return; // Stop propagation to terminal listeners
            }
            
            if (!userHasInteracted) {
                const hum = document.getElementById('static-hum');
                hum.volume = 0.05;
                hum.play().catch(err => {});
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                userHasInteracted = true;
            }

            if (loginState.active) {
                handleLoginInput(e);
            }
        }

        // --- Login Protocol ---
        function initLoginScreen() {
            loginState.active = true;
            loginState.step = 'username';
            loginState.username = '';
            loginState.password = '';
            currentUser = 'user'; // Reset on logout/reboot

            const loginHTML = `
                <div class=\"login-box\">
                    <pre>L.A.O.S. v9.8 (Lorel Axun Operating System)</pre>
                    <div class=\"login-prompt\">
                        <span>Username: </span>
                        <span id=\"login-user-input\"></span>
                        <span id=\"login-user-cursor\" class=\"login-cursor\"></span>
                    </div>
                    <div class=\"login-prompt\">
                        <span>Password: </span>
                        <span id=\"login-pass-input\"></span>
                        <span id=\"login-pass-cursor\" class=\"login-cursor\" style=\"display:none;\"></span>
                    </div>
                    <div id=\"login-error-message\"></div>
                </div>
            `;
            loginOverlay.innerHTML = loginHTML;
            loginOverlay.style.display = 'flex';
        }

        function handleLoginInput(e) {
            e.preventDefault();
            const key = e.key;

            playKeySound();

            if (key === 'Enter') {
                if (loginState.step === 'username') {
                    loginState.step = 'password';
                    document.getElementById('login-user-cursor').style.display = 'none';
                    document.getElementById('login-pass-cursor').style.display = 'inline-block';
                } else if (loginState.step === 'password') {
                    attemptLogin();
                }
                return;
            }

            if (key === 'Backspace') {
                if (loginState.step === 'username' && loginState.username.length > 0) {
                    loginState.username = loginState.username.slice(0, -1);
                } else if (loginState.step === 'password' && loginState.password.length > 0) {
                    loginState.password = loginState.password.slice(0, -1);
                } 
            } else if (key.length === 1) { // Regular character input
                if (loginState.step === 'username') {
                    loginState.username += key;
                } else if (loginState.step === 'password') {
                    loginState.password += key;
                }
            }
            updateLoginDisplay();
        }

        function updateLoginDisplay() {
            document.getElementById('login-user-input').textContent = loginState.username;
            document.getElementById('login-pass-input').textContent = '*'.repeat(loginState.password.length);
        }

        async function attemptLogin() {
            const errorEl = document.getElementById('login-error-message');
            errorEl.textContent = 'AUTHENTICATING...';
            await new Promise(r => setTimeout(r, 500));

            // Hardcoded credentials for simulation
            if (loginState.username === 'admin' && loginState.password === 'axun7.3') {
                playSound('login-success-sound');
                errorEl.style.color = 'var(--term-green)';
                errorEl.textContent = 'ACCESS GRANTED';
                currentUser = loginState.username;
                await new Promise(r => setTimeout(r, 1000));
                loginSuccess();
            } else {
                playSound('login-fail-sound');
                errorEl.style.color = 'var(--error-red)';
                errorEl.textContent = 'ACCESS DENIED';
                await new Promise(r => setTimeout(r, 1500));
                initLoginScreen(); // Reset the screen
            }
        }

        async function loginSuccess() {
            loginState.active = false;
            loginOverlay.style.opacity = '0';
            await new Promise(r => setTimeout(r, 500));
            loginOverlay.style.display = 'none';

            monitorBezel.style.display = 'flex';
            await new Promise(r => setTimeout(r, 100));
            mainScreen.style.opacity = '1';
            
            await initializeTerminal();
        }
        
        // --- Editor Functions ---
        function handleEditorKeys(e) {
            if (!editorState.active) return;
            if (e.ctrlKey && e.key.toLowerCase() === 's') {
                e.preventDefault();
                saveAndExitEditor();
            }
            else if (e.ctrlKey && e.key.toLowerCase() === 'x') {
                e.preventDefault();
                exitEditorWithoutSaving();
            }
        }

        async function enterEditorMode(filePath, content) {
            if (editorState.active) return;
            editorState.active = true;
            editorState.filePath = filePath;

            const { windowEl, contentEl } = createDraggableWindow('editor-window', `edit: ${filePath}`, 600, 400, 50, 250);
            editorState.windowEl = windowEl;
            
            const editorTextarea = document.createElement('textarea');
            editorTextarea.id = 'editor-textarea';
            editorTextarea.spellcheck = false;
            editorTextarea.value = content;
            contentEl.appendChild(editorTextarea);
            
            setTimeout(() => editorTextarea.focus(), 0);
        }

        async function saveAndExitEditor() {
            if (!editorState.active) return;
            const editorTextarea = editorState.windowEl.querySelector('#editor-textarea');
            const newContent = editorTextarea.value;
            const filePath = editorState.filePath;
            const targetPath = resolvePath(filePath);
            const parentPath = resolvePath(targetPath + '/..');
            const parentNode = fileSystem[parentPath];

            if (parentNode && parentNode.type === 'dir') {
                const targetNode = fileSystem[targetPath];
                if (!targetNode) { // New file
                     const filename = targetPath.split('/').pop();
                     parentNode.children.push(filename);
                     parentNode.children.sort();
                }
                fileSystem[targetPath] = { type: 'file', content: newContent };
                await dbManager.saveFileSystem(fileSystem); // PERSIST
                await exitEditorMode();
                await printSystemOutput(`File '${filePath}' saved.`);
            } else {
                await exitEditorMode();
                await printSystemOutput(`Error: Could not save file to invalid path '${filePath}'.`);
            }
        }

        async function exitEditorWithoutSaving() {
            const filePath = editorState.filePath;
            await exitEditorMode();
            await printSystemOutput(`Edit aborted. No changes were saved to '${filePath}'.`);
        }

        async function exitEditorMode() {
            if (!editorState.active) return;
            const taskbarItem = document.querySelector(`.taskbar-item[data-window-id=\"${
                editorState.windowEl.id
            }\"]`);
            if (taskbarItem) taskbarItem.remove();
            editorState.windowEl.remove();
            editorState.active = false;
            editorState.filePath = null;
            editorState.windowEl = null;
            document.getElementById('hidden-input').focus();
        }

        // --- Top (Live Monitor) Functions ---
        function enterTopMode() {
            if (topState.active) return;
            topState.active = true;
            const { windowEl, contentEl } = createDraggableWindow('top-window', 'top - Process Monitor', 650, 300, 80, 80);
            topState.windowEl = windowEl;

            const topContent = document.createElement('div');
            topContent.id = 'top-content';
            contentEl.appendChild(topContent);
            
            updateTopDisplay();
            topState.intervalId = setInterval(updateTopDisplay, 2000); // Refresh every 2 seconds
        }

        function exitTopMode() {
            if (!topState.active) return;
            clearInterval(topState.intervalId);
            topState.intervalId = null;
            const taskbarItem = document.querySelector(`.taskbar-item[data-window-id=\"${
                topState.windowEl.id
            }\"]`);
            if (taskbarItem) taskbarItem.remove();
            topState.windowEl.remove();
            topState.active = false;
            topState.windowEl = null;
            document.getElementById('hidden-input').focus();
        }

        function updateTopDisplay() {
            if (!topState.active) return;
            const topContent = topState.windowEl.querySelector('#top-content');

            const processArray = Object.entries(processList);
            const totalProcesses = processArray.length;
            let totalCpu = 0;
            let totalMem = 0;
            processArray.forEach(([pid, proc]) => {
                totalCpu += parseFloat(proc.cpu);
                totalMem += parseFloat(proc.mem);
            });

            // Sort processes by CPU usage, descending
            const sortedProcesses = processArray.sort((a, b) => parseFloat(b[1].cpu) - parseFloat(a[1].cpu));

            let contentText = '';
            const colHeaders = `  PID USER      CPU%   MEM(MB) UPTIME   COMMAND\n`;
            contentText += colHeaders;
            contentText += '-'.repeat(colHeaders.length) + '\n';

            sortedProcesses.forEach(([pid, proc]) => {
                const uptime = Math.floor((new Date() - proc.startTime) / 1000);
                const line = ` ${String(pid).padStart(4)} ${currentUser.padEnd(9)} ${proc.cpu.padStart(6)} ${proc.mem.padStart(8)} ${String(uptime).padStart(6)}s  ${proc.command}\n`;
                contentText += line;
            });

            topContent.textContent = contentText;
        }

        // --- Terminal Functions (post-login) ---
        async function initializeTerminal() {
            await dbManager.init();
            
            const loadedFS = await dbManager.loadFileSystem();
            if (loadedFS) {
                fileSystem = loadedFS;
            } else {
                fileSystem = JSON.parse(JSON.stringify(defaultFileSystem)); // Deep copy
                await dbManager.saveFileSystem(fileSystem);
            }
            
            const loadedPkgs = await dbManager.loadPackages();
            if (loadedPkgs) {
                installedPackages = loadedPkgs;
            } else {
                installedPackages = {};
                await dbManager.savePackages(installedPackages);
            }
            
            // Create the main terminal window
            const { windowEl, contentEl } = createDraggableWindow('terminal-window', 'L.A.O.S. Shell', 800, 500, 20, 20);
            const terminalHTML = `
                <div class=\"terminal-container\" id=\"terminal-container\">
                    <h1 class=\"glitch chromatic-aberration\" data-text=\"Lorel Axun v9.8\"><span id=\"typewriter-title\"></span></h1>
                    <div id=\"initial-messages\"></div>
                    <div id=\"chat-history\" class=\"chat-history\"></div>
                    <form class=\"input-line\" id=\"input-form\">
                        <span class=\"prompt\" id=\"prompt\"></span>
                        <span id=\"command-line\"></span><span id=\"autocomplete-suggestion\"></span><span id=\"cursor\"></span>
                        <input type=\"text\" id=\"hidden-input\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">
                    </form>
                </div>
                <div class=\"status-bar\">
                    <span>LOREL AXUN v9.8</span>
                    <span>STATUS: <span class=\"pulse-glow\">ONLINE</span></span>
                </div>
            `;
            contentEl.innerHTML = terminalHTML;
            const typewriterTitle = document.getElementById('typewriter-title');
            
            initTitleTypewriter(typewriterTitle);
            initializeNLU();
            loadHistory();
            loadInstalledPackages();
            displayInitialMessages();
            renderDesktopIcons();
            updateTaskbarClock();
            setInterval(updateTaskbarClock, 1000);
            setupTerminalInputListeners();
            populateStartMenu();

            // Initialize base system processes
            nextPid = 1;
            processList = {};
            processList[nextPid++] = { command: 'kernel_task', startTime: new Date(), cpu: (Math.random() * 0.5 + 0.1).toFixed(2), mem: (Math.random() * 50 + 25).toFixed(2) };
            processList[nextPid++] = { command: 'window_manager', startTime: new Date(), cpu: (Math.random() * 2.0 + 0.8).toFixed(2), mem: (Math.random() * 20 + 10).toFixed(2) };
            processList[nextPid++] = { command: `shell_session (${currentUser})`, startTime: new Date(), cpu: (Math.random() * 1.0 + 0.2).toFixed(2), mem: (Math.random() * 30 + 15).toFixed(2) };

            updatePrompt();

            (async () => {
                document.isTyping = true;
                document.getElementById('cursor').style.display = 'none';
                if (!localStorage.getItem('motdShown_v9.8')) {
                    await displayMOTD();
                    localStorage.setItem('motdShown_v9.8', 'true');
                }
                document.isTyping = false;
                document.getElementById('cursor').style.display = 'inline-block';
                document.getElementById('hidden-input').focus();
                scrollToBottom();
            })();
        }
        
        async function displayMOTD() {
            const motdContent = `
  ██╗      █████╗   ██████╗ ███████╗
  ██║     ██╔══██╗ ██╔═══██╗██╔════╝
  ██║     ███████║ ██║   ██║███████╗
  ██║     ██╔══██║ ██║   ██║╚════██║
  ███████╗██║  ██║ ╚██████╔╝███████║
  ╚══════╝╚═╝  ╚═╝  ╚═════╝ ╚══════╝
                                     
Benvenuto in L.A.O.S. v9.8 (Desktop Selection Box)
* NOVITÀ: Puoi selezionare più icone sul desktop trascinando il mouse!
* Questa funzione migliora la manipolazione diretta degli elementi del file system.
* Digita 'help' per una lista completa dei comandi nel terminale.
`;
            await printSystemOutput(motdContent);
        }

        function updatePrompt() {
             const homeDir = `/home/${currentUser}`;
             let displayCwd = cwd;
             if (cwd.startsWith(homeDir)) {
                 displayCwd = '~' + cwd.substring(homeDir.length);
             }
             document.getElementById('prompt').innerHTML = `<span style=\"color: var(--cmd-highlight)\">${currentUser}@lorel:</span><span style=\"color: var(--dir-blue)\">${displayCwd}</span>$ `;
        }

        function setupTerminalInputListeners() {
            const hiddenInput = document.getElementById('hidden-input');
            const inputForm = document.getElementById('input-form');
            const terminalContainer = document.getElementById('terminal-container');
            
            terminalContainer.addEventListener('click', (e) => {
                // Prevent clicks inside the terminal from focusing away from editor
                if (!editorState.active) hiddenInput.focus();
            });
            
            hiddenInput.addEventListener('input', () => {
                if (editorState.active) return;
                playKeySound();
                updateCommandLine();
                updateAutocompleteSuggestion();
            });

            inputForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const userInput = hiddenInput.value.trim();
                await executeCommandInTerminal(userInput);
            });

            hiddenInput.addEventListener('keydown', async function (e) {
                if (document.isTyping || editorState.active) return;

                const key = e.key;
                const prompt = document.getElementById('prompt');
                clearTimeout(document.activityTimeout);
                prompt.classList.add('listening');
                document.activityTimeout = setTimeout(() => {
                    prompt.classList.remove('listening');
                }, 1500);

                if (key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        hiddenInput.value = commandHistory[historyIndex];
                        hiddenInput.dispatchEvent(new Event('input'));
                    }
                } else if (key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        hiddenInput.value = commandHistory[historyIndex];
                        hiddenInput.dispatchEvent(new Event('input'));
                    } else {
                        historyIndex = commandHistory.length;
                        hiddenInput.value = '';
                        hiddenInput.dispatchEvent(new Event('input'));
                    }
                } else if (key === 'Tab' || key === 'ArrowRight') {
                    const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');
                    if(autocompleteSuggestion.textContent && hiddenInput.selectionStart === hiddenInput.value.length) {
                        e.preventDefault();
                        hiddenInput.value += autocompleteSuggestion.textContent;
                        hiddenInput.dispatchEvent(new Event('input'));
                    } else if (key === 'Tab') {
                       e.preventDefault();
                       await handleLegacyAutocomplete();
                    }
                } else if (key === 'Backspace') {
                     playKeySound();
                }
            });

            startButton.addEventListener('click', (e) => {
                e.stopPropagation();
                hideContextMenu();
                toggleStartMenu();
            });
        }
        
        async function executeCommandInTerminal(userInput) {
            if (!userInput || document.isTyping || editorState.active) return;

            const hiddenInput = document.getElementById('hidden-input');
            const prompt = document.getElementById('prompt');
            prompt.classList.remove('listening');
            document.getElementById('autocomplete-suggestion').textContent = '';
            
            if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {
                commandHistory.push(userInput);
                localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
            }
            historyIndex = commandHistory.length;
            hiddenInput.value = '';
            document.getElementById('command-line').textContent = '';

            document.isTyping = true;
            document.getElementById('cursor').style.display = 'none';
            
            const analysis = analyzeInput(userInput);
            addUserMessage(analysis.highlightedInput, true);
            await processCommandFromInput(analysis.command);
            saveChatHistory();

            if (parseCommand(userInput).command !== 'reboot' && !editorState.active) {
                document.isTyping = false;
                document.getElementById('cursor').style.display = 'inline-block';
                updatePrompt();
                hiddenInput.focus();
            }
            scrollToBottom();
        }

        function hideStartMenu() { startMenu.style.display = 'none'; }
        function toggleStartMenu() { startMenu.style.display = startMenu.style.display === 'none' ? 'block' : 'none'; }
        
        function showContextMenu(e, context = { type: 'desktop' }) {
            e.preventDefault();
            hideStartMenu();

            let menuItems = [];

            switch (context.type) {
                case 'file':
                    menuItems.push({ label: `Modifica '${context.path}'`, action: () => executeCommandInTerminal(`edit ${context.path}`) });
                    if (context.path.endsWith('.js')) {
                         menuItems.push({ label: `Esegui '${context.path}'`, action: () => executeCommandInTerminal(`run ${context.path}`) });
                    }
                     menuItems.push({ label: `Elimina`, action: () => executeCommandInTerminal(`rm ${context.path}`) });
                    break;
                case 'dir':
                     menuItems.push({ label: `Elimina Cartella`, action: () => executeCommandInTerminal(`rm -r ${context.path}`) });
                    break;
                case 'desktop':
                default:
                    menuItems.push({ label: 'Process Monitor', action: () => enterTopMode() });
                    menuItems.push({ label: 'System Info', action: () => showNeofetchWindow() });
                    menuItems.push({ label: 'Refresh Desktop', action: () => renderDesktopIcons() });
                    menuItems.push({ label: 'Nuovo File...', action: () => { 
                        const name = prompt('Inserisci il nome del nuovo file:');
                        if (name) executeCommandInTerminal(`touch ${name}`);
                    }}); 
                    break;
            }

            let menuHTML = '';
            menuItems.forEach((item, index) => {
                menuHTML += `<div class=\"context-menu-item\" data-index=\"${
                    index
                }\">${item.label}</div>`;
            });
            contextMenu.innerHTML = menuHTML;

            contextMenu.style.top = `${e.clientY}px`;
            contextMenu.style.left = `${e.clientX}px`;
            contextMenu.style.display = 'block';

            document.querySelectorAll('.context-menu-item').forEach(el => {
                el.onclick = () => {
                    const index = parseInt(el.dataset.index, 10);
                    menuItems[index].action();
                    hideContextMenu();
                };
            });
        }

        function hideContextMenu() { contextMenu.style.display = 'none'; }
        
        async function showNeofetchWindow() {
            const output = getNeofetchOutput();
            const { windowEl, contentEl } = createDraggableWindow('neofetch-window', 'System Info', 500, 250, 100, 300);
            contentEl.style.padding = '10px';
            contentEl.style.whiteSpace = 'pre';
            contentEl.style.overflow = 'hidden';
            contentEl.innerHTML = output;
        }
        
        function renderDesktopIcons() {
            const iconContainer = document.getElementById('desktop-icons');
            iconContainer.innerHTML = ''; // Clear existing icons
            const userHome = fileSystem[`/home/${currentUser}`];
            if (!userHome || userHome.type !== 'dir') return;

            const icons = {
                'dir': `📂`,
                '.txt': `📄`,
                '.js': `⚙️`,
                'default': `❔`
            };

            userHome.children.forEach((itemName, index) => {
                const itemPath = `/home/${currentUser}/${itemName}`;
                const itemNode = fileSystem[itemPath];
                const iconEl = document.createElement('div');
                iconEl.className = 'desktop-icon';
                iconEl.id = `icon-${itemName.replace(/\./g, '-')}`;
                iconEl.draggable = true;

                let iconArt = icons['default'];
                if (itemNode.type === 'dir') {
                    iconArt = icons['dir'];
                } else if (itemName.endsWith('.txt')) {
                    iconArt = icons['.txt'];
                } else if (itemName.endsWith('.js')) {
                    iconArt = icons['.js'];
                }

                iconEl.innerHTML = `<pre>${iconArt}</pre><div class=\"icon-label\">${itemName}</div>`;
                iconEl.style.left = `${(index % 10) * 90 + 10}px`;
                iconEl.style.top = `${Math.floor(index / 10) * 100 + 10}px`;

                iconEl.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', iconEl.id);
                    e.dataTransfer.setData('offset-x', e.clientX - iconEl.getBoundingClientRect().left);
                    e.dataTransfer.setData('offset-y', e.clientY - iconEl.getBoundingClientRect().top);
                });

                iconEl.addEventListener('dblclick', () => {
                    if (itemNode.type === 'file') {
                        let command;
                        if (itemName.endsWith('.js')) {
                            command = `run ${itemName}`;
                        } else {
                            command = `edit ${itemName}`;
                        }
                        executeCommandInTerminal(command);
                    }
                });

                iconEl.addEventListener('contextmenu', (evt) => {
                    evt.stopPropagation(); // Prevent desktop menu from showing
                    showContextMenu(evt, { type: itemNode.type, path: itemName });
                });

                iconContainer.appendChild(iconEl);
            });
        }

        function handleDesktopDrop(e) {
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            const offsetX = e.dataTransfer.getData('offset-x');
            const offsetY = e.dataTransfer.getData('offset-y');
            const iconEl = document.getElementById(id);
            const desktopRect = desktop.getBoundingClientRect();

            if (iconEl) {
                iconEl.style.left = `${e.clientX - desktopRect.left - offsetX}px`;
                iconEl.style.top = `${e.clientY - desktopRect.top - offsetY}px`;
            }
        }

        function populateStartMenu() {
            const menuCategories = {
                'System': ['help', 'status', 'sysinfo', 'neofetch', 'date', 'whoami', 'reboot', 'clear'],
                'File System': ['ls', 'cd', 'cat', 'pwd', 'mkdir', 'touch', 'rm'],
                'Development': ['edit', 'run', 'bg'],
                'AI & Web': ['news', 'weather', 'wiki', 'sentiment', 'generate'],
                'Process Management': ['ps', 'top', 'kill'],
                'Packages': ['lax']
            };
            let menuHTML = '';
            for (const category in menuCategories) {
                menuHTML += `<div class=\"start-menu-section\"><div class=\"start-menu-header\">${category}</div>`;
                menuCategories[category].forEach(command => {
                    menuHTML += `<span class=\"start-menu-item\" data-command=\"${command}\">${command}</span>`;
                });
                menuHTML += `</div>`;
            }
            startMenu.innerHTML = menuHTML;

            document.querySelectorAll('.start-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const command = item.dataset.command;
                    const hiddenInput = document.getElementById('hidden-input');
                    hiddenInput.value = command + ' ';
                    hiddenInput.focus();
                    updateCommandLine();
                    hideStartMenu();
                });
            });
        }

        function updateCommandLine() {
            const hiddenInput = document.getElementById('hidden-input');
            const commandLine = document.getElementById('command-line');
            const inputText = hiddenInput.value;
            const parts = inputText.split(' ');
            const command = parts[0].toLowerCase();
            
            if (availableCommands.includes(command) && parts[0] !== '') {
                const remainingText = escapeHtml(parts.slice(1).join(' '));
                commandLine.innerHTML = `<span class=\"command-known\">${escapeHtml(parts[0])}</span> ${remainingText}`;
            } else {
                commandLine.textContent = inputText;
            }
        }
        
        function updateAutocompleteSuggestion() {
            const hiddenInput = document.getElementById('hidden-input');
            const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');
            const currentInput = hiddenInput.value;
            if (currentInput.includes(' ') || currentInput.length === 0) {
                autocompleteSuggestion.textContent = '';
                return;
            }
            
            const matches = availableCommands.filter(cmd => cmd.startsWith(currentInput));
            
            if (matches.length === 1 && matches[0] !== currentInput) {
                autocompleteSuggestion.textContent = matches[0].substring(currentInput.length);
            } else {
                autocompleteSuggestion.textContent = '';
            }
        }

        function resolvePath(path) {
            if (!path) return cwd;
            const homeDir = `/home/${currentUser}`;
            if (path === '~') path = homeDir;
            if (path.startsWith('~/')) path = `${homeDir}/${path.substring(2)}`;
            
            const newPathParts = path.startsWith('/') ? [] : cwd.split('/').filter(p => p);
            const pathParts = path.split('/').filter(p => p);
            
            for (const part of pathParts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (newPathParts.length > 0) newPathParts.pop();
                } else {
                    newPathParts.push(part);
                }
            }
            return '/' + newPathParts.join('/');
        }

        function escapeHtml(text) { return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function analyzeInput(input) { const intent = classifier.classify(input); if (intent !== 'unknown') { const entity = nerManager.extractEntities(input, intent); if (entity) { const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`); const command = `${intent} ${entity.value}`; return { command, highlightedInput }; } return { command: intent, highlightedInput: input }; } return { command: input, highlightedInput: input }; }
        async function handleLegacyAutocomplete() { const hiddenInput = document.getElementById('hidden-input'); const currentInput = hiddenInput.value; const parts = currentInput.split(' '); const lastPart = parts[parts.length - 1]; if (parts.length === 1 && lastPart.length > 0) { const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart)); if (matches.length > 1) { await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`); } return; } }
        
        function parseCommandWithRedirection(input) {
            let redirect = null;
            let commandStr = input;

            const appendMatch = input.match(/(.*)>>\\s*(.+)$/);
            if (appendMatch) {
                commandStr = appendMatch[1].trim();
                redirect = { operator: '>>', target: appendMatch[2].trim() };
            } else {
                const overwriteMatch = input.match(/(.*)>\\s*(.+)$/);
                if (overwriteMatch) {
                    commandStr = overwriteMatch[1].trim();
                    redirect = { operator: '>', target: overwriteMatch[2].trim() };
                }
            }
            return { commandStr, redirect };
        }

        function parseCommand(input) { const regex = /[^\\s\"']+|\"([^\"]*)\"|'([^']*)'/g; const tokens = []; let match; do { match = regex.exec(input); if (match !== null) { tokens.push(match[1] || match[2] || match[0]); } } while (match !== null); const command = tokens[0] ? tokens[0].toLowerCase() : ''; const args = []; const flags = {}; for (let i = 1; i < tokens.length; i++) { const token = tokens[i]; if (token.startsWith('--')) { const flagName = token.substring(2); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else if (token.startsWith('-')) { const flagName = token.substring(1); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else { args.push(token); } } return { command, args, flags }; }
        function createAsciiTable(headers, data) { const colWidths = headers.map((header, i) => { return Math.max(header.length, ...data.map(row => String(row[i]).length)); }); const separator = '+' + colWidths.map(w => '-'.repeat(w + 2)).join('+') + '+'; let table = separator + '\n'; table += '|' + headers.map((h, i) => ` ${h.padEnd(colWidths[i])} `).join('|') + '|\n'; table += separator + '\n'; data.forEach(row => { table += '|' + row.map((cell, i) => ` ${String(cell).padEnd(colWidths[i])} `).join('|') + '|\n'; }); table += separator; return table; }
        
        function getNeofetchOutput() {
            const logoLines = ['██╗      █████╗', '██║     ██╔══██╗', '██║     ███████║', '██║     ██╔══██║', '███████╗██║  ██║', '╚══════╝╚═╝  ╚═╝', ''];
            const labelColor = 'var(--term-dim)';
            const valueColor = 'var(--term-green)';
            const uptimeMins = Math.floor(performance.now() / 60000); 
            const uptimeString = `${uptimeMins} mins`;
            const infoLines = [
                `<span style=\"color: ${valueColor};\">${currentUser}@lorel</span>`,
                '------------------',
                `<span style=\"color: ${labelColor};\">OS</span>: L.A.O.S. v9.8 Desktop Selection Box`,
                `<span style=\"color: ${labelColor};\">Host</span>: Simulated Web Environment`,
                `<span style=\"color: ${labelColor};\">Kernel</span>: JS-DOM v11.25`,
                `<span style=\"color: ${labelColor};\">Uptime</span>: ${uptimeString}`,
                `<span style=\"color: ${labelColor};\">Shell</span>: LAX-Shell 2.1`,
            ];
            const logoWidth = 24;
            let output = '';
            const maxLines = Math.max(logoLines.length, infoLines.length);
            for (let i = 0; i < maxLines; i++) {
                const logoLine = (logoLines[i] || '').padEnd(logoWidth, ' ');
                const infoLine = infoLines[i] || '';
                output += `<span style=\"color: var(--cmd-highlight);\">${logoLine}</span>${infoLine}\n`;
            }
            return '<pre>' + output + '</pre>';
        }

        async function processCommandFromInput(userInput) {
            const { commandStr, redirect } = parseCommandWithRedirection(userInput);
            const parsed = parseCommand(commandStr);

            let outputBuffer = null;
            let isHtmlOutput = false;

            // Handle installed package commands
            if (installedPackages[parsed.command]) {
                try {
                    outputBuffer = await installedPackages[parsed.command].execute(parsed.args, parsed.flags);
                } catch (e) {
                    outputBuffer = `[${parsed.command} ERROR] ${e.message}`;
                }
            } else {
                // Handle built-in commands
                switch (parsed.command) {
                    case 'help':
                        outputBuffer = `Comandi disponibili (visibili anche nel menu Start):\n` +
                                    `  help              - Mostra questa lista di comandi.\n` +
                                    `  status            - Mostra lo stato attuale del sistema.\n` +
                                    `  sysinfo           - Mostra informazioni di sistema in una tabella.\n` +
                                    `  neofetch          - Mostra info di sistema con logo ASCII.\n` +
                                    `  date              - Mostra data e ora correnti.\n` +
                                    `  whoami            - Mostra l'utente attualmente loggato.\n` +
                                    `  news [--limit N]  - Recupera N notizie (default 3).\n` +
                                    `  weather <città>   - Mostra il meteo per una città.\n` +
                                    `  wiki <termine>    - Cerca un termine su Wikipedia.\n` +
                                    `  stats             - Mostra un grafico ASCII di dati simulati.\n` +
                                    `  sentiment <testo> - Analizza il sentiment di una frase (ENG).\n` +
                                    `  generate <prompt> - Genera testo a partire da un prompt (ENG).\n` +
                                    `  echo <testo>      - Ripete il testo fornito.\n` +
                                    `  clear             - Pulisce lo schermo del terminale.\n` +
                                    `  reboot            - Simula un riavvio dell'interfaccia.\n\n` +
                                    `File System & Scripting:\n` +
                                    `  ls [percorso]     - Lista i contenuti di una directory.\n` +
                                    `  cd <directory>    - Cambia la directory corrente.\n` +
                                    `  cat <file>        - Mostra il contenuto di un file.\n` +
                                    `  pwd               - Mostra la directory corrente.\n` +
                                    `  mkdir <nome>      - Crea una nuova directory.\n` +
                                    `  touch <nome>      - Crea un nuovo file vuoto.\n` +
                                    `  rm [-r] <nome>    - Rimuove un file o una directory.\n` +
                                    `  edit <file>       - Apre un file in un editor di testo a finestra.\n` +
                                    `  run <file.js>     - Esegue uno script JS (con API fs asincrona).\n\n` +
                                    `Process Management:\n` +
                                    `  ps                - Mostra i processi in esecuzione.\n` +
                                    `  top               - Monitora i processi in una finestra in tempo reale.\n` +
                                    `  bg <file.js>      - Esegue uno script in background.\n` +
                                    `  kill <pid>        - Termina un processo in esecuzione.\n\n` +
                                    `Ecosystem Management:\n` +
                                    `  lax install <pkg> - Installa un nuovo comando.\n` +
                                    `  lax list          - Mostra i comandi installati.\n` +
                                    `  lax remove <pkg>  - Rimuove un comando installato.\n\n` +
                                    `I/O Redirection:\n` +
                                    `  > <file>          - Scrive l'output di un comando in un file (sovrascrive).\n` +
                                    `  >> <file>         - Aggiunge l'output di un comando a un file.\n` +
                                    `  (es. echo \"Ciao\" > note.txt)`;
                        break;
                    case 'status':
                        outputBuffer = 'STATUS: ONLINE. Version: 9.8. All systems nominal. User: ' + currentUser;
                        break;
                    case 'sysinfo':
                        const headers = ['Property', 'Value'];
                        const tableData = [
                            ['Version', '9.8 - Desktop Selection Box'],
                            ['Creator', 'AleXsjsju'],
                            ['Created', '2025-11-22'],
                            ['Status', 'ONLINE'],
                            ['Logged User', currentUser],
                            ['Modules', 'Transformers.js, IndexedDB']
                        ];
                        outputBuffer = createAsciiTable(headers, tableData);
                        break;
                    case 'neofetch':
                        outputBuffer = getNeofetchOutput();
                        isHtmlOutput = true;
                        break;
                    case 'whoami': outputBuffer = currentUser; break;
                    case 'pwd': outputBuffer = cwd; break;
                    case 'date': outputBuffer = new Date().toLocaleString('it-IT'); break;
                    case 'clear': document.getElementById('chat-history').innerHTML = ''; localStorage.removeItem('chatHistory'); break;
                    case 'reboot': await runRebootSequence(); break;
                    case 'echo': outputBuffer = parsed.args.length > 0 ? parsed.args.join(' ') : ''; break;
                    case 'news': outputBuffer = await fetchNews(parsed.flags.limit || 3); break;
                    case 'weather': if (parsed.args.length === 0) { outputBuffer = 'Uso: weather <città> o chiedi \"che tempo fa a <città>?\"'; } else { outputBuffer = await fetchWeather(parsed.args.join(' ')); } break;
                    case 'wiki': if (parsed.args.length === 0) { outputBuffer = 'Uso: wiki <termine da cercare> o chiedi \"cosa è <termine>?\"'; } else { outputBuffer = await fetchWikipedia(parsed.args.join(' ')); } break;
                    case 'sentiment': 
                        if (parsed.args.length === 0) {
                            outputBuffer = 'Uso: sentiment <testo da analizzare in inglese>';
                        } else {
                            outputBuffer = await analyzeSentiment(parsed.args.join(' '));
                        }
                        break;
                    case 'generate': 
                        if (parsed.args.length === 0) {
                            outputBuffer = 'Uso: generate <testo iniziale in inglese>';
                        } else {
                            outputBuffer = await generateText(parsed.args.join(' '));
                        }
                        break;
                    case 'ls': {
                        const path = resolvePath(parsed.args[0]);
                        const node = fileSystem[path];
                        if (node && node.type === 'dir') {
                            let output = '';
                            node.children.forEach(childName => {
                                const childPath = (path === '/' ? '' : path) + '/' + childName;
                                const childNode = fileSystem[childPath];
                                if (childNode.type === 'dir') {
                                    output += `<span class=\"fs-dir\">${childName}/</span>  `;
                                } else {
                                    output += `${childName}  `;
                                }
                            });
                            outputBuffer = output.trim();
                            isHtmlOutput = true;
                        } else {
                            outputBuffer = `ls: cannot access '${parsed.args[0] || '.'}': No such file or directory`;
                        }
                        break;
                    }
                    case 'cd': {
                        if (!parsed.args[0]) { 
                            cwd = `/home/${currentUser}`; break;
                        } 
                        const path = resolvePath(parsed.args[0]);
                        const node = fileSystem[path];
                        if (node && node.type === 'dir') {
                            cwd = path;
                        } else {
                            outputBuffer = `cd: no such file or directory: ${parsed.args[0]}`;
                        }
                        break;
                    }
                    case 'cat': {
                        if (parsed.args.length === 0) {
                            outputBuffer = `cat: missing operand`;
                            break;
                        }
                        const path = resolvePath(parsed.args[0]);
                        const node = fileSystem[path];
                        if (node && node.type === 'file') {
                            await printSystemOutput(node.content);
                            outputBuffer = null;
                        } else if (node && node.type === 'dir') {
                            outputBuffer = `cat: ${parsed.args[0]}: Is a directory`;
                        } else {
                            outputBuffer = `cat: ${parsed.args[0]}: No such file or directory`;
                        }
                        break;
                    }
                    case 'mkdir': {
                        if (parsed.args.length === 0) {
                            outputBuffer = `mkdir: missing operand`;
                            break;
                        }
                        const newDirName = parsed.args[0];
                        if (newDirName.includes('/')) {
                            outputBuffer = `mkdir: cannot create directory '${newDirName}': Invalid name`;
                            break;
                        }
                        const parentPath = cwd;
                        const newDirPath = resolvePath(`${parentPath}/${newDirName}`);
                        
                        if (fileSystem[newDirPath]) {
                            outputBuffer = `mkdir: cannot create directory '${newDirName}': File exists`;
                            break;
                        }

                        const parentNode = fileSystem[parentPath];
                        if (parentNode && parentNode.type === 'dir') {
                            parentNode.children.push(newDirName);
                            parentNode.children.sort();
                            fileSystem[newDirPath] = { type: 'dir', children: [] };
                            await dbManager.saveFileSystem(fileSystem); // PERSIST
                            renderDesktopIcons(); // Refresh desktop
                        } else {
                            outputBuffer = `mkdir: fatal error in path resolution`;
                        }
                        break;
                    }
                    case 'touch': {
                        if (parsed.args.length === 0) {
                            outputBuffer = `touch: missing file operand`;
                            break;
                        }
                        const newFileName = parsed.args[0];
                        if (newFileName.includes('/')) {
                            outputBuffer = `touch: cannot create file '${newFileName}': Invalid name`;
                            break;
                        }
                        const parentPath = cwd;
                        const newFilePath = resolvePath(`${parentPath}/${newFileName}`);

                        if (fileSystem[newFilePath]) { break; } 

                        const parentNode = fileSystem[parentPath];
                        if (parentNode && parentNode.type === 'dir') {
                            parentNode.children.push(newFileName);
                            parentNode.children.sort();
                            fileSystem[newFilePath] = { type: 'file', content: '' };
                            await dbManager.saveFileSystem(fileSystem); // PERSIST
                            renderDesktopIcons(); // Refresh desktop
                        } else {
                            outputBuffer = `touch: fatal error in path resolution`;
                        }
                        break;
                    }
                    case 'rm': {
                        if (parsed.args.length === 0) {
                            outputBuffer = `rm: missing operand`;
                            break;
                        }
                        const targetName = parsed.args[0];
                        const targetPath = resolvePath(targetName);
                        const targetNode = fileSystem[targetPath];

                        if (!targetNode) {
                            outputBuffer = `rm: cannot remove '${targetName}': No such file or directory`;
                            break;
                        }

                        const parentPath = resolvePath(targetPath + '/..');
                        const parentNode = fileSystem[parentPath];
                        const isRecursive = parsed.flags.r || parsed.flags.recursive;

                        if (targetNode.type === 'dir' && targetNode.children.length > 0 && !isRecursive) {
                            outputBuffer = `rm: cannot remove '${targetName}': Directory not empty`;
                            break;
                        }
                        function deleteRecursively(path) {
                            const node = fileSystem[path];
                            if (node.type === 'dir') {
                                [...node.children].forEach(child => {
                                    deleteRecursively((path === '/' ? '' : path) + '/' + child);
                                });
                            }
                            delete fileSystem[path];
                        }
                        if (isRecursive && targetNode.type === 'dir') {
                            deleteRecursively(targetPath);
                        } else {
                            delete fileSystem[targetPath];
                        }
                        if (parentNode && parentNode.children) {
                            const index = parentNode.children.indexOf(targetName.split('/').pop());
                            if (index > -1) { parentNode.children.splice(index, 1); }
                        }
                        await dbManager.saveFileSystem(fileSystem); // PERSIST
                        renderDesktopIcons(); // Refresh desktop
                        break;
                    }
                    case 'edit': {
                        if (parsed.args.length === 0) {
                            outputBuffer = 'Uso: edit <nomefile>';
                            break;
                        }
                        const filePath = parsed.args[0];
                        const resolvedPath = resolvePath(filePath);
                        const node = fileSystem[resolvedPath];
                        if (node && node.type === 'dir') {
                            outputBuffer = `edit: '${filePath}' è una directory`;
                            break;
                        }
                        const content = (node && node.type === 'file') ? node.content : '';
                        await enterEditorMode(filePath, content);
                        break;
                    }
                    case 'run': {
                        if (parsed.args.length === 0) {
                            outputBuffer = `run: missing file operand`;
                            break;
                        }
                        const filePath = resolvePath(parsed.args[0]);
                        const fileNode = fileSystem[filePath];
                        if (!fileNode || fileNode.type !== 'file') {
                            outputBuffer = `run: cannot find script '${parsed.args[0]}': No such file or directory`;
                            break;
                        }
                        await printSystemOutput(`[SYSTEM] Executing script: ${parsed.args[0]}`)
                        try {
                            const sandboxedTerminal = {
                            log: async (message) => {
                                    await printSystemOutput(String(message));
                            }
                            };
                            const sandboxedFs = {
                                readFile: (path, callback) => {
                                    setTimeout(() => { // Simulate async I/O
                                        const resolvedPath = resolvePath(path);
                                        const node = fileSystem[resolvedPath];
                                        if (node && node.type === 'file') {
                                            callback(null, node.content);
                                        } else if (node && node.type === 'dir') {
                                            callback(`Error: '${path}' is a directory`, null);
                                        } else {
                                            callback(`Error: No such file '${path}'`, null);
                                        }
                                    }, 100);
                                },
                                writeFile: (path, data, callback) => {
                                    setTimeout(() => { // Simulate async I/O
                                        const resolvedPath = resolvePath(path);
                                        const parentPath = resolvePath(resolvedPath + '/..');
                                        const parentNode = fileSystem[parentPath];
                                        
                                        if (!parentNode || parentNode.type !== 'dir') {
                                            callback(`Error: Cannot write to '${path}': Invalid path`);
                                            return;
                                        }
                                        const targetNode = fileSystem[resolvedPath];
                                        if (targetNode && targetNode.type === 'dir') {
                                            callback(`Error: Cannot write to '${path}': Is a directory`);
                                            return;
                                        }

                                        if (!targetNode) { // New file
                                            const filename = resolvedPath.split('/').pop();
                                            parentNode.children.push(filename);
                                            parentNode.children.sort();
                                        }

                                        fileSystem[resolvedPath] = { type: 'file', content: String(data) };
                                        dbManager.saveFileSystem(fileSystem); // PERSIST
                                        renderDesktopIcons(); // Refresh desktop
                                        callback(null);
                                    }, 100);
                                }
                            };
                            const scriptFunction = new Function('terminal', 'fs', fileNode.content);
                            await scriptFunction(sandboxedTerminal, sandboxedFs);
                        } catch (e) {
                            outputBuffer = `[SCRIPT ERROR] ${e.name}: ${e.message}`;
                        }
                        break;
                    }
                    case 'bg': {
                        if (parsed.args.length === 0) {
                            outputBuffer = `bg: missing file operand`;
                            break;
                        }
                        const filePath = resolvePath(parsed.args[0]);
                        const fileNode = fileSystem[filePath];
                        if (!fileNode || fileNode.type !== 'file') {
                            outputBuffer = `bg: cannot find script '${parsed.args[0]}': No such file or directory`;
                            break;
                        }
                        const pid = nextPid++;
                        const intervalId = setInterval(() => {
                            printSystemOutput(`[PID ${pid}] ${new Date().toLocaleTimeString()}: Script logger.js is running.`);
                        }, 5000);

                        processList[pid] = { 
                            command: `bg ${parsed.args[0]}`,
                            intervalId: intervalId,
                            startTime: new Date(),
                            cpu: (Math.random() * 2.5 + 0.5).toFixed(2),
                            mem: (Math.random() * 20 + 10).toFixed(2)
                        };
                        
                        outputBuffer = `[SYSTEM] Started process with PID ${pid}.`;
                        try {
                            const sandboxedTerminal = { log: async (message) => await printSystemOutput(`[PID ${pid}] ${String(message)}`) };
                            const scriptFunction = new Function('terminal', fileNode.content);
                            await scriptFunction(sandboxedTerminal);
                        } catch(e) { /* ignore errors for this simple demo */ }

                        break;
                    }
                    case 'ps': {
                        const headers = ['PID', 'USER', 'CPU%', 'MEM(MB)', 'UPTIME', 'COMMAND'];
                        const pData = Object.entries(processList).map(([pid, process]) => {
                            const uptime = Math.floor((new Date() - process.startTime) / 1000) + 's';
                            return [pid, currentUser, process.cpu, process.mem, uptime, process.command];
                        });

                        if (pData.length === 0) {
                            outputBuffer = 'No processes are running.';
                        } else {
                            outputBuffer = createAsciiTable(headers, pData);
                        }
                        break;
                    }
                    case 'kill': {
                        if (parsed.args.length === 0) {
                            outputBuffer = `kill: missing pid operand`;
                            break;
                        }
                        const pidToKill = parseInt(parsed.args[0], 10);
                        if (isNaN(pidToKill) || !processList[pidToKill]) {
                            outputBuffer = `kill: pid ${parsed.args[0]} not found.`;
                            break;
                        }
                        clearInterval(processList[pidToKill].intervalId);
                        delete processList[pidToKill];
                        outputBuffer = `[SYSTEM] Terminated process with PID ${pidToKill}.`;
                        break;
                    }
                    case 'top': {
                        enterTopMode();
                        break;
                    }
                    case 'lax': {
                        const subCommand = parsed.args[0];
                        const pkgName = parsed.args[1];

                        if (subCommand === 'install') {
                            if (!pkgName) {
                                outputBuffer = 'Uso: lax install <package>';
                                break;
                            }
                            if (installedPackages[pkgName]) {
                                outputBuffer = `Package '${pkgName}' is already installed.`;
                                break;
                            }
                            if (!packageRepository[pkgName]) {
                                outputBuffer = `Package '${pkgName}' not found in repository.`;
                                break;
                            }
                            await printSystemOutput(`Downloading ${pkgName}@${packageRepository[pkgName].version}...`);
                            await new Promise(r => setTimeout(r, 800)); // fake delay
                            installedPackages[pkgName] = packageRepository[pkgName];
                            availableCommands.push(pkgName);
                            availableCommands.sort();
                            populateStartMenu(); // Update menu with new command
                            await dbManager.savePackages(installedPackages); // PERSIST
                            outputBuffer = `Successfully installed '${pkgName}'. You can now use the '${pkgName}' command.`;
                        } else if (subCommand === 'list') {
                            const installed = Object.keys(installedPackages);
                            if (installed.length === 0) {
                                outputBuffer = 'No packages installed.';
                            } else {
                                let list = 'Installed packages:\n';
                                for (const pkg of installed) {
                                    list += `  - ${pkg}@${installedPackages[pkg].version}: ${installedPackages[pkg].description}\n`;
                                }
                                outputBuffer = list.trim();
                            }
                        } else if (subCommand === 'remove') {
                            if (!pkgName) {
                                outputBuffer = 'Uso: lax remove <package>';
                                break;
                            }
                            if (!installedPackages[pkgName]) {
                                outputBuffer = `Package '${pkgName}' is not installed.`;
                                break;
                            }
                            delete installedPackages[pkgName];
                            const index = availableCommands.indexOf(pkgName);
                            if (index > -1) {
                                availableCommands.splice(index, 1);
                            }
                            populateStartMenu(); // Update menu
                            await dbManager.savePackages(installedPackages); // PERSIST
                            outputBuffer = `Successfully removed package '${pkgName}'.`;
                        } else {
                            outputBuffer = 'Uso: lax [install|list|remove] <package>';
                        }
                        break;
                    }
                    case 'stats':
                        let s = new Array(120).fill(0).map((_, i) => 15 * Math.sin(i * ((Math.PI * 4) / 120)));
                        const chart = asciichart.plot(s, { height: 10 });
                        outputBuffer = chart + '\nChart depicts simulated CPU load over the last 60 seconds.';
                        break;
                    default:
                        outputBuffer = `Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`;
                        break;
                }
            }

            if (redirect) {
                if (outputBuffer === null || String(outputBuffer).includes('Uso:')) {
                    await typeLorelMessage(outputBuffer || 'Comando non produce output per la redirezione.');
                    return;
                }
                const targetPath = resolvePath(redirect.target);
                const parentPath = resolvePath(targetPath + '/..');
                const parentNode = fileSystem[parentPath];
                if (!parentNode || parentNode.type !== 'dir') {
                    await typeLorelMessage(`bash: ${redirect.target}: No such file or directory`);
                    return;
                }
                let targetNode = fileSystem[targetPath];
                if (targetNode && targetNode.type === 'dir') {
                    await typeLorelMessage(`bash: ${redirect.target}: Is a directory`);
                    return;
                }
                const cleanOutput = String(outputBuffer).replace(/<[^>]*>/g, '');
                if (redirect.operator === '>') {
                     if (!targetNode) {
                        parentNode.children.push(targetPath.split('/').pop());
                        parentNode.children.sort();
                     }
                     fileSystem[targetPath] = { type: 'file', content: cleanOutput };
                } else if (redirect.operator === '>>') {
                    if (!targetNode) {
                        parentNode.children.push(targetPath.split('/').pop());
                        parentNode.children.sort();
                        fileSystem[targetPath] = { type: 'file', content: cleanOutput };
                    } else {
                        fileSystem[targetPath].content += '\n' + cleanOutput;
                    }
                }
                await dbManager.saveFileSystem(fileSystem); // PERSIST
                renderDesktopIcons(); // Refresh desktop
            } else if (outputBuffer !== null) {
                 if (['sysinfo', 'stats', 'help', 'sentiment', 'generate', 'ps', 'lax'].includes(parsed.command) || Object.keys(installedPackages).includes(parsed.command)) {
                    await printSystemOutput(outputBuffer);
                 } else if (isHtmlOutput) {
                    addLorelMessage(outputBuffer, true);
                 } else {
                    await typeLorelMessage(outputBuffer);
                 }
            }
        }

        async function runRebootSequence() {
            Object.values(processList).forEach(p => clearInterval(p.intervalId));
            processList = {};
            nextPid = 1;
            await typeLorelMessage("[SYSTEM] Reboot sequence initiated... Terminating all processes and shutting down.");
            await new Promise(resolve => setTimeout(resolve, 1000));

            mainScreen.style.opacity = '0';
            monitorBezel.style.display = 'none';
            await new Promise(resolve => setTimeout(resolve, 500));
            desktop.innerHTML = '<div id=\"desktop-icons\"></div><div id=\"selection-box\"></div>'; // Reset desktop but keep containers
            taskbarApps.innerHTML = '';

            biosOverlay.style.display = 'flex';
            const biosLines = [ { text: 'LorelAxun BIOS v1.2', delay: 500 }, { text: 'Copyright (c) 2025 AleXsjsju Corp.', delay: 200 }, { text: '', delay: 500 }, { text: 'Initializing Core Memory.................... ', delay: 300 }, { text: '65536 KB OK', delay: 100, append: true, action: playBiosBeep }, { text: '\nDetecting Primary Master.................. LAX-HD-01', delay: 800 }, { text: 'Detecting Primary Slave................. None', delay: 800 }, { text: 'Detecting Secondary Master................ None', delay: 800 }, { text: 'Detecting Secondary Slave................. None', delay: 800 }, { text: '', delay: 500 }, { text: 'Checking NVRAM............................ OK', delay: 400 }, { text: 'Initializing Web-Access Layer........... OK', delay: 600 }, { text: '', delay: 1000 }, { text: 'Booting from Primary Master (LAX-HD-01)...', delay: 500 }, ];
            for (const line of biosLines) { await new Promise(resolve => setTimeout(resolve, line.delay)); if (line.append) { biosOverlay.textContent += line.text; } else { biosOverlay.textContent += line.text + '\n'; } if (line.action) { await line.action(); } }
            await new Promise(resolve => setTimeout(resolve, 1000));
            biosOverlay.style.display = 'none';
            biosOverlay.textContent = '';

            const logo = `\n██╗      █████╗\n██║     ██╔══██╗\n██║     ███████║\n██║     ██╔══██║\n███████╗██║  ██║\n╚══════╝╚═╝  ╚═╝\n            `;
            bootLogoOverlay.innerHTML = `<pre>${escapeHtml(logo)}</pre>`;
            bootLogoOverlay.style.display = 'flex';
            playSound('startup-sound');
            await new Promise(resolve => setTimeout(resolve, 3500));
            bootLogoOverlay.style.display = 'none';
            bootLogoOverlay.innerHTML = '';

            initLoginScreen();
        }

        async function analyzeSentiment(text) {
            try {
                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');

                if (!sentimentPipeline) {
                    await printSystemOutput('Loading sentiment analysis model (this may take a moment on first run)...');
                    sentimentPipeline = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finuned-sst-2-english');
                    await printSystemOutput('Model loaded successfully.');
                }
                await printSystemOutput(`Analyzing text: \"${text}\"`);
                const result = await sentimentPipeline(text);
                return `Analysis complete:\n` +
                    `  - LABEL: ${result[0].label}\n` +
                    `  - SCORE: ${result[0].score.toFixed(4)}`;
            } catch (error) {
                console.error('Sentiment Analysis Error:', error);
                return 'Error during sentiment analysis. The model may have failed to load. Check the browser console.';
            }
        }

        async function generateText(prompt) {
            try {
                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');

                if (!textGenerationPipeline) {
                    await printSystemOutput('Loading text generation model (this may take a moment on first run)...');
                    textGenerationPipeline = await pipeline('text-generation', 'Xenova/distilgpt2');
                    await printSystemOutput('Model loaded successfully.');
                }
                await printSystemOutput(`Generating text from prompt: \"${prompt}\"`);
                const result = await textGenerationPipeline(prompt, { max_new_tokens: 50 });
                return `Generation complete:\n\n${result[0].generated_text}`;
            } catch (error) {
                console.error('Text Generation Error:', error);
                return 'Error during text generation. The model may have failed to load. Check the browser console.';
            }
        }

        async function fetchWikipedia(term) { let output = `Ricerca su Wikipedia per \"${term}\"...`; try { const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`; const searchResponse = await fetch(searchUrl); if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`); const searchData = await searchResponse.json(); if (!searchData.query.search || searchData.query.search.length === 0) { throw new Error(`Nessun risultato trovato per \"${term}\".`); } const searchResults = searchData.query.search; if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) { let disambiguation = false; if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true; if(disambiguation || searchResults.length > 2) { let suggestionText = `\nTrovati più risultati per \"${term}\". Essere più specifici:\n`; searchResults.slice(0, 5).forEach(res => { suggestionText += `  - ${res.title}\n`; }); suggestionText += `Esempio: wiki \"${searchResults[0].title}\"`; return output + suggestionText; } } const pageTitle = searchResults[0].title; output += `\nTrovata pagina: \"${pageTitle}\".\nRecupero riassunto...`; const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`; const summaryResponse = await fetch(summaryUrl); if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`); const summaryData = await summaryResponse.json(); const pages = summaryData.query.pages; const pageId = Object.keys(pages)[0]; const extract = pages[pageId].extract; if (extract) { return output + `\n${extract}`; } else { throw new Error(`Nessun riassunto disponibile per \"${pageTitle}\".`); } } catch (error) { return output + `\nErrore durante la ricerca su Wikipedia: ${error.message}`; } }
        async function fetchWeather(city) { let output = `Ricerca coordinate per ${city}...`; try { const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`); if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`); const geoData = await geoResponse.json(); if (!geoData.results || geoData.results.length === 0) { throw new Error(`Località non trovata: ${city}`); } const uniqueLocations = []; const seen = new Set(); for (const loc of geoData.results) { const identifier = `${loc.name}, ${loc.admin1 || loc.country}`; if (!seen.has(identifier)) { uniqueLocations.push(loc); seen.add(identifier); } } let location; if (uniqueLocations.length > 1 && !city.includes(',')) { let suggestionText = `\nTrovate più località per \"${city}\". Essere più specifici:\n`; uniqueLocations.slice(0, 3).forEach(loc => { suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\n`; }); suggestionText += `Esempio: weather \"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\"`; return output + suggestionText; } else { location = uniqueLocations[0]; } const { latitude, longitude, name, admin1, country_code } = location; const locationName = `${name}, ${admin1 || country_code}`; output += `\nCoordinate trovate per ${locationName}.\nRecupero dati meteo...`; const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`); if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`); const weatherData = await weatherResponse.json(); const { temperature, windspeed, weathercode } = weatherData.current_weather; const weatherDescription = getWeatherDescription(weathercode); return output + `\nMeteo attuale per ${locationName}:\n` + `  - Descrizione: ${weatherDescription}\n` + `  - Temperatura: ${temperature}°C\n` + `  - Vento: ${windspeed} km/h`; } catch (error) { return output + `\nErrore durante il recupero del meteo: ${error.message}`; } }
        function getWeatherDescription(code) { const descriptions = { 0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso', 45: 'Nebbia', 48: 'Nebbia con brina', 51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa', 61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte', 71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte', 80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento', 95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante' }; return descriptions[code] || 'Condizioni non specificate'; }
        async function fetchNews(limit = 3) { let output = `Recupero ${limit} notizie dal web...`; try { const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); let newsHeadlines = '\nUltime notizie recuperate:\n'; data.forEach((article, index) => { const title = article.title.charAt(0).toUpperCase() + article.title.slice(1); newsHeadlines += `\n[${index + 1}] ${title}`; }); return output + newsHeadlines; } catch (error) { return output + `\nErrore durante il recupero delle notizie: ${error.message}`; } }
        async function typeLorelMessage(text) { const history = document.getElementById('chat-history'); const messageDiv = document.createElement('div'); messageDiv.className = 'msg lorel'; history.appendChild(messageDiv); scrollToBottom(); const chunks = text.split('\n'); for (let i = 0; i < chunks.length; i++) { const chunk = chunks[i]; if (i > 0) { messageDiv.innerText += '\n'; const pauseDuration = 250 + Math.random() * 300; await new Promise(resolve => setTimeout(resolve, pauseDuration)); } for (let j = 0; j < chunk.length; j++) { const char = chunk.charAt(j); messageDiv.innerText += char; playKeySound(); scrollToBottom(); const speed = 30 + (Math.random() * 25); await new Promise(resolve => setTimeout(resolve, speed)); if (char === ',') { await new Promise(resolve => setTimeout(resolve, 250 + Math.random() * 100)); } else if (char === '.' || char === '!' || char === '?') { await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 150)); } } } saveChatHistory(); }
        async function printSystemOutput(text) { const history = document.getElementById('chat-history'); const div = document.createElement('div'); div.className = 'msg lorel'; const pre = document.createElement('pre'); div.appendChild(pre); history.appendChild(div); scrollToBottom(); const lines = String(text).split('\n'); for (const line of lines) { pre.textContent += line + '\n'; scrollToBottom(); await new Promise(r => setTimeout(r, 50)); } saveChatHistory(); }
        function addLorelMessage(text, isHtml = false) { const history = document.getElementById('chat-history'); const div = document.createElement('div'); div.className = 'msg lorel'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }
        function addUserMessage(text, isHtml = false) { const history = document.getElementById('chat-history'); const div = document.createElement('div'); div.className = 'msg user'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }
        function saveChatHistory() { const history = document.getElementById('chat-history'); if(history) localStorage.setItem('chatHistory', history.innerHTML); }
        function loadHistory() { const savedCommandHistory = localStorage.getItem('commandHistory'); if(savedCommandHistory) { commandHistory = JSON.parse(savedCommandHistory); historyIndex = commandHistory.length; } const savedChat = localStorage.getItem('chatHistory'); if (savedChat) { document.getElementById('chat-history').innerHTML = savedChat; } }
        function loadInstalledPackages() { 
            for (const pkgName in installedPackages) {
                if (!availableCommands.includes(pkgName)) {
                    availableCommands.push(pkgName);
                }
            }
            availableCommands.sort();
         }
        
        function displayInitialMessages() {
            const initialMessagesContainer = document.getElementById('initial-messages');
            const messages = [
                '[SYSTEM] Initializing core memory... OK',
                '[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span>',
                '[AI CORE] Transformers.js library integrated. New `sentiment` & `generate` commands available.',
                '[DEVELOPMENT] Internal scripting engine loaded with sandboxed File System API.',
                '[DEVELOPMENT] Internal text editor implemented. Use the `edit` command.',
                '[SYSTEM] Rudimentary Process Manager loaded. Use `bg`, `ps`, and `kill` to manage background tasks.',
                '[SYSTEM] Live Process Monitor implemented. Use `top` for a real-time view of running processes.',
                '[SYSTEM] Rudimentary Package Manager implemented. Use `lax` to install new commands like `cowsay`.',
                '[SYSTEM] Persistence layer active. File system and packages now stored in IndexedDB.',
                '[SYSTEM] Window Manager active. Windows are draggable and resizable.',
                '[SYSTEM] Taskbar active for centralized window management.',
                '[SYSTEM] Start Menu and System Clock added to taskbar.',
                '[SYSTEM] Desktop Context Menu (right-click) active.',
                '[SYSTEM] Draggable Desktop Icons active. Double-click to open files.',
                '[SYSTEM] Context Menus are now context-sensitive for icons and the desktop.',
                '[SYSTEM] NEW: Desktop Selection Box active. Drag on the desktop to select multiple icons.'
            ];
            let content = '';
            messages.forEach(msg => {
                content += `<div class=\"sys-msg\">${msg}</div>`;
            });
            initialMessagesContainer.innerHTML = content;
        }

        function scrollToBottom() { const term = document.getElementById('terminal-container'); if(term) term.scrollTop = term.scrollHeight; }
        function updateTaskbarClock() { 
             const now = new Date(); 
             const timeString = now.toLocaleTimeString('it-IT'); 
             taskbarClock.textContent = timeString; 
        }
        
        window.onload = () => {
            initializeGlobalListeners();
            initLoginScreen();
        }

    </script>
</body>
</html>
