<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOREL AXUN V5.0 // DYNAMIC TITLE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --term-green: #33ff00;
            --term-dim: #1a8000;
            --term-glow: #33ff0080;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background-color: var(--bg-color);
            color: var(--term-green);
            font-family: 'VT323', monospace;
            display: flex;
            flex-direction: column;
            font-size: 1.2rem;
        }
        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        .crt::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }
        }
        
        .terminal-container {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--term-glow);
            display: flex;
            flex-direction: column;
        }

        h1 {
            border-bottom: 2px solid var(--term-green);
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            height: 1.5rem; /* Reserve space for typewriter */
        }

        #typewriter-title .title-cursor {
            display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
        }

        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }
        .sys-msg span { color: var(--term-green); font-weight: bold; }

        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}

        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }
        .msg.lorel::before { content: "LOREL_SYS>> "; color: var(--term-green); }
        .msg.user::before { content: "USER_INPUT>> "; color: #00ffff; }
        .msg.user { color: #ccffff; }

        mark {
            background-color: var(--term-dim);
            color: var(--term-green);
            text-shadow: none;
            padding: 0 3px;
        }

        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px;}
        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }
        .prompt.listening::after {
            content: '_';
            animation: blink 0.8s step-end infinite;
            padding-left: 5px;
            color: var(--term-dim);
        }
        
        #command-line {
            outline: none;
        }
        #cursor {
            background: var(--term-green);
            display: inline-block;
            width: 10px;
            height: 1.2rem;
            animation: blink 1s step-end infinite;
            box-shadow: 0 0 5px var(--term-glow);
            vertical-align: middle;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }

        .glitch {
            position: relative;
        }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
        }
        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);
            animation: glitch-anim-2 2.5s infinite steps(8) reverse;
        }
        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
            animation: glitch-anim-2 2.5s infinite steps(8);
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }
        }

        .status-bar {
            background-color: var(--term-green);
            color: var(--bg-color);
            padding: 2px 10px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            height: 25px;
        }
        .status-bar span {
            font-weight: bold;
        }
    </style>
</head>
<body class="crt">
    <div class="terminal-container" id="terminal-container">
        <h1 class="glitch" data-text="Lorel Axun v5.0"><span id="typewriter-title"></span></h1>
        
        <div class="sys-msg">[SYSTEM] Initializing core memory... OK</div>
        <div class="sys-msg">[NETWORK] Testing connection... <span style="color:var(--term-green)">SUCCESS</span></div>
        <div class="sys-msg">[UPDATE] Session persistence enabled via localStorage. History is now saved.</div>
        <div class="sys-msg">[AESTHETICS] CRT scanline effect enabled for enhanced immersion.</div>
        <div class="sys-msg">[AESTHETICS] Keystroke audio feedback enabled.</div>
        <div class="sys-msg">[SYSTEM] CSS animation logic consolidated for improved consistency.</div>
        <div class="sys-msg">[AESTHETICS] Lorel's messages now feature a typewriter effect with synchronized audio.</div>
        <div class="sys-msg">[SYSTEM] Advanced command parser implemented. Now supports quoted arguments and flags.</div>
        <div class="sys-msg">[AESTHETICS] Title animation upgraded to a dynamic, cyclical typewriter effect.</div>
        
        <div id="chat-history" class="chat-history"></div>

        <div class="input-line" id="input-line">
            <span class="prompt">user@lorel:~$</span>
            <span id="command-line"></span><span id="cursor"></span>
        </div>
    </div>
    <div class="status-bar">
        <span>LOREL AXUN v5.0</span>
        <span>STATUS: <span style="animation: blinker 1s linear infinite;">ONLINE</span></span>
        <span id="clock"></span>
    </div>

    <script>
        const history = document.getElementById('chat-history');
        const commandLine = document.getElementById('command-line');
        const terminalContainer = document.getElementById('terminal-container');
        const cursor = document.getElementById('cursor');
        const clock = document.getElementById('clock');
        const prompt = document.querySelector('.prompt');

        let isTyping = false;
        let commandHistory = [];
        let historyIndex = -1;
        let activityTimeout;

        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear'];
        const commandArgs = {};
        
        // --- Dynamic Title Engine ---
        function initTitleTypewriter() {
            const target = document.getElementById('typewriter-title');
            const phrases = [
                "Lorel Axun v5.0",
                "Status: ONLINE",
                "System nominal.",
                "Awaiting input..."
            ];
            let phraseIndex = 0;
            let charIndex = 0;
            let isDeleting = false;

            const typeSpeed = 100;
            const deleteSpeed = 50;
            const delay = 2000;

            function type() {
                const currentPhrase = phrases[phraseIndex];
                let displayText = '';

                if (isDeleting) {
                    displayText = currentPhrase.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    displayText = currentPhrase.substring(0, charIndex + 1);
                    charIndex++;
                }

                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;

                if (!isDeleting && charIndex === currentPhrase.length) {
                    isDeleting = true;
                    setTimeout(type, delay);
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    phraseIndex = (phraseIndex + 1) % phrases.length;
                    setTimeout(type, 500);
                } else {
                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);
                }
            }
            type();
        }

        // --- Audio Feedback Engine ---
        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA='; // A very short keyboard tick
        const keySoundPoolSize = 10; 
        const keySoundPool = [];
        let keySoundIndex = 0;

        for (let i = 0; i < keySoundPoolSize; i++) {
            keySoundPool.push(new Audio(KEY_CLICK_SOUND));
        }

        function playKeySound() {
            const sound = keySoundPool[keySoundIndex];
            sound.currentTime = 0;
            sound.play().catch(e => { /* Ignore errors from rapid playback or browser policy */ });
            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;
        }
        // --- End Audio ---

        // --- NLU Engine ---
        const classifier = {
            intents: {},
            train: function(intent, phrases) {
                if (!this.intents[intent]) this.intents[intent] = [];
                phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase)));
            },
            tokenize: text => text.toLowerCase().replace(/[^a-z0-9\s]/gi, '').split(/\s+/).filter(Boolean),
            classify: function(text) {
                const tokens = this.tokenize(text);
                let bestMatch = { intent: 'unknown', score: 0 };
                for (const intent in this.intents) {
                    let intentScore = 0;
                    this.intents[intent].forEach(phraseTokens => {
                        const commonTokens = tokens.filter(token => phraseTokens.includes(token));
                        const score = commonTokens.length / phraseTokens.length;
                        if (score > intentScore) intentScore = score;
                    });
                    if (intentScore > bestMatch.score) {
                        bestMatch = { intent, score: intentScore };
                    }
                }
                return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; // Confidence threshold
            }
        };

        const nerManager = {
            extractEntities: function(text, intent) {
                if (intent === 'weather') {
                    const match = text.match(/(?:a|per|di|a)\s(.+)/i);
                    if (match && match[1]) {
                        const entityText = match[1].trim().replace('?','');
                        return { value: `\"${entityText}\"`, text: entityText, type: 'LOCATION' };
                    }
                } else if (intent === 'wiki') {
                    const match = text.match(/(?:è|e'|di|su)\s(.+)/i);
                     if (match && match[1]) {
                        const entityText = match[1].trim().replace('?','');
                        return { value: `\"${entityText}\"`, text: entityText, type: 'TOPIC' };
                     }
                }
                return null; // No entity found
            }
        };

        function initializeNLU() {
            classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']);
            classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']);
            classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']);
            classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']);
            classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']);
        }
        // --- End NLU ---

        document.addEventListener('keydown', async function (e) {
            if (isTyping) return;
            const key = e.key;

            clearTimeout(activityTimeout);
            if (key !== 'Enter') {
                prompt.classList.add('listening');
                activityTimeout = setTimeout(() => {
                    prompt.classList.remove('listening');
                }, 1500);
            }

            if (key === 'Enter') {
                e.preventDefault();
                prompt.classList.remove('listening');
                const userInput = commandLine.textContent.trim();
                if (userInput) {
                    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {
                         commandHistory.push(userInput);
                         localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                    }
                    historyIndex = commandHistory.length;
                    commandLine.textContent = '';
                    isTyping = true;
                    cursor.style.display = 'none';
                    
                    const analysis = analyzeInput(userInput);
                    addUserMessage(analysis.highlightedInput, true);
                    await processCommand(analysis.command);
                    saveChatHistory();

                    isTyping = false;
                    cursor.style.display = 'inline-block';
                    scrollToBottom();
                }
            } else if (key === 'Backspace') {
                e.preventDefault();
                commandLine.textContent = commandLine.textContent.slice(0, -1);
                playKeySound();
            } else if (key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    commandLine.textContent = commandHistory[historyIndex];
                }
            } else if (key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    commandLine.textContent = commandHistory[historyIndex];
                } else {
                    historyIndex = commandHistory.length;
                    commandLine.textContent = '';
                }
            } else if (key === 'Tab') {
                e.preventDefault();
                await handleAutocomplete();
            } else if (key.length === 1 && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                commandLine.textContent += key;
                playKeySound();
            }
        });

        function analyzeInput(input) {
            const intent = classifier.classify(input);
            
            if (intent !== 'unknown') {
                const entity = nerManager.extractEntities(input, intent);
                if (entity) {
                    const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`);
                    const command = `${intent} ${entity.value}`
                    return { command, highlightedInput };
                }
                return { command: intent, highlightedInput: input }; // Intent recognized, but no entity
            }
            return { command: input, highlightedInput: input }; // Fallback to original input
        }

        async function handleAutocomplete() {
            const currentInput = commandLine.textContent;
            const parts = currentInput.split(' ');
            const command = parts[0];
            const lastPart = parts[parts.length - 1];

            if (parts.length === 1) {
                const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart));
                if (matches.length === 1) {
                    commandLine.textContent = matches[0] + ' ';
                } else if (matches.length > 1) {
                    await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`, true);
                }
                return;
            }

            if (command === 'weather' && parts.length > 1) {
                const currentArg = parts[parts.length - 1];
                if (currentArg.length < 2) {
                    await typeLorelMessage('Digita almeno 2 caratteri per la ricerca della città.', true);
                    return;
                }
                const suggestions = await fetchCitySuggestions(currentArg);
                if (suggestions.length === 1) {
                    parts[parts.length - 1] = suggestions[0];
                    commandLine.textContent = parts.join(' ') + ' ';
                } else if (suggestions.length > 1) {
                    await typeLorelMessage(`Suggerimenti: ${suggestions.join('  ')}`, true);
                } else {
                    await typeLorelMessage('Nessuna città trovata.', true);
                }
                return;
            }

            if (commandArgs[command]) {
                const argSuggestions = commandArgs[command];
                const currentArg = parts.length > 1 ? lastPart : '';
                const matches = argSuggestions.filter(arg => arg.toLowerCase().startsWith(currentArg.toLowerCase()));
                if (matches.length === 1) {
                    parts[parts.length - 1] = matches[0];
                    commandLine.textContent = parts.join(' ') + ' ';
                } else if (matches.length > 1) {
                    await typeLorelMessage(`Suggerimenti: ${matches.join('  ')}`, true);
                }
            }
        }

        async function fetchCitySuggestions(partialName) {
            try {
                const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(partialName)}&count=5&language=it&format=json`);
                if (!response.ok) return [];
                const data = await response.json();
                if (data.results) {
                    const uniqueNames = new Set();
                    return data.results.map(loc => {
                        const name = `${loc.name}, ${loc.country_code}`
                        if(uniqueNames.has(name)) return null;
                        uniqueNames.add(name);
                        return name;
                    }).filter(name => name !== null);
                }
                return [];
            } catch (error) {
                console.error("City suggestion fetch error:", error);
                return [];
            }
        }
        
        function parseCommand(input) {
            const regex = /[^\s\"']+|\"([^\"]*)\"|'([^']*)'/g;
            const tokens = [];
            let match;
            do {
                match = regex.exec(input);
                if (match !== null) {
                    tokens.push(match[1] || match[2] || match[0]);
                }
            } while (match !== null);

            const command = tokens[0] ? tokens[0].toLowerCase() : '';
            const args = [];
            const flags = {};

            for (let i = 1; i < tokens.length; i++) {
                const token = tokens[i];
                if (token.startsWith('--')) {
                    const flagName = token.substring(2);
                    const nextToken = tokens[i + 1];
                    if (nextToken && !nextToken.startsWith('-')) {
                        flags[flagName] = nextToken;
                        i++;
                    } else {
                        flags[flagName] = true;
                    }
                } else if (token.startsWith('-')) {
                    const flagName = token.substring(1);
                     const nextToken = tokens[i + 1];
                    if (nextToken && !nextToken.startsWith('-')) {
                        flags[flagName] = nextToken;
                        i++;
                    } else {
                        flags[flagName] = true;
                    }
                } else {
                    args.push(token);
                }
            }
            return { command, args, flags };
        }

        async function processCommand(command) {
            const parsed = parseCommand(command);

            switch (parsed.command) {
                case 'help':
                    const helpText = `Comandi disponibili:\n` +
                                   `  help              - Mostra questa lista di comandi.\n` +
                                   `  status            - Mostra lo stato attuale del sistema.\n` +
                                   `  date              - Mostra data e ora correnti.\n` +
                                   `  news [--limit N]  - Recupera N notizie (default 3).\n` +
                                   `  weather <città>   - Mostra il meteo per una città.\n` +
                                   `  wiki <termine>    - Cerca un termine su Wikipedia.\n` +
                                   `  echo <testo>      - Ripete il testo fornito.\n` +
                                   `  clear             - Pulisce lo schermo del terminale.`;
                    await typeLorelMessage(helpText);
                    break;
                case 'status':
                    await typeLorelMessage('STATUS: ONLINE. Version: 5.0. Modules: Dynamic Title, Advanced Parser, NLU, API Fetch, Session Persistence, CSS Aesthetics, Audio Feedback.');
                    break;
                case 'date':
                    await typeLorelMessage(new Date().toLocaleString('it-IT'));
                    break;
                case 'clear':
                    history.innerHTML = '';
                    localStorage.removeItem('chatHistory');
                    break;
                case 'echo':
                    await typeLorelMessage(parsed.args.length > 0 ? parsed.args.join(' ') : '');
                    break;
                case 'news':
                    const limit = parsed.flags.limit || 3;
                    await fetchNews(limit);
                    break;
                case 'weather':
                    if (parsed.args.length === 0) {
                        await typeLorelMessage('Uso: weather <città> o chiedi \"che tempo fa a <città>?\"');
                    } else {
                        await fetchWeather(parsed.args.join(' '));
                    }
                    break;
                case 'wiki':
                     if (parsed.args.length === 0) {
                        await typeLorelMessage('Uso: wiki <termine da cercare> o chiedi \"cosa è <termine>?\"');
                    } else {
                        await fetchWikipedia(parsed.args.join(' '));
                    }
                    break;
                default:
                    await typeLorelMessage(`Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`);
                    break;
            }
        }

        async function fetchWikipedia(term) {
            await typeLorelMessage(`Ricerca su Wikipedia per \"${term}\"...`);
            try {
                const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`;
                const searchResponse = await fetch(searchUrl);
                if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`);
                const searchData = await searchResponse.json();

                if (!searchData.query.search || searchData.query.search.length === 0) {
                    throw new Error(`Nessun risultato trovato per \"${term}\".`);
                }

                const searchResults = searchData.query.search;
                
                if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) {
                    let disambiguation = false;
                    if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true;

                    if(disambiguation || searchResults.length > 2) {
                        let suggestionText = `Trovati più risultati per \"${term}\". Essere più specifici:\n`;
                        searchResults.slice(0, 5).forEach(res => {
                            suggestionText += `  - ${res.title}\n`;
                        });
                        suggestionText += `Esempio: wiki \"${searchResults[0].title}\"`;
                        await typeLorelMessage(suggestionText);
                        return;
                    }
                }

                const pageTitle = searchResults[0].title;
                await typeLorelMessage(`Trovata pagina: \"${pageTitle}\". Recupero riassunto...`);

                const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`;
                const summaryResponse = await fetch(summaryUrl);
                if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`);
                const summaryData = await summaryResponse.json();

                const pages = summaryData.query.pages;
                const pageId = Object.keys(pages)[0];
                const extract = pages[pageId].extract;

                if (extract) {
                    await typeLorelMessage(extract);
                } else {
                    throw new Error(`Nessun riassunto disponibile per \"${pageTitle}\". Potrebbe essere una pagina di reindirizzamento o disambiguazione.`);
                }

            } catch (error) {
                await typeLorelMessage(`Errore durante la ricerca su Wikipedia: ${error.message}`);
            }
        }

        async function fetchWeather(city) {
            await typeLorelMessage(`Ricerca coordinate per ${city}...`);
            try {
                const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`);
                if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`);
                const geoData = await geoResponse.json();
                
                if (!geoData.results || geoData.results.length === 0) {
                    throw new Error(`Località non trovata: ${city}`);
                }

                const uniqueLocations = [];
                const seen = new Set();
                for (const loc of geoData.results) {
                    const identifier = `${loc.name}, ${loc.admin1 || loc.country}`
                    if (!seen.has(identifier)) {
                        uniqueLocations.push(loc);
                        seen.add(identifier);
                    }
                }

                let location;
                if (uniqueLocations.length > 1 && !city.includes(',')) {
                    let suggestionText = `Trovate più località per \"${city}\". Essere più specifici:\n`;
                    uniqueLocations.slice(0, 3).forEach(loc => {
                        suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\n`;
                    });
                    suggestionText += `Esempio: weather \"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\"`;
                    await typeLorelMessage(suggestionText);
                    return;
                } else {
                    location = uniqueLocations[0];
                }

                const { latitude, longitude, name, admin1, country_code } = location;
                const locationName = `${name}, ${admin1 || country_code}`
                await typeLorelMessage(`Coordinate trovate per ${locationName}. Recupero dati meteo...`);

                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
                if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`);
                const weatherData = await weatherResponse.json();
                
                const { temperature, windspeed, weathercode } = weatherData.current_weather;
                const weatherDescription = getWeatherDescription(weathercode);

                const weatherReport = `Meteo attuale per ${locationName}:\n` +
                                    `  - Descrizione: ${weatherDescription}\n` +
                                    `  - Temperatura: ${temperature}°C\n` +
                                    `  - Vento: ${windspeed} km/h`;
                await typeLorelMessage(weatherReport);

            } catch (error) {
                await typeLorelMessage(`Errore durante il recupero del meteo: ${error.message}`);
            }
        }

        function getWeatherDescription(code) {
            const descriptions = {
                0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso',
                45: 'Nebbia', 48: 'Nebbia con brina',
                51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa',
                61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte',
                71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte',
                80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento',
                95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante'
            };
            return descriptions[code] || 'Condizioni non specificate';
        }

        async function fetchNews(limit = 3) {
            await typeLorelMessage(`Recupero ${limit} notizie dal web...`);
            try {
                const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                let newsHeadlines = 'Ultime notizie recuperate:\n\n';
                data.forEach((article, index) => {
                    const title = article.title.charAt(0).toUpperCase() + article.title.slice(1);
                    newsHeadlines += `[${index + 1}] ${title}\n`;
                });
                await typeLorelMessage(newsHeadlines);
            } catch (error) {
                await typeLorelMessage(`Errore durante il recupero delle notizie: ${error.message}`);
            }
        }

        function typeLorelMessage(text, isSuggestion = false) {
            return new Promise(resolve => {
                if (isSuggestion) {
                    const div = document.createElement('div');
                    div.className = 'msg lorel';
                    div.style.color = 'var(--term-dim)';
                    history.appendChild(div);
                    scrollToBottom();
                    let i = 0;
                    const speed = 10;
                    function typeSuggestion() {
                        if (i < text.length) {
                            div.innerText += text.charAt(i);
                            i++;
                            scrollToBottom();
                            setTimeout(typeSuggestion, speed);
                        } else {
                            setTimeout(() => {
                                if (div.parentNode) div.parentNode.removeChild(div);
                                resolve();
                            }, 2500);
                        }
                    }
                    typeSuggestion();
                    return;
                }

                const messageDiv = document.createElement('div');
                messageDiv.className = 'msg lorel';
                history.appendChild(messageDiv);
                scrollToBottom();

                const thinkTime = 400 + Math.random() * 300;
                setTimeout(() => {
                    let i = 0;
                    const speed = 30;
                    function type() {
                        if (i < text.length) {
                            messageDiv.innerText += text.charAt(i);
                            playKeySound();
                            i++;
                            scrollToBottom();
                            setTimeout(type, speed);
                        } else {
                            resolve();
                        }
                    }
                    type();
                }, thinkTime);
            });
        }
        
        function addUserMessage(text, isHtml = false) {
            const div = document.createElement('div');
            div.className = 'msg user';
            if (isHtml) {
                div.innerHTML = text;
            } else {
                div.innerText = text;
            }
            history.appendChild(div);
            saveChatHistory();
            scrollToBottom();
        }

        function saveChatHistory() {
            localStorage.setItem('chatHistory', history.innerHTML);
        }

        function loadHistory() {
            const savedCommandHistory = localStorage.getItem('commandHistory');
            if(savedCommandHistory) {
                commandHistory = JSON.parse(savedCommandHistory);
                historyIndex = commandHistory.length;
            }
            const savedChat = localStorage.getItem('chatHistory');
            if (savedChat) {
                history.innerHTML = savedChat;
            }
        }

        function scrollToBottom() {
             terminalContainer.scrollTop = terminalContainer.scrollHeight;
        }

        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('it-IT');
            clock.textContent = timeString;
        }
        
        window.onload = async () => {
            initTitleTypewriter();
            initializeNLU();
            loadHistory();
            updateClock();
            setInterval(updateClock, 1000);
            isTyping = true;
            cursor.style.display = 'none';
            if (!localStorage.getItem('chatHistory')) {
                await typeLorelMessage("Interfaccia v5.0. Il titolo ora riflette il mio stato di attività continuo.");
                saveChatHistory();
            }
            isTyping = false;
            cursor.style.display = 'inline-block';
            scrollToBottom();
        }

    </script>
</body>
</html>
