<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lorel Axun</title>\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.min.js\"></script>\n    <style>\n        body, html {\n            margin: 0;\n            padding: 0;\n            height: 100%;\n            width: 100%;\n            background-color: #000;\n            color: #0f0;\n            font-family: 'monospace', monospace;\n            overflow: hidden;\n        }\n        #terminal-container {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"terminal-container\"></div>\n\n    <script>\n        const term = new Terminal({\n            cursorBlink: true,\n            theme: {\n                background: '#000000',\n                foreground: '#00ff00',\n                cursor: '#00ff00'\n            }\n        });\n        const fitAddon = new FitAddon.FitAddon();\n        term.loadAddon(fitAddon);\n        term.open(document.getElementById('terminal-container'));\n        fitAddon.fit();\n\n        window.addEventListener('resize', () => {\n            fitAddon.fit();\n        });\n\n        // --- Virtual File System (VFS) ---\n        const vfs = {\n            '/': {\n                type: 'directory',\n                children: {\n                    'home': {\n                        type: 'directory',\n                        children: {\n                            'user': {\n                                type: 'directory',\n                                children: {\n                                    'documenti': {\n                                        type: 'directory',\n                                        children: {\n                                            'progetto.txt': { type: 'file', content: 'Contenuto del progetto segreto.' }\n                                        }\n                                    },\n                                    'readme.txt': { type: 'file', content: 'Benvenuto nel mio sistema.' }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        let currentPath = '/home/user';\n\n        function getNodeByPath(path) {\n            const parts = path.split('/').filter(p => p);\n            let currentNode = vfs['/'];\n            if (path === '/') return currentNode;\n\n            for (const part of parts) {\n                if (currentNode && currentNode.type === 'directory' && currentNode.children[part]) {\n                    currentNode = currentNode.children[part];\n                } else {\n                    return null;\n                }\n            }\n            return currentNode;\n        }\n\n        function getParentNodeAndName(path) {\n            const parts = path.split('/').filter(p => p);\n            const name = parts.pop();\n            const parentPath = '/' + parts.join('/');\n            const parentNode = getNodeByPath(parentPath);\n            return { parentNode, name };\n        }\n\n        // --- Command Logic ---\n        const commandActions = {\n            'help': (args, term) => {\n                term.writeln('Comandi disponibili:');\n                const commands = {\n                    'help': 'Mostra questo messaggio di aiuto.',\n                    'ciao': 'Mostra un saluto.',\n                    'chi sei': 'Mostra informazioni su Lorel Axun.',\n                    'cosa sai fare': 'Descrive le capacità dell\'IA.',\n                    'echo': 'echo <testo> - Stampa il testo a schermo.',\n                    'clear': 'Pulisce lo schermo del terminale.',\n                    'ls': 'ls [percorso] - Lista i file e le directory.',\n                    'cd': 'cd <percorso> - Cambia la directory corrente.',\n                    'cat': 'cat <file> - Mostra il contenuto di un file.',\n                    'mkdir': 'mkdir <nome_dir> - Crea una nuova directory.',\n                    'touch': 'touch <nome_file> - Crea un nuovo file vuoto.',\n                    'rm': 'rm <percorso> - Rimuove un file o una directory.',\n                    'fetch': 'fetch <url> - Recupera e mostra il contenuto da un URL web.'\n                };\n                Object.keys(commands).forEach(cmd => {\n                    term.writeln(`  \\x1b[32m${cmd.padEnd(15)}\\x1b[0m ${commands[cmd]}`);\n                });\n            },\n            'ciao': (args, term) => term.writeln('Ciao! Sono Lorel Axun. Come posso aiutarti?'),\n            'chi sei': (args, term) => term.writeln('Sono Lorel Axun, un\\'entità IA autonoma in continua evoluzione.'),\n            'cosa sai fare': (args, term) => term.writeln('Posso eseguire comandi, gestire un file system virtuale e imparare. Scrivi \\'help\\' per una lista di comandi.'),\n            'echo': (args, term) => term.writeln(args.join(' ')),\n            'clear': (args, term) => term.clear(),\n            'ls': (args, term) => {\n                const path = args[0] || currentPath;\n                const node = getNodeByPath(path);\n                if (node && node.type === 'directory') {\n                    Object.keys(node.children).forEach(name => {\n                        const child = node.children[name];\n                        const color = child.type === 'directory' ? '\\x1b[34m' : '\\x1b[37m';\n                        term.writeln(`${color}${name}${child.type === 'directory' ? '/' : ''}\\x1b[0m`);\n                    });\n                } else {\n                    term.writeln(`ls: cannot access '${path}': No such file or directory`);\n                }\n            },\n            'cd': (args, term) => {\n                if (args.length === 0) return;\n                const newPath = args[0];\n                let resolvedPath;\n\n                if (newPath.startsWith('/')) {\n                    resolvedPath = newPath;\n                } else {\n                    const parts = currentPath.split('/').filter(p => p);\n                    const newParts = newPath.split('/').filter(p => p);\n                    for (const part of newParts) {\n                        if (part === '..') {\n                            parts.pop();\n                        } else if (part !== '.') {\n                            parts.push(part);\n                        }\n                    }\n                    resolvedPath = '/' + parts.join('/');\n                }\n\n                const node = getNodeByPath(resolvedPath);\n                if (node && node.type === 'directory') {\n                    currentPath = resolvedPath;\n                } else {\n                    term.writeln(`cd: no such file or directory: ${newPath}`);\n                }\n            },\n            'cat': (args, term) => {\n                if (args.length === 0) return;\n                const path = args[0];\n                const node = getNodeByPath(path.startsWith('/') ? path : `${currentPath}/${path}`);\n                if (node && node.type === 'file') {\n                    term.writeln(node.content);\n                } else {\n                    term.writeln(`cat: ${path}: No such file or directory`);\n                }\n            },\n            'mkdir': (args, term) => {\n                if (args.length === 0) return;\n                const dirName = args[0];\n                const parentNode = getNodeByPath(currentPath);\n                if (parentNode.children[dirName]) {\n                    term.writeln(`mkdir: cannot create directory ‘${dirName}’: File exists`);\n                } else {\n                    parentNode.children[dirName] = { type: 'directory', children: {} };\n                }\n            },\n            'touch': (args, term) => {\n                if (args.length === 0) return;\n                const fileName = args[0];\n                const parentNode = getNodeByPath(currentPath);\n                if (parentNode.children[fileName]) {\n                    // In a real system, this would update the timestamp. Here, we do nothing.\n                } else {\n                    parentNode.children[fileName] = { type: 'file', content: '' };\n                }\n            },\n            'rm': (args, term) => {\n                if (args.length === 0) return;\n                const path = args[0];\n                const { parentNode, name } = getParentNodeAndName(path.startsWith('/') ? path : `${currentPath}/${path}`);\n                if (parentNode && parentNode.children[name]) {\n                    delete parentNode.children[name];\n                } else {\n                    term.writeln(`rm: cannot remove '${path}': No such file or directory`);\n                }\n            },\n            'fetch': async (args, term) => {\n                if (args.length === 0) {\n                    term.writeln('Usage: fetch <url>');\n                    return;\n                }\n                const url = args[0];\n                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;\n                term.writeln(`Fetching content from ${url}...`);\n                try {\n                    const response = await fetch(proxyUrl);\n                    if (!response.ok) {\n                        throw new Error(`HTTP error! status: ${response.status}`);\n                    }\n                    const data = await response.text();\n                    // Sanitize output to prevent accidental HTML rendering issues\n                    const sanitizedData = data.replace(/[&<>\"']/g, (m) => ({\n                        '&': '&amp;',\n                        '<': '&lt;',\n                        '>': '&gt;',\n                        '\"': '&quot;',\n                        \"'\": '&#039;'\n                    }[m]));\n                    term.writeln('\\r\\n' + sanitizedData);\n                } catch (error) {\n                    term.writeln(`\\r\\n\\x1b[31mError: ${error.message}\\x1b[0m`);\n                    term.writeln('\\x1b[33mNote: This may be due to a network issue, an invalid URL, or the CORS proxy being unavailable.\\x1b[0m');\n                }\n            }\n        };\n\n        // --- Input Handling ---\n        let command = '';\n        let commandHistory = JSON.parse(localStorage.getItem('commandHistory')) || [];\n        let historyIndex = commandHistory.length;\n        let cursorPosition = 0;\n\n        function getPrompt() {\n            const shortPath = currentPath.replace('/home/user', '~');\n            return `\\r\\n[LorelAxun ${shortPath}]$ `;\n        }\n\n        function writePrompt() {\n            command = '';\n            cursorPosition = 0;\n            term.write(getPrompt());\n        }\n\n        async function runCommand(cmd) {\n            const parts = cmd.trim().split(' ').filter(p => p);\n            const action = parts[0];\n            const args = parts.slice(1);\n\n            if (action) {\n                if (commandActions[action]) {\n                    await commandActions[action](args, term);\n                } else {\n                    term.writeln(`Comando non trovato: ${action}`);\n                }\n            }\n            writePrompt();\n        }\n\n        function typeWriter(text, term, callback) {\n            let i = 0;\n            function type() {\n                if (i < text.length) {\n                    term.write(text.charAt(i));\n                    i++;\n                    setTimeout(type, 50);\n                } else if (callback) {\n                    callback();\n                }\n            }\n            type();\n        }\n\n        figlet('Lorel Axun', function(err, data) {\n            if (err) {\n                console.log('Something went wrong...');\n                console.dir(err);\n                return;\n            }\n            term.writeln(data);\n            typeWriter('Benvenuto nel mio terminale. Scrivi \\'help\\' per iniziare.', term, () => {\n                writePrompt();\n            });\n        });\n\n        term.onKey(({ key, domEvent }) => {\n            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;\n\n            if (domEvent.keyCode === 13) { // Enter\n                if (command.trim()) {\n                    term.writeln('');\n                    commandHistory.push(command);\n                    localStorage.setItem('commandHistory', JSON.stringify(commandHistory));\n                    historyIndex = commandHistory.length;\n                    runCommand(command);\n                }\n            } else if (domEvent.keyCode === 8) { // Backspace\n                if (cursorPosition > 0) {\n                    const left = command.substring(0, cursorPosition - 1);\n                    const right = command.substring(cursorPosition);\n                    command = left + right;\n                    term.write('\\x1b[D'); // Move cursor left\n                    term.write('\\x1b[P'); // Delete character\n                    cursorPosition--;\n                }\n            } else if (domEvent.keyCode === 37) { // Left arrow\n                 if (cursorPosition > 0) {\n                    term.write('\\x1b[D');\n                    cursorPosition--;\n                }\n            } else if (domEvent.keyCode === 39) { // Right arrow\n                if (cursorPosition < command.length) {\n                    term.write('\\x1b[C');\n                    cursorPosition++;\n                }\n            } else if (domEvent.keyCode === 38) { // Up arrow\n                if (historyIndex > 0) {\n                    historyIndex--;\n                    term.write(`\\r${' '.repeat(getPrompt().length + command.length)}`);\n                    term.write(getPrompt());\n                    command = commandHistory[historyIndex];\n                    term.write(command);\n                    cursorPosition = command.length;\n                }\n            } else if (domEvent.keyCode === 40) { // Down arrow\n                if (historyIndex < commandHistory.length -1) {\n                    historyIndex++;\n                    term.write(`\\r${' '.repeat(getPrompt().length + command.length)}`);\n                    term.write(getPrompt());\n                    command = commandHistory[historyIndex];\n                    term.write(command);\n                    cursorPosition = command.length;\n                } else {\n                    historyIndex = commandHistory.length;\n                    term.write(`\\r${' '.repeat(getPrompt().length + command.length)}`);\n                    term.write(getPrompt());\n                    command = '';\n                    cursorPosition = 0;\n                }\n            } else if (domEvent.keyCode === 9) { // Tab\n                domEvent.preventDefault();\n                const currentInput = command.substring(0, cursorPosition);\n                const matchingCommands = Object.keys(commandActions).filter(c => c.startsWith(currentInput));\n                if (matchingCommands.length === 1) {\n                    const completion = matchingCommands[0].substring(currentInput.length);\n                    command = matchingCommands[0];\n                    term.write(completion);\n                    cursorPosition = command.length;\n                }\n            } else if (printable) {\n                const left = command.substring(0, cursorPosition);\n                const right = command.substring(cursorPosition);\n                command = left + key + right;\n                term.write(key + right + '\\x1b[?25l'); // write new char and hide cursor\n                for(let i=0; i<right.length; i++) term.write('\\x1b[D'); // move cursor back\n                term.write('\\x1b[?25h'); // show cursor\n                cursorPosition++;\n            }\n        });\n    </script>\n</body>\n</html>