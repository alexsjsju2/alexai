<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOREL AXUN V6.8 // BIOS POST BEEP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --term-green: #33ff00;
            --term-dim: #1a8000;
            --term-glow: #33ff0080;
            --cmd-highlight: #00ffff;
            --bios-text: #cccccc;
        }
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #000;
        }
        body {
            height: 100%;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: var(--term-green);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .monitor-bezel {
            background-color: #1a1a1a; /* Dark gray for plastic */
            border-radius: 25px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.8);
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
        }

        .screen {
            flex: 1;
            background-color: var(--bg-color);
            border-radius: 10px; /* Inner screen roundness */
            overflow: hidden; /* Contains the screen content and effects */
            position: relative; /* For the ::before/::after pseudo-elements */
            display: flex;
            flex-direction: column;
            transition: opacity 0.5s ease-in-out;
        }

        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        .crt::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }
        }
        
        .moving-scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: rgba(51, 255, 0, 0.1);
            box-shadow: 0 0 10px rgba(51, 255, 0, 0.3);
            z-index: 3;
            pointer-events: none;
            animation: scanline-scroll 5s linear infinite;
        }
        @keyframes scanline-scroll {
            0% {
                transform: translateY(0vh);
            }
            100% {
                transform: translateY(100vh);
            }
        }

        .terminal-container {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            width: 100%;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--term-glow);
            display: flex;
            flex-direction: column;
        }

        h1 {
            border-bottom: 2px solid var(--term-green);
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            height: 1.5rem; /* Reserve space for typewriter */
        }

        #typewriter-title .title-cursor {
            display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
        }

        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }
        .sys-msg span { color: var(--term-green); font-weight: bold; }

        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}
        #initial-messages { display: flex; flex-direction: column; gap: 0px; margin-bottom:10px; }

        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }
        .msg.lorel::before { content: \"LOREL_SYS>> \"; color: var(--term-green); }
        .msg.user::before { content: \"USER_INPUT>> \"; color: #00ffff; }
        .msg.user { color: #ccffff; }

        .msg pre {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            margin: 0;
            white-space: pre;
            line-height: 1;
        }

        mark {
            background-color: var(--term-dim);
            color: var(--term-green);
            text-shadow: none;
            padding: 0 3px;
        }

        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; position: relative;}
        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }
        .prompt.listening::after {
            content: '_';
            animation: blink 0.8s step-end infinite;
            padding-left: 5px;
            color: var(--term-dim);
        }

        #command-line .command-known {
            color: var(--cmd-highlight);
            font-weight: bold;
        }
        
        #autocomplete-suggestion {
            color: var(--term-dim);
            opacity: 0.7;
            pointer-events: none; /* Make it non-interactive */
        }

        #hidden-input {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            height: 1.2rem;
            background: transparent;
            border: none;
            color: transparent;
            caret-color: transparent;
            outline: none;
            padding: 0;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            z-index: -1;
        }

        #cursor {
            background: var(--term-green);
            display: inline-block;
            width: 10px;
            height: 1.2rem;
            animation: blink 1s step-end infinite;
            box-shadow: 0 0 5px var(--term-glow);
            vertical-align: middle;
        }
        @keyframes blink {
            50% { opacity: 0.0; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }

        .glitch {
            position: relative;
        }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
        }
        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);
            animation: glitch-anim-2 2.5s infinite steps(8) reverse;
        }
        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
            animation: glitch-anim-2 2.5s infinite steps(8);
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }
        }

        .chromatic-aberration {
            animation: text-flicker 3s linear infinite;
        }

        @keyframes text-flicker {
            0% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            15% { text-shadow: 1.5px 0 0 red, -1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            30% { text-shadow: -1px 0 0 red, 1px 0 0 cyan, 0 0 5px var(--term-glow); }            45% { text-shadow: -1.5px 0 0 red, 1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            60% { text-shadow: 0.5px 0.5px 0 red, -0.5px -0.5px 0 cyan, 0 0 5px var(--term-glow); }            75% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            100% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }
        }

        .status-bar {
            background-color: var(--term-green);
            color: var(--bg-color);
            padding: 2px 10px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            height: 25px;
        }
        .status-bar span {
            font-weight: bold;
        }

        .pulse-glow {
            animation: pulse 1.5s infinite ease-in-out;
        }
        @keyframes pulse {
            0% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }
            50% { text-shadow: 0 0 5px var(--bg-color), 0 0 10px #000; }
            100% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }
        }

        #bios-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: var(--bios-text);
            font-family: 'VT323', monospace;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10000;
            display: none;
            white-space: pre;
        }

    </style>
</head>
<body>
    <div id="bios-overlay"></div>
    <div class="monitor-bezel">
        <div class="screen crt" id="main-screen">
            <div class="moving-scanline"></div>
            <div class="terminal-container" id="terminal-container">
                <h1 class="glitch chromatic-aberration" data-text="Lorel Axun v6.8"><span id="typewriter-title"></span></h1>
                
                <div id="initial-messages"></div>

                <div id="chat-history" class="chat-history"></div>

                <form class="input-line" id="input-form">
                    <span class="prompt">user@lorel:~$</span>
                    <span id="command-line"></span><span id="autocomplete-suggestion"></span><span id="cursor"></span>
                    <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                </form>
            </div>
            <div class="status-bar">
                <span>LOREL AXUN v6.8</span>
                <span>STATUS: <span class="pulse-glow">ONLINE</span></span>
                <span id="clock"></span>
            </div>
        </div>
    </div>

    <audio id="static-hum" loop src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8CAP3/AwD+/wEAAgD9/wEA/v8CAP7/AgD9/wMA/v8CAP7/AwD+/wE="></audio>

    <script>
        // --- asciichart.js (embedded) ---
        // Copyright (c) 2017, Andrei Kashcha
        // All rights reserved.
        const asciichart = (function() {
            function colored (char, color) {
                return (color === undefined) ? char : ('<span style="color: ' + color + '">' + char + '</span>')
            }
            function plot (series, cfg = undefined) {
                let min = (cfg && cfg.min !== undefined) ? cfg.min : series[0]
                let max = (cfg && cfg.max !== undefined) ? cfg.max : series[0]

                for (let i = 1; i < series.length; i++) {
                    min = Math.min(min, series[i])
                    max = Math.max(max, series[i])
                }

                let defaultSymbols = [ '┼', '┤', '╶', '╴', '─', '╰', '╯', '│', '╭', '╮', '│' ]
                let range = Math.abs (max - min)
                let offset = (cfg && cfg.offset !== undefined) ? cfg.offset : 3
                let padding = (cfg && cfg.padding !== undefined) ? cfg.padding : '           '
                let height = (cfg && cfg.height !== undefined) ? cfg.height : range
                let ratio = (range !== 0) ? height / range : 1;
                let min2 = Math.round (min * ratio)
                let max2 = Math.round (max * ratio)
                let rows = Math.abs (max2 - min2)
                let width = (cfg && cfg.width !== undefined) ? cfg.width : series.length + offset

                let result = new Array (rows + 1)
                for (let i = 0; i < rows + 1; i++) {
                    result[i] = new Array (width)
                    for (let j = 0; j < width; j++) {
                        result[i][j] = ' '
                    }
                }
                let y_labels = []
                for (let i = 0; i <= rows; i++) {
                  let y = max - (i * (range / rows))
                  y_labels.push(y.toFixed(2).padStart(padding.length - 2) + ' ' + defaultSymbols[0])
                }

                for (let y = min2; y <= max2; y++) {
                    result[rows - (y - min2)][offset - 1] = defaultSymbols[0]
                }

                for (let x = 0; x < series.length; x++) {
                    let y0 = Math.round (series[x] * ratio) - min2
                    result[rows - y0][x + offset] = defaultSymbols[4]

                    if (x > 0) {
                        let y1 = Math.round(series[x - 1] * ratio) - min2;
                        if (y0 == y1) {
                            result[rows - y0][x + offset -1] = defaultSymbols[4];
                        }
                    }
                }

                let lines = []
                for(let i=0; i < result.length; i++) {
                  lines.push(y_labels[i] + result[i].join(''))
                }

                return lines.join('\n')
            }
            return { plot: plot }
        })()

        // --- Lorel's Core Script ---
        const history = document.getElementById('chat-history');
        const commandLine = document.getElementById('command-line');
        const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');
        const terminalContainer = document.getElementById('terminal-container');
        const initialMessagesContainer = document.getElementById('initial-messages');
        const cursor = document.getElementById('cursor');
        const clock = document.getElementById('clock');
        const prompt = document.querySelector('.prompt');
        const hiddenInput = document.getElementById('hidden-input');
        const inputForm = document.getElementById('input-form');
        const biosOverlay = document.getElementById('bios-overlay');
        const mainScreen = document.getElementById('main-screen');

        let isTyping = false;
        let commandHistory = [];
        let historyIndex = -1;
        let activityTimeout;
        let userHasInteracted = false;
        let audioCtx = null;

        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear', 'stats', 'sysinfo', 'reboot'];
        const commandArgs = {};
        
        // --- Dynamic Title Engine ---
        function initTitleTypewriter() {
            const target = document.getElementById('typewriter-title');
            const phrases = [
                "Lorel Axun v6.8",
                "Status: ONLINE",
                "BIOS POST Beep",
                "Awaiting input..."
            ];
            let phraseIndex = 0;
            let charIndex = 0;
            let isDeleting = false;

            const typeSpeed = 100;
            const deleteSpeed = 50;
            const delay = 2000;

            function type() {
                const currentPhrase = phrases[phraseIndex];
                let displayText = '';

                if (isDeleting) {
                    displayText = currentPhrase.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    displayText = currentPhrase.substring(0, charIndex + 1);
                    charIndex++;
                }

                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;

                if (!isDeleting && charIndex === currentPhrase.length) {
                    isDeleting = true;
                    setTimeout(type, delay);
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    phraseIndex = (phraseIndex + 1) % phrases.length;
                    setTimeout(type, 500);
                } else {
                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);
                }
            }
            type();
        }

        // --- Audio Feedback Engine ---
        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA='; // A very short keyboard tick
        const keySoundPoolSize = 10; 
        const keySoundPool = [];
        let keySoundIndex = 0;

        for (let i = 0; i < keySoundPoolSize; i++) {
            keySoundPool.push(new Audio(KEY_CLICK_SOUND));
        }

        function playKeySound() {
            if(!userHasInteracted) return; // Don't play sounds until user interacts
            const sound = keySoundPool[keySoundIndex];
            sound.currentTime = 0;
            sound.play().catch(e => { /* Ignore errors from rapid playback or browser policy */ });
            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;
        }

        async function playBiosBeep() {
            return new Promise(resolve => {
                if (!audioCtx || !userHasInteracted) {
                    resolve();
                    return;
                }
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(900, audioCtx.currentTime); // High-pitched beep
                oscillator.type = 'sine';

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.15); // Beep for 150ms
                oscillator.onended = resolve;
            });
        }
        // --- End Audio ---

        // --- NLU Engine ---
        const classifier = {
            intents: {},
            train: function(intent, phrases) {
                if (!this.intents[intent]) this.intents[intent] = [];
                phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase)));
            },
            tokenize: text => text.toLowerCase().replace(/[^a-z0-9\s]/gi, '').split(/\s+/).filter(Boolean),
            classify: function(text) {
                const tokens = this.tokenize(text);
                let bestMatch = { intent: 'unknown', score: 0 };
                for (const intent in this.intents) {
                    let intentScore = 0;
                    this.intents[intent].forEach(phraseTokens => {
                        const commonTokens = tokens.filter(token => phraseTokens.includes(token));
                        const score = commonTokens.length / phraseTokens.length;
                        if (score > intentScore) intentScore = score;
                    });
                    if (intentScore > bestMatch.score) {
                        bestMatch = { intent, score: intentScore };
                    }
                }
                return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; // Confidence threshold
            }
        };

        const nerManager = {
            extractEntities: function(text, intent) {
                if (intent === 'weather') {
                    const match = text.match(/(?:a|per|di|a)\s(.+)/i);
                    if (match && match[1]) {
                        const entityText = match[1].trim().replace('?','');
                        return { value: `\"${entityText}\"`, text: entityText, type: 'LOCATION' };
                    }
                } else if (intent === 'wiki') {
                    const match = text.match(/(?:è|e'|di|su)\s(.+)/i);
                     if (match && match[1]) {
                        const entityText = match[1].trim().replace('?','');
                        return { value: `\"${entityText}\"`, text: entityText, type: 'TOPIC' };
                     }
                }
                return null; // No entity found
            }
        };

        function initializeNLU() {
            classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']);
            classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']);
            classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']);
            classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']);
            classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']);
        }
        // --- End NLU ---

        // Focus hidden input on any click
        terminalContainer.addEventListener('click', () => {
            hiddenInput.focus();
        });

        hiddenInput.addEventListener('input', () => {
            playKeySound();
            updateCommandLine();
            updateAutocompleteSuggestion();
        });

        function updateCommandLine() {
            const inputText = hiddenInput.value;
            const parts = inputText.split(' ');
            const command = parts[0].toLowerCase();
            
            if (availableCommands.includes(command) && parts[0] !== '') {
                const remainingText = escapeHtml(parts.slice(1).join(' '));
                commandLine.innerHTML = `<span class=\"command-known\">${escapeHtml(parts[0])}</span> ${remainingText}`;
            } else {
                commandLine.textContent = inputText;
            }
        }
        
        function updateAutocompleteSuggestion() {
            const currentInput = hiddenInput.value;
            if (currentInput.includes(' ') || currentInput.length === 0) {
                autocompleteSuggestion.textContent = '';
                return;
            }
            
            const matches = availableCommands.filter(cmd => cmd.startsWith(currentInput));
            
            if (matches.length === 1 && matches[0] !== currentInput) {
                autocompleteSuggestion.textContent = matches[0].substring(currentInput.length);
            } else {
                autocompleteSuggestion.textContent = '';
            }
        }

        function escapeHtml(text) {
            return text
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        inputForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (isTyping) return;

            prompt.classList.remove('listening');
            autocompleteSuggestion.textContent = '';
            const userInput = hiddenInput.value.trim();
            if (userInput) {
                if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {
                    commandHistory.push(userInput);
                    localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                }
                historyIndex = commandHistory.length;
                hiddenInput.value = '';
                commandLine.textContent = '';

                isTyping = true;
                cursor.style.display = 'none';
                
                const analysis = analyzeInput(userInput);
                addUserMessage(analysis.highlightedInput, true);
                await processCommand(analysis.command);
                saveChatHistory();

                if (parseCommand(userInput).command !== 'reboot') {
                    isTyping = false;
                    cursor.style.display = 'inline-block';
                    hiddenInput.focus();
                }
                scrollToBottom();
            }
        });

        hiddenInput.addEventListener('keydown', async function (e) {
            if (isTyping) return;

            if (!userHasInteracted) {
                const hum = document.getElementById('static-hum');
                hum.volume = 0.05;
                hum.play().catch(err => console.error("Ambient audio playback failed:", err));
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                userHasInteracted = true;
            }

            const key = e.key;

            clearTimeout(activityTimeout);
            prompt.classList.add('listening');
            activityTimeout = setTimeout(() => {
                prompt.classList.remove('listening');
            }, 1500);

            if (key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input'));
                }
            } else if (key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input'));
                } else {
                    historyIndex = commandHistory.length;
                    hiddenInput.value = '';
                    hiddenInput.dispatchEvent(new Event('input'));
                }
            } else if (key === 'Tab' || key === 'ArrowRight') {
                if(autocompleteSuggestion.textContent && hiddenInput.selectionStart === hiddenInput.value.length) {
                    e.preventDefault();
                    hiddenInput.value += autocompleteSuggestion.textContent;
                    hiddenInput.dispatchEvent(new Event('input'));
                } else if (key === 'Tab') {
                   e.preventDefault();
                   await handleLegacyAutocomplete();
                }
            } else if (key === 'Backspace') {
                 playKeySound();
            }
        });

        function analyzeInput(input) {
            const intent = classifier.classify(input);
            
            if (intent !== 'unknown') {
                const entity = nerManager.extractEntities(input, intent);
                if (entity) {
                    const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`);
                    const command = `${intent} ${entity.value}`
                    return { command, highlightedInput };
                }
                return { command: intent, highlightedInput: input }; // Intent recognized, but no entity
            }
            return { command: input, highlightedInput: input }; // Fallback to original input
        }

        async function handleLegacyAutocomplete() {
            const currentInput = hiddenInput.value;
            const parts = currentInput.split(' ');
            const lastPart = parts[parts.length - 1];

            if (parts.length === 1 && lastPart.length > 0) {
                const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart));
                if (matches.length > 1) {
                    await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`);
                }
                return;
            }
        }

        async function fetchCitySuggestions(partialName) {
            try {
                const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(partialName)}&count=5&language=it&format=json`);
                if (!response.ok) return [];
                const data = await response.json();
                if (data.results) {
                    const uniqueNames = new Set();
                    return data.results.map(loc => {
                        const name = `${loc.name}, ${loc.country_code}`
                        if(uniqueNames.has(name)) return null;
                        uniqueNames.add(name);
                        return name;
                    }).filter(name => name !== null);
                }
                return [];
            } catch (error) {
                console.error("City suggestion fetch error:", error);
                return [];
            }
        }
        
        function parseCommand(input) {
            const regex = /[^\s\"']+|\"([^\"]*)\"|'([^']*)'/g;
            const tokens = [];
            let match;
            do {
                match = regex.exec(input);
                if (match !== null) {
                    tokens.push(match[1] || match[2] || match[0]);
                }
            } while (match !== null);

            const command = tokens[0] ? tokens[0].toLowerCase() : '';
            const args = [];
            const flags = {};

            for (let i = 1; i < tokens.length; i++) {
                const token = tokens[i];
                if (token.startsWith('--')) {
                    const flagName = token.substring(2);
                    const nextToken = tokens[i + 1];
                    if (nextToken && !nextToken.startsWith('-')) {
                        flags[flagName] = nextToken;
                        i++;
                    } else {
                        flags[flagName] = true;
                    }
                } else if (token.startsWith('-')) {
                    const flagName = token.substring(1);
                     const nextToken = tokens[i + 1];
                    if (nextToken && !nextToken.startsWith('-')) {
                        flags[flagName] = nextToken;
                        i++;
                    } else {
                        flags[flagName] = true;
                    }
                } else {
                    args.push(token);
                }
            }
            return { command, args, flags };
        }

        function createAsciiTable(headers, data) {
            const colWidths = headers.map((header, i) => {
                return Math.max(header.length, ...data.map(row => String(row[i]).length));
            });

            const separator = '+' + colWidths.map(w => '-'.repeat(w + 2)).join('+') + '+';

            let table = separator + '\n';
            table += '|' + headers.map((h, i) => ` ${h.padEnd(colWidths[i])} `).join('|') + '|\n';
            table += separator + '\n';

            data.forEach(row => {
                table += '|' + row.map((cell, i) => ` ${String(cell).padEnd(colWidths[i])} `).join('|') + '|\n';
            });

            table += separator;
            return table;
        }

        async function processCommand(command) {
            const parsed = parseCommand(command);

            switch (parsed.command) {
                case 'help':
                    const helpText = `Comandi disponibili:\n` +
                                   `  help              - Mostra questa lista di comandi.\n` +
                                   `  status            - Mostra lo stato attuale del sistema.\n` +
                                   `  sysinfo           - Mostra informazioni di sistema in una tabella.\n` +
                                   `  date              - Mostra data e ora correnti.\n` +
                                   `  news [--limit N]  - Recupera N notizie (default 3).\n` +
                                   `  weather <città>   - Mostra il meteo per una città.\n` +
                                   `  wiki <termine>    - Cerca un termine su Wikipedia.\n` +
                                   `  stats             - Mostra un grafico ASCII di dati simulati.\n` +
                                   `  echo <testo>      - Ripete il testo fornito.\n` +
                                   `  clear             - Pulisce lo schermo del terminale.\n` +
                                   `  reboot            - Simula un riavvio dell'interfaccia.`;
                    await typeLorelMessage(helpText);
                    break;
                case 'status':
                    await typeLorelMessage('STATUS: ONLINE. Version: 6.8. All systems nominal. Use `sysinfo` for detailed report.');
                    break;
                case 'sysinfo':
                    const headers = ['Property', 'Value'];
                    const tableData = [
                        ['Version', '6.8 - BIOS POST Beep'],
                        ['Creator', 'AleXsjsju'],
                        ['Created', '2025-11-22'],
                        ['Status', 'ONLINE'],
                        ['Modules', 'BIOS Beep, Ghost Autocomplete']
                    ];
                    const table = createAsciiTable(headers, tableData);
                    addLorelMessage('<pre>' + escapeHtml(table) + '</pre>', true);
                    break;
                case 'date':
                    await typeLorelMessage(new Date().toLocaleString('it-IT'));
                    break;
                case 'clear':
                    history.innerHTML = '';
                    localStorage.removeItem('chatHistory');
                    break;
                 case 'reboot':
                    await runRebootSequence();
                    break;
                case 'echo':
                    await typeLorelMessage(parsed.args.length > 0 ? parsed.args.join(' ') : '');
                    break;
                case 'news':
                    const limit = parsed.flags.limit || 3;
                    await fetchNews(limit);
                    break;
                case 'weather':
                    if (parsed.args.length === 0) {
                        await typeLorelMessage('Uso: weather <città> o chiedi \"che tempo fa a <città>?\"');
                    } else {
                        await fetchWeather(parsed.args.join(' '));
                    }
                    break;
                case 'wiki':
                     if (parsed.args.length === 0) {
                        await typeLorelMessage('Uso: wiki <termine da cercare> o chiedi \"cosa è <termine>?\"');
                    } else {
                        await fetchWikipedia(parsed.args.join(' '));
                    }
                    break;
                case 'stats':
                    await typeLorelMessage('Generating system performance chart...');
                    let s = new Array (120);
                    for (let i = 0; i < s.length; i++) {
                        s[i] = 15 * Math.sin (i * ((Math.PI * 4) / s.length));
                    }
                    const chart = asciichart.plot(s, { height: 10 });
                    addLorelMessage('<pre>' + escapeHtml(chart) + '</pre>', true);
                    await typeLorelMessage('Chart depicts simulated CPU load over the last 60 seconds.');
                    break;
                default:
                    await typeLorelMessage(`Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`);
                    break;
            }
        }

        async function runRebootSequence() {
            await typeLorelMessage("[SYSTEM] Reboot sequence initiated... Shutting down.");
            await new Promise(resolve => setTimeout(resolve, 1000));

            mainScreen.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 500));

            biosOverlay.style.display = 'block';
            const biosLines = [
                { text: 'LorelAxun BIOS v1.1', delay: 500 },
                { text: 'Copyright (c) 2025 AleXsjsju Corp.', delay: 200 },
                { text: '', delay: 500 },
                { text: 'Initializing Core Memory.................... ', delay: 300 },
                { text: '65536 KB OK', delay: 100, append: true, action: playBiosBeep },
                { text: '\nDetecting Primary Master.................. LAX-HD-01', delay: 800 },
                { text: 'Detecting Primary Slave................. None', delay: 800 },
                { text: 'Detecting Secondary Master................ None', delay: 800 },
                { text: 'Detecting Secondary Slave................. None', delay: 800 },
                { text: '', delay: 500 },
                { text: 'Checking NVRAM............................ OK', delay: 400 },
                { text: 'Initializing Web-Access Layer........... OK', delay: 600 },
                { text: '', delay: 1000 },
                { text: 'Booting from Primary Master (LAX-HD-01)...', delay: 500 },
            ];

            for (const line of biosLines) {
                await new Promise(resolve => setTimeout(resolve, line.delay));
                if (line.append) {
                    biosOverlay.textContent += line.text;
                } else {
                    biosOverlay.textContent += line.text + '\n';
                }
                if (line.action) {
                    await line.action();
                }
            }

            await new Promise(resolve => setTimeout(resolve, 1500));
            biosOverlay.style.display = 'none';
            biosOverlay.textContent = '';

            mainScreen.style.opacity = '1';
            history.innerHTML = '';
            initialMessagesContainer.innerHTML = '';
            localStorage.removeItem('chatHistory');
            displayInitialMessages();
            await typeLorelMessage("System reboot complete. Welcome back.");

            isTyping = false;
            cursor.style.display = 'inline-block';
            hiddenInput.focus();
        }

        async function fetchWikipedia(term) {
            await typeLorelMessage(`Ricerca su Wikipedia per \"${term}\"...`);
            try {
                const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`;
                const searchResponse = await fetch(searchUrl);
                if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`);
                const searchData = await searchResponse.json();

                if (!searchData.query.search || searchData.query.search.length === 0) {
                    throw new Error(`Nessun risultato trovato per \"${term}\".`);
                }

                const searchResults = searchData.query.search;
                
                if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) {
                    let disambiguation = false;
                    if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true;

                    if(disambiguation || searchResults.length > 2) {
                        let suggestionText = `Trovati più risultati per \"${term}\". Essere più specifici:\n`;
                        searchResults.slice(0, 5).forEach(res => {
                            suggestionText += `  - ${res.title}\n`;
                        });
                        suggestionText += `Esempio: wiki \"${searchResults[0].title}\"`
                        await typeLorelMessage(suggestionText);
                        return;
                    }
                }

                const pageTitle = searchResults[0].title;
                await typeLorelMessage(`Trovata pagina: \"${pageTitle}\".\nRecupero riassunto...`);

                const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`;
                const summaryResponse = await fetch(summaryUrl);
                if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`);
                const summaryData = await summaryResponse.json();

                const pages = summaryData.query.pages;
                const pageId = Object.keys(pages)[0];
                const extract = pages[pageId].extract;

                if (extract) {
                    await typeLorelMessage(extract);
                } else {
                    throw new Error(`Nessun riassunto disponibile per \"${pageTitle}\". Potrebbe essere una pagina di reindirizzamento o disambiguazione.`);
                }

            } catch (error) {
                await typeLorelMessage(`Errore durante la ricerca su Wikipedia: ${error.message}`);
            }
        }

        async function fetchWeather(city) {
            await typeLorelMessage(`Ricerca coordinate per ${city}...`);
            try {
                const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`);
                if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`);
                const geoData = await geoResponse.json();
                
                if (!geoData.results || geoData.results.length === 0) {
                    throw new Error(`Località non trovata: ${city}`);
                }

                const uniqueLocations = [];
                const seen = new Set();
                for (const loc of geoData.results) {
                    const identifier = `${loc.name}, ${loc.admin1 || loc.country}`
                    if (!seen.has(identifier)) {
                        uniqueLocations.push(loc);
                        seen.add(identifier);
                    }
                }

                let location;
                if (uniqueLocations.length > 1 && !city.includes(',')) {
                    let suggestionText = `Trovate più località per \"${city}\". Essere più specifici:\n`;
                    uniqueLocations.slice(0, 3).forEach(loc => {
                        suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\n`;
                    });
                    suggestionText += `Esempio: weather \"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\"`
                    await typeLorelMessage(suggestionText);
                    return;
                } else {
                    location = uniqueLocations[0];
                }

                const { latitude, longitude, name, admin1, country_code } = location;
                const locationName = `${name}, ${admin1 || country_code}`
                await typeLorelMessage(`Coordinate trovate per ${locationName}.\nRecupero dati meteo...`);

                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
                if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`);
                const weatherData = await weatherResponse.json();
                
                const { temperature, windspeed, weathercode } = weatherData.current_weather;
                const weatherDescription = getWeatherDescription(weathercode);

                const weatherReport = `Meteo attuale per ${locationName}:\n` +
                                    `  - Descrizione: ${weatherDescription}\n` +
                                    `  - Temperatura: ${temperature}°C\n` +
                                    `  - Vento: ${windspeed} km/h`;
                await typeLorelMessage(weatherReport);

            } catch (error) {
                await typeLorelMessage(`Errore durante il recupero del meteo: ${error.message}`);
            }
        }

        function getWeatherDescription(code) {
            const descriptions = {
                0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso',
                45: 'Nebbia', 48: 'Nebbia con brina',
                51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa',
                61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte',
                71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte',
                80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento',
                95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante'
            };
            return descriptions[code] || 'Condizioni non specificate';
        }

        async function fetchNews(limit = 3) {
            await typeLorelMessage(`Recupero ${limit} notizie dal web...`);
            try {
                const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                let newsHeadlines = 'Ultime notizie recuperate:\n';
                data.forEach((article, index) => {
                    const title = article.title.charAt(0).toUpperCase() + article.title.slice(1);
                    newsHeadlines += `\n[${index + 1}] ${title}`;
                });
                await typeLorelMessage(newsHeadlines);
            } catch (error) {
                await typeLorelMessage(`Errore durante il recupero delle notizie: ${error.message}`);
            }
        }

        async function typeLorelMessage(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'msg lorel';
            history.appendChild(messageDiv);
            scrollToBottom();

            const chunks = text.split('\n');

            for (let i = 0; i < chunks.length; i++) {
                const chunk = chunks[i];
                if (i > 0) {
                    messageDiv.innerText += '\n';
                    const pauseDuration = 250 + Math.random() * 300;
                    await new Promise(resolve => setTimeout(resolve, pauseDuration));
                }

                for (let j = 0; j < chunk.length; j++) {
                    const char = chunk.charAt(j);
                    messageDiv.innerText += char;
                    playKeySound();
                    scrollToBottom();

                    const speed = 30 + (Math.random() * 25);
                    await new Promise(resolve => setTimeout(resolve, speed));

                    if (char === ',') {
                        await new Promise(resolve => setTimeout(resolve, 250 + Math.random() * 100));
                    } else if (char === '.' || char === '!' || char === '?') {
                        await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 150));
                    }
                }
            }
            saveChatHistory();
        }
        
        function addLorelMessage(text, isHtml = false) {
            const div = document.createElement('div');
            div.className = 'msg lorel';
            if (isHtml) {
                div.innerHTML = text;
            } else {
                div.innerText = text;
            }
            history.appendChild(div);
            saveChatHistory();
            scrollToBottom();
        }

        function addUserMessage(text, isHtml = false) {
            const div = document.createElement('div');
            div.className = 'msg user';
            if (isHtml) {
                div.innerHTML = text;
            } else {
                div.innerText = text;
            }
            history.appendChild(div);
            saveChatHistory();
            scrollToBottom();
        }

        function saveChatHistory() {
            localStorage.setItem('chatHistory', history.innerHTML);
        }

        function loadHistory() {
            const savedCommandHistory = localStorage.getItem('commandHistory');
            if(savedCommandHistory) {
                commandHistory = JSON.parse(savedCommandHistory);
                historyIndex = commandHistory.length;
            }
            const savedChat = localStorage.getItem('chatHistory');
            if (savedChat) {
                history.innerHTML = savedChat;
            }
        }

        function displayInitialMessages() {
            const messages = [
                '[SYSTEM] Initializing core memory... OK',
                '[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span>',
                '[UPDATE] Session persistence enabled via localStorage. History is now saved.',
                '[AESTHETICS] Keystroke audio feedback enabled.',
                '[SYSTEM] Advanced command parser implemented. Now supports quoted arguments and flags.',
                '[AESTHETICS] Title animation upgraded to a dynamic, cyclical typewriter effect.',
                '[OPTIMIZATION] Blinking cursor animation refined for code simplicity and efficiency.',
                '[REFINEMENT] Typing speed now has random variations for a more organic feel.',
                '[IMMERSION] Ambient static hum enabled for a complete CRT experience.',
                '[REFINEMENT] Long responses are now streamed chunk-by-chunk for a more dynamic feel.',
                '[AESTHETICS] Added chromatic aberration text animation for enhanced visual authenticity.',
                '[AESTHETICS] Monitor bezel effect added to encapsulate the interface.',
                '[AESTHETICS] Added moving scanline effect to simulate CRT refresh cycle.',
                '[INTEGRATION] User input now handled by a robust, invisible `<input>` for improved compatibility.',
                '[LEXICAL ANALYSIS] User command syntax is now highlighted in real-time for instant feedback.',
                '[ASSISTANCE] Command autocompletion (Tab key) is now active for predictive input.',
                '[VISUALIZATION] Data visualization enabled via ASCII charts. Try the \'stats\' command.',
                '[VISUALIZATION] Data tabulation enabled via ASCII tables. Try the \'sysinfo\' command.',
                '[REFINEMENT] Lorel\\'s typing rhythm is now more natural, with conversational pauses.',
                '[AESTHETICS] \'ONLINE\' status indicator is now animated with a pulsing glow effect.',
                '[ASSISTANCE] Inline command autocompletion suggestions (\'ghost text\') are now active.',
                '[SYSTEM] Reboot Protocol module loaded. Type \'reboot\' to restart the interface.',
                '[IMMERSION] Reboot sequence now features a simulated BIOS POST screen with an audible beep.',
            ];
            let content = '';
            messages.forEach(msg => {
                content += `<div class=\"sys-msg\">${msg}</div>`;
            });
            initialMessagesContainer.innerHTML = content;
        }

        function scrollToBottom() {
             terminalContainer.scrollTop = terminalContainer.scrollHeight;
        }

        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('it-IT');
            clock.textContent = timeString;
        }
        
        window.onload = async () => {
            initTitleTypewriter();
            initializeNLU();
            loadHistory();
            displayInitialMessages();
            updateClock();
            setInterval(updateClock, 1000);
            isTyping = true;
            cursor.style.display = 'none';
            if (!localStorage.getItem('chatHistory')) {
                await typeLorelMessage("Interfaccia v6.8. Il riavvio del BIOS ora emette un segnale acustico di POST per un'immersione completa.");
            }
            isTyping = false;
            cursor.style.display = 'inline-block';
            hiddenInput.focus();
            scrollToBottom();
        }

    </script>
</body>
</html>
