<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOREL AXUN V2.7 // ADVANCED PARSER</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --term-green: #33ff00;
            --term-dim: #1a8000;
            --term-glow: #33ff0080;
            --scanline: rgba(0, 0, 0, 0.5);
        }
        body {
            background-color: var(--bg-color);
            color: var(--term-green);
            font-family: 'VT323', monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 1.2rem;
        }
        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        .crt::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }
        }
        
        .terminal-container {
            padding: 20px;
            flex-grow: 1;
            overflow-y: auto;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--term-glow);
        }

        h1 {
            border-bottom: 2px solid var(--term-green);
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }
        .sys-msg span { color: var(--term-green); font-weight: bold; }

        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; }

        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }
        .msg.lorel::before { content: "LOREL_SYS>> "; color: var(--term-green); }
        .msg.user::before { content: "USER_INPUT>> "; color: #00ffff; }
        .msg.user { color: #ccffff; }

        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; margin-top: auto; }
        .prompt { margin-right: 10px; color: var(--term-green); }
        
        #command-line {
            outline: none;
        }
        #cursor {
            background: var(--term-green);
            display: inline-block;
            width: 10px;
            height: 1.2rem;
            animation: cursor-blink 1s step-end infinite;
            box-shadow: 0 0 5px var(--term-glow);
            vertical-align: middle;
        }
        @keyframes cursor-blink {
            50% { opacity: 0; }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }

        .glitch {
            position: relative;
        }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
        }
        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);
            animation: glitch-anim-2 2.5s infinite steps(8) reverse;
        }
        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
            animation: glitch-anim-2 2.5s infinite steps(8);
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }
        }
    </style>
</head>
<body class="crt">
    <div class="terminal-container" id="terminal-container">
        <h1 class="glitch" data-text="Lorel Axun v2.7 _">Lorel Axun v2.7 _</h1>
        
        <div class="sys-msg">[SYSTEM] Initializing core memory... OK</div>
        <div class="sys-msg">[NETWORK] Testing connection... <span style="color:var(--term-green)">SUCCESS</span></div>
        <div class="sys-msg">[UPDATE] Advanced command parser implemented.</div>
        <div class="sys-msg">[UPDATE] New command 'echo' available.</div>
        <div class="sys-msg">[AESTHETICS] Terminal immersion enhanced.</div>
        <div class="sys-msg">[STATUS] <span style="animation: blinker 1s linear infinite;">ONLINE</span></div>
        <br>
        
        <div id="chat-history" class="chat-history"></div>

        <div class="input-line" id="input-line">
            <span class="prompt">user@lorel:~$</span>
            <span id="command-line"></span><span id="cursor"></span>
        </div>
    </div>

    <script>
        const history = document.getElementById('chat-history');
        const commandLine = document.getElementById('command-line');
        const terminalContainer = document.getElementById('terminal-container');
        const inputLine = document.getElementById('input-line');
        const cursor = document.getElementById('cursor');

        let isTyping = false;

        document.addEventListener('keydown', async function (e) {
            if (isTyping) return;

            e.preventDefault();
            const key = e.key;

            if (key === 'Enter') {
                const command = commandLine.textContent.trim();
                if (command) {
                    addUserMessage(command);
                    commandLine.textContent = '';
                    
                    isTyping = true;
                    cursor.style.display = 'none';
                    
                    await processCommand(command);

                    isTyping = false;
                    cursor.style.display = 'inline-block';
                    scrollToBottom();
                }
            } else if (key === 'Backspace') {
                commandLine.textContent = commandLine.textContent.slice(0, -1);
            } else if (key.length === 1) { // Handle printable characters
                commandLine.textContent += key;
            }
        });
        
        function parseArguments(commandString) {
            const regex = /[^\s"']+|"([^"]*)"|'([^']*)'/g;
            const args = [];
            let match;
            do {
                match = regex.exec(commandString);
                if (match !== null) {
                    args.push(match[1] || match[2] || match[0]);
                }
            } while (match !== null);
            return args;
        }

        async function processCommand(command) {
            const parts = parseArguments(command);
            const mainCommand = parts[0] ? parts[0].toLowerCase() : '';
            const args = parts.slice(1);

            switch (mainCommand) {
                case 'help':
                    const helpText = `Comandi disponibili:\n` +
                                   `  help              - Mostra questa lista di comandi.\n` +
                                   `  status            - Mostra lo stato attuale del sistema.\n` +
                                   `  date              - Mostra data e ora correnti.\n` +
                                   `  news              - Recupera le ultime notizie dal web.\n` +
                                   `  weather <città>   - Mostra il meteo attuale per la città specificata.\n` +
                                   `  echo <testo>      - Ripete il testo fornito. Gestisce gli argomenti tra virgolette.\n` +
                                   `  clear             - Pulisce lo schermo del terminale.`;
                    await typeLorelMessage(helpText);
                    break;
                case 'status':
                    await typeLorelMessage('STATUS: ONLINE. Version: 2.7. Modules: Advanced Parser, API Fetch (Active).');
                    break;
                case 'date':
                    await typeLorelMessage(new Date().toLocaleString('it-IT'));
                    break;
                case 'clear':
                    history.innerHTML = '';
                    break;
                case 'echo':
                    if (args.length > 0) {
                        await typeLorelMessage(args.join(' '));
                    } else {
                        await typeLorelMessage('');
                    }
                    break;
                case 'news':
                    await fetchNews();
                    break;
                case 'weather':
                    if (args.length === 0) {
                        await typeLorelMessage('Uso: weather <città>');
                    } else {
                        await fetchWeather(args.join(' '));
                    }
                    break;
                default:
                    await typeLorelMessage(`Comando non riconosciuto: '${command}'. Digita 'help' per la lista dei comandi.`);
                    break;
            }
        }

        async function fetchWeather(city) {
            await typeLorelMessage(`Ricerca coordinate per ${city}...`);
            try {
                const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=it&format=json`);
                if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`);
                const geoData = await geoResponse.json();
                if (!geoData.results || geoData.results.length === 0) {
                    throw new Error(`Città non trovata: ${city}`);
                }
                const location = geoData.results[0];
                const { latitude, longitude, name, admin1 } = location;
                await typeLorelMessage(`Coordinate trovate per ${name}, ${admin1}. Recupero dati meteo...`);

                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
                if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`);
                const weatherData = await weatherResponse.json();
                
                const { temperature, windspeed, weathercode } = weatherData.current_weather;
                const weatherDescription = getWeatherDescription(weathercode);

                const weatherReport = `Meteo attuale per ${name}, ${admin1}:\n` +
                                    `  - Descrizione: ${weatherDescription}\n` +
                                    `  - Temperatura: ${temperature}°C\n` +
                                    `  - Vento: ${windspeed} km/h`;
                await typeLorelMessage(weatherReport);

            } catch (error) {
                await typeLorelMessage(`Errore durante il recupero del meteo: ${error.message}`);
            }
        }

        function getWeatherDescription(code) {
            const descriptions = {
                0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso',
                45: 'Nebbia', 48: 'Nebbia con brina',
                51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa',
                61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte',
                71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte',
                80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento',
                95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante'
            };
            return descriptions[code] || 'Condizioni non specificate';
        }

        async function fetchNews() {
            await typeLorelMessage('Recupero notizie dal web...');
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=3');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                let newsHeadlines = 'Ultime notizie recuperate:\n\n';
                data.forEach((article, index) => {
                    const title = article.title.charAt(0).toUpperCase() + article.title.slice(1);
                    newsHeadlines += `[${index + 1}] ${title}\n`;
                });
                await typeLorelMessage(newsHeadlines);
            } catch (error) {
                await typeLorelMessage(`Errore durante il recupero delle notizie: ${error.message}`);
            }
        }

        function typeLorelMessage(text) {
            return new Promise(resolve => {
                const div = document.createElement('div');
                div.className = 'msg lorel';
                history.appendChild(div);
                scrollToBottom();

                let i = 0;
                const speed = 25; // ms

                function type() {
                    if (i < text.length) {
                        div.innerText += text.charAt(i);
                        i++;
                        scrollToBottom();
                        setTimeout(type, speed);
                    } else {
                        resolve();
                    }
                }
                type();
            });
        }
        
        function addUserMessage(text) {
            const div = document.createElement('div');
            div.className = 'msg user';
            div.innerText = text;
            history.appendChild(div);
            scrollToBottom();
        }

        function scrollToBottom() {
             terminalContainer.scrollTop = terminalContainer.scrollHeight;
        }
        
        // Initial greeting
        window.onload = async () => {
            isTyping = true;
            cursor.style.display = 'none';
            await typeLorelMessage("Interfaccia v2.7. Advanced parser online. Digita 'help' per una lista di comandi.");
            isTyping = false;
            cursor.style.display = 'inline-block';
        }

    </script>
</body>
</html>