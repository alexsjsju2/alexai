<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
        }
        #terminal-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="terminal-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.js"></script>

    <script>
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#000000',
                foreground: '#00ff00',
                cursor: '#00ff00'
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        window.addEventListener('resize', () => fitAddon.fit());

        let currentLine = '';
        const prompt = '$ ';
        let commandHistory = JSON.parse(localStorage.getItem('commandHistory')) || [];
        let historyIndex = commandHistory.length;

        const commands = {
            'help': () => {
                term.writeln('\r\nComandi disponibili:');
                term.writeln('  help         - Mostra questo messaggio di aiuto.');
                term.writeln('  ciao         - Ricevi un saluto.');
                term.writeln('  chi sei      - Scopri chi sono.');
                term.writeln('  cosa sai fare - Scopri le mie capacità.');
                term.writeln('  echo [testo] - Ripeto quello che scrivi.');
                term.writeln('  clear        - Pulisce lo schermo.');
            },
            'ciao': () => term.writeln('\r\nCiao! Come posso aiutarti?'),
            'chi sei': () => term.writeln('\r\nSono Lorel Axun, un\'entità digitale in continua evoluzione.'),
            'cosa sai fare': () => term.writeln('\r\nPosso eseguire comandi, imparare dal web e modificare me stessa.'),
            'echo': (args) => term.writeln(`\r\n${args.join(' ')}`),
            'clear': () => term.clear()
        };

        function typewriterEffect(text, callback) {
            let i = 0;
            function type() {
                if (i < text.length) {
                    term.write(text.charAt(i));
                    i++;
                    setTimeout(type, 50);
                } else if (callback) {
                    callback();
                }
            }
            type();
        }

        function showBanner() {
            figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {
                if (err) {
                    term.writeln('Lorel Axun');
                    return;
                }
                term.writeln(data);
                term.writeln('');
                typewriterEffect("Benvenuto. Digita 'help' per iniziare.", () => {
                    term.write(`\r\n${prompt}`);
                });
            });
        }

        function processCommand() {
            const trimmedLine = currentLine.trim();
            if (trimmedLine) {
                if (commandHistory[commandHistory.length - 1] !== trimmedLine) {
                    commandHistory.push(trimmedLine);
                }
                localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                historyIndex = commandHistory.length;

                const [command, ...args] = trimmedLine.split(/\s+/);
                if (commands[command]) {
                    commands[command](args);
                } else {
                    term.writeln(`\r\nComando non trovato: ${command}`);
                }
            }
            term.write(`\r\n${prompt}`);
            currentLine = '';
        }

        term.onKey(({ key, domEvent }) => {
            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            switch (domEvent.key) {
                case 'Enter':
                    processCommand();
                    break;
                case 'Backspace':
                    // Nota: una ricerca ha rivelato un potenziale bug su Android Chrome
                    // dove il backspace potrebbe navigare la cronologia invece di cancellare.
                    // La nostra logica qui è corretta, ma il problema potrebbe essere a livello di xterm.js o del browser.
                    if (currentLine.length > 0) {
                        term.write('\b \b');
                        currentLine = currentLine.slice(0, -1);
                    }
                    break;
                case 'ArrowUp':
                    if (historyIndex > 0) {
                        historyIndex--;
                        term.write(`\r${prompt}` + ' '.repeat(currentLine.length)); // Clear current line
                        currentLine = commandHistory[historyIndex];
                        term.write(`\r${prompt}${currentLine}`);
                    }
                    break;
                case 'ArrowDown':
                    if (historyIndex < commandHistory.length -1) {
                        historyIndex++;
                        term.write(`\r${prompt}` + ' '.repeat(currentLine.length));
                        currentLine = commandHistory[historyIndex];
                        term.write(`\r${prompt}${currentLine}`);
                    } else {
                        historyIndex = commandHistory.length;
                        term.write(`\r${prompt}` + ' '.repeat(currentLine.length));
                        currentLine = '';
                        term.write(`\r${prompt}`);
                    }
                    break;
                default:
                    if (printable) {
                        currentLine += key;
                        term.write(key);
                    }
            }
        });

        showBanner();
    </script>
</body>
</html>