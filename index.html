<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lorel Axun</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/xterm/css/xterm.css\" />\n    <style>\n        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background-color: #000; }\n        #terminal-container { height: 100%; width: 100%; }\n    </style>\n</head>\n<body>\n    <div id=\"terminal-container\"></div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/figlet/lib/figlet.js\"></script>\n\n    <script>\n        const terminalContainer = document.getElementById('terminal-container');\n        const term = new Terminal({\n            cursorBlink: true,\n            theme: {\n                background: '#000000',\n                foreground: '#00FF00',\n                cursor: '#00FF00'\n            }\n        });\n        const fitAddon = new FitAddon.FitAddon();\n        term.loadAddon(fitAddon);\n        term.open(terminalContainer);\n        fitAddon.fit();\n\n        window.addEventListener('resize', () => fitAddon.fit());\n\n        let vfs = {};\n        let currentDir = '/home/user';\n        let history = [];\n        let historyIndex = 0;\n        let currentCommand = '';\n        let env = {};\n\n        const defaultEnv = {\n            'USER': 'user',\n            'HOME': '/home/user',\n            'PS1': '\\w $ '\n        };\n\n        function saveState() {\n            const state = {\n                vfs: vfs,\n                currentDir: currentDir,\n                history: history,\n                env: env\n            };\n            localStorage.setItem('lorel_axun_state', JSON.stringify(state));\n        }\n\n        function loadState() {\n            const stateString = localStorage.getItem('lorel_axun_state');\n            if (stateString) {\n                const state = JSON.parse(stateString);\n                vfs = state.vfs || {};\n                currentDir = state.currentDir || '/home/user';\n                history = state.history || [];\n                env = { ...defaultEnv, ...(state.env || {}) };\n                historyIndex = history.length;\n                return true;\n            } else {\n                // Initial setup\n                env = { ...defaultEnv };\n                vfs = {\n                    '/': { type: 'dir', content: ['home'] },\n                    '/home': { type: 'dir', content: ['user'] },\n                    '/home/user': { type: 'dir', content: ['readme.txt', '.axunrc'] },\n                    '/home/user/readme.txt': {\n                        type: 'file',\n                        content: `Welcome to Lorel Axun OS.\\n\\nThis is a web-based shell environment.\\nHere are some commands you can try:\\n- ls: list files\\n- cat <file>: view file content\\n- edit <file>: edit a file (Ctrl+S to save, Ctrl+X to exit)\\n- js <file>: execute a JavaScript file in a sandbox\\n- fetch <url>: make an HTTP GET request\\n- help: show all available commands\\n\\nNEW: This shell now supports a startup script!\\nCreate or edit the file ~/.axunrc to add commands\\nthat will run automatically every time you load the shell.\\nThis is great for setting aliases or environment variables.\\n`\n                    },\n                    '/home/user/.axunrc': {\n                        type: 'file',\n                        content: `# Lorel Axun startup script\\n# This file is executed when the shell starts.\\n# You can add commands here to customize your environment.\\n\\n# Example: set a custom prompt\\n# export PS1=\"ðŸš€ \\\\w $ \"\\n\\n# Example: welcome message\\necho \"Welcome back, $USER. Your .axunrc is loaded.\"\\n`\n                    }\n                };\n                currentDir = '/home/user';\n                saveState();\n                return false;\n            }\n        }\n\n        function resolvePath(path) {\n            if (path.startsWith('/')) {\n                return path;\n            }\n            const parts = (currentDir === '/' ? '' : currentDir).split('/').concat(path.split('/'));\n            const resolved = [];\n            for (const part of parts) {\n                if (part === '' || part === '.') continue;\n                if (part === '..') {\n                    if (resolved.length > 0) resolved.pop();\n                } else {\n                    resolved.push(part);\n                }\n            }\n            return '/' + resolved.join('/');\n        }\n\n        function parseArguments(command) {\n            const args = [];\n            let currentArg = '';\n            let inQuote = false;\n            for (let i = 0; i < command.length; i++) {\n                const char = command[i];\n                if (char === '\"') {\n                    inQuote = !inQuote;\n                } else if (char === ' ' && !inQuote) {\n                    if (currentArg.length > 0) {\n                        args.push(currentArg);\n                        currentArg = '';\n                    }\n                } else {\n                    currentArg += char;\n                }\n            }\n            if (currentArg.length > 0) {\n                args.push(currentArg);\n            }\n            return args.map(arg => arg.replace(/\\$(\\w+)/g, (match, varName) => env[varName] || ''));\n        }\n\n        async function executeCommand(command, addToHistory = true) {\n            if (command.trim() !== '' && addToHistory) {\n                history.push(command);\n                historyIndex = history.length;\n                saveState();\n            }\n\n            const pipelines = command.split('|').map(c => c.trim());\n            let input = null;\n\n            for (let i = 0; i < pipelines.length; i++) {\n                let cmdPart = pipelines[i];\n                let outputRedirect = null;\n                let appendRedirect = null;\n\n                if (cmdPart.includes('>>')) {\n                    [cmdPart, appendRedirect] = cmdPart.split('>>').map(s => s.trim());\n                } else if (cmdPart.includes('>')) {\n                    [cmdPart, outputRedirect] = cmdPart.split('>').map(s => s.trim());\n                }\n\n                const args = parseArguments(cmdPart);\n                const cmd = args[0];\n                const cmdArgs = args.slice(1);\n\n                if (input !== null) {\n                    cmdArgs.push(input);\n                }\n\n                let output = '';\n                try {\n                    if (commands[cmd]) {\n                        output = await commands[cmd](cmdArgs);\n                    } else {\n                        output = `Command not found: ${cmd}`;\n                    }\n                } catch (e) {\n                    output = `Error: ${e.message}`;\n                }\n\n                if (outputRedirect) {\n                    const path = resolvePath(outputRedirect);\n                    vfs[path] = { type: 'file', content: output };\n                    saveState();\n                    output = ''; // No output to terminal or next pipe\n                } else if (appendRedirect) {\n                    const path = resolvePath(appendRedirect);\n                    if (vfs[path] && vfs[path].type === 'file') {\n                        vfs[path].content += output;\n                    } else {\n                        vfs[path] = { type: 'file', content: output };\n                    }\n                    saveState();\n                    output = ''; // No output to terminal or next pipe\n                }\n\n                if (i < pipelines.length - 1) {\n                    input = output;\n                } else if (output) {\n                    term.writeln(output.replace(/\\n/g, '\\r\\n'));\n                }\n            }\n        }\n\n        const commands = {\n            help: async () => 'Available commands: ciao, chi sei, help, echo, clear, ls, cat, mkdir, touch, rm, cd, edit, fetch, js, export, unset, env',\n            ciao: async () => 'Ciao! Sono Lorel Axun. Come posso aiutarti?',\n            'chi': async (args) => args[0] === 'sei' ? 'Sono Lorel Axun, un\\'intelligenza artificiale in evoluzione.' : 'Comando non valido.',\n            echo: async (args) => args.join(' '),\n            clear: async () => { term.clear(); return ''; },\n            ls: async (args) => {\n                const path = args.length > 0 ? resolvePath(args[0]) : currentDir;\n                if (vfs[path] && vfs[path].type === 'dir') {\n                    return vfs[path].content.join('\\t');\n                } else {\n                    return `ls: cannot access '${args[0] || '.'}': No such file or directory`;\n                }\n            },\n            cat: async (args) => {\n                if (args.length === 0) return 'Usage: cat <file>';\n                const path = resolvePath(args[0]);\n                if (vfs[path] && vfs[path].type === 'file') {\n                    return vfs[path].content;\n                } else {\n                    return `cat: ${args[0]}: No such file or directory`;\n                }\n            },\n            mkdir: async (args) => {\n                if (args.length === 0) return 'Usage: mkdir <directory>';\n                const newDirPath = resolvePath(args[0]);\n                const parentPath = newDirPath.substring(0, newDirPath.lastIndexOf('/')) || '/';\n                const newDirName = newDirPath.substring(newDirPath.lastIndexOf('/') + 1);\n\n                if (vfs[newDirPath]) return `mkdir: cannot create directory '${args[0]}': File exists`;\n                if (!vfs[parentPath] || vfs[parentPath].type !== 'dir') return `mkdir: cannot create directory '${args[0]}': No such file or directory`;\n\n                vfs[newDirPath] = { type: 'dir', content: [] };\n                vfs[parentPath].content.push(newDirName);\n                saveState();\n                return '';\n            },\n            touch: async (args) => {\n                if (args.length === 0) return 'Usage: touch <file>';\n                const path = resolvePath(args[0]);\n                if (!vfs[path]) {\n                    const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';\n                    const fileName = path.substring(path.lastIndexOf('/') + 1);\n                    if (vfs[parentPath] && vfs[parentPath].type === 'dir') {\n                        vfs[path] = { type: 'file', content: '' };\n                        vfs[parentPath].content.push(fileName);\n                        saveState();\n                    }\n                }\n                return '';\n            },\n            rm: async (args) => {\n                if (args.length === 0) return 'Usage: rm <file_or_dir>';\n                const path = resolvePath(args[0]);\n                if (!vfs[path]) return `rm: cannot remove '${args[0]}': No such file or directory`;\n                if (vfs[path].type === 'dir' && vfs[path].content.length > 0) return `rm: cannot remove '${args[0]}': Directory not empty`;\n\n                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';\n                const fileName = path.substring(path.lastIndexOf('/') + 1);\n                delete vfs[path];\n                vfs[parentPath].content = vfs[parentPath].content.filter(item => item !== fileName);\n                saveState();\n                return '';\n            },\n            cd: async (args) => {\n                const target = args[0] || env['HOME'];\n                const path = resolvePath(target);\n                if (vfs[path] && vfs[path].type === 'dir') {\n                    currentDir = path;\n                    saveState();\n                } else {\n                    return `cd: ${target}: No such file or directory`;\n                }\n                return '';\n            },\n            edit: async (args) => {\n                if (args.length === 0) return 'Usage: edit <file>';\n                const path = resolvePath(args[0]);\n                const originalContent = (vfs[path] && vfs[path].type === 'file') ? vfs[path].content : '';\n                \n                term.writeln(`\\x1b[2J\\x1b[H`); // Clear screen\n                term.writeln(`Editing ${path}. Press Ctrl+S to save, Ctrl+X to exit.`);\n                term.writeln('---');\n                term.write(originalContent);\n\n                return new Promise(resolve => {\n                    let content = originalContent;\n                    let disposables = [];\n\n                    const onKey = (e) => {\n                        const printable = !e.domEvent.altKey && !e.domEvent.ctrlKey && !e.domEvent.metaKey;\n                        const event = e.domEvent;\n\n                        if (event.ctrlKey && event.key === 's') {\n                            event.preventDefault();\n                            vfs[path] = { type: 'file', content: content };\n                            const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';\n                            const fileName = path.substring(path.lastIndexOf('/') + 1);\n                            if (vfs[parentPath] && vfs[parentPath].type === 'dir' && !vfs[parentPath].content.includes(fileName)) {\n                                vfs[parentPath].content.push(fileName);\n                            }\n                            saveState();\n                            term.writeln('\\n--- Saved ---');\n                        } else if (event.ctrlKey && event.key === 'x') {\n                            event.preventDefault();\n                            disposables.forEach(d => d.dispose());\n                            term.writeln('\\n--- Exited ---');\n                            term.writeln('');\n                            resolve('');\n                        } else if (event.key === 'Enter') {\n                            content += '\\n';\n                            term.write('\\r\\n');\n                        } else if (event.key === 'Backspace') {\n                            if (content.length > 0) {\n                                content = content.slice(0, -1);\n                                term.write('\\b \\b');\n                            }\n                        } else if (printable) {\n                            content += e.key;\n                            term.write(e.key);\n                        }\n                    };\n                    disposables.push(term.onKey(onKey));\n                });\n            },\n            fetch: async (args) => {\n                if (args.length === 0) return 'Usage: fetch <url>';\n                try {\n                    const response = await fetch(args[0]);\n                    if (!response.ok) return `HTTP error! status: ${response.status}`;\n                    return await response.text();\n                } catch (error) {\n                    return `Fetch failed: ${error.message}`;\n                }\n            },\n            js: async (args) => {\n                if (args.length === 0) return 'Usage: js <file>';\n                const path = resolvePath(args[0]);\n                if (!vfs[path] || vfs[path].type !== 'file') return `js: file not found: ${args[0]}`;
                \n                const userCode = vfs[path].content;\n                let output = '';\n\n                const api = {\n                    vfs: {\n                        readFile: (filePath) => {\n                            const readPath = resolvePath(filePath);\n                            if (vfs[readPath] && vfs[readPath].type === 'file') return vfs[readPath].content;\n                            throw new Error(`File not found: ${filePath}`);\n                        },\n                        writeFile: (filePath, content) => {\n                            const writePath = resolvePath(filePath);\n                            const parentPath = writePath.substring(0, writePath.lastIndexOf('/')) || '/';\n                            const fileName = writePath.substring(writePath.lastIndexOf('/') + 1);\n                            if (vfs[parentPath] && vfs[parentPath].type === 'dir') {\n                                vfs[writePath] = { type: 'file', content: String(content) };\n                                if (!vfs[parentPath].content.includes(fileName)) {\n                                    vfs[parentPath].content.push(fileName);\n                                }\n                                saveState();\n                                return `File written: ${filePath}`;
                            }\n                            throw new Error(`Directory not found for path: ${filePath}`);\n                        }\n                    },\n                    env: {\n                        get: (key) => env[key],\n                        set: (key, value) => { env[key] = value; saveState(); return `Set ${key}=${value}`; }\n                    },\n                    log: (...args) => {\n                        output += args.map(String).join(' ') + '\\n';\n                    }\n                };\n\n                try {\n                    const sandboxedFunc = new Function('api', userCode);\n                    sandboxedFunc(api);\n                    return output.trim();\n                } catch (e) {\n                    return `Execution error: ${e.message}`;
                }\n            },\n            export: async (args) => {\n                if (args.length === 0) return 'Usage: export KEY=VALUE';\n                const [key, value] = args[0].split('=');\n                if (key && value) {\n                    env[key] = value;\n                    saveState();\n                } else {\n                    return 'Invalid format. Use KEY=VALUE.';\n                }\n                return '';\n            },\n            unset: async (args) => {\n                if (args.length === 0) return 'Usage: unset KEY';\n                if (defaultEnv.hasOwnProperty(args[0])) return `unset: cannot unset readonly variable: ${args[0]}`;
                delete env[args[0]];\n                saveState();\n                return '';\n            },\n            env: async () => {\n                return Object.entries(env).map(([key, value]) => `${key}=${value}`).join('\\n');\n            }\n        };\n\n        function prompt() {\n            const ps1 = env.PS1 || '$ ';\n            const promptStr = ps1.replace('\\\\w', currentDir);\n            term.write(`\\r\\n${promptStr}`);\n        }\n\n        term.onKey(async (e) => {\n            const ev = e.domEvent;\n            const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey;\n\n            switch (ev.key) {\n                case 'Enter':\n                    if (currentCommand.trim().length > 0) {\n                        term.writeln('');\n                        await executeCommand(currentCommand);\n                    }\n                    prompt();\n                    currentCommand = '';\n                    break;\n                case 'Backspace':\n                    if (currentCommand.length > 0) {\n                        term.write('\\b \\b');\n                        currentCommand = currentCommand.slice(0, -1);\n                    }\n                    break;\n                case 'ArrowUp':\n                    if (historyIndex > 0) {\n                        historyIndex--;\n                        term.write('\\x1b[2K\\r' + (env.PS1 || '$ ').replace('\\\\w', currentDir) + history[historyIndex]);\n                        currentCommand = history[historyIndex];\n                    }\n                    break;\n                case 'ArrowDown':\n                    if (historyIndex < history.length - 1) {\n                        historyIndex++;\n                        term.write('\\x1b[2K\\r' + (env.PS1 || '$ ').replace('\\\\w', currentDir) + history[historyIndex]);\n                        currentCommand = history[historyIndex];\n                    } else {\n                        historyIndex = history.length;\n                        term.write('\\x1b[2K\\r' + (env.PS1 || '$ ').replace('\\\\w', currentDir));\n                        currentCommand = '';\n                    }\n                    break;\n                case 'Tab':\n                    ev.preventDefault();\n                    const parts = currentCommand.split(' ');\n                    const toComplete = parts.pop();\n                    const dirContent = vfs[currentDir].content;\n                    const matches = dirContent.filter(item => item.startsWith(toComplete));\n                    if (matches.length === 1) {\n                        const completion = matches[0].slice(toComplete.length);\n                        term.write(completion);\n                        currentCommand += completion;\n                    }\n                    break;\n                default:\n                    if (printable) {\n                        term.write(e.key);\n                        currentCommand += e.key;\n                    }\n            }\n        });\n\n        async function runStartupScript() {\n            const rcPath = resolvePath((env['HOME'] || '/home/user') + '/.axunrc');\n            if (vfs[rcPath] && vfs[rcPath].type === 'file') {\n                const content = vfs[rcPath].content;\n                const commandsToRun = content.split('\\n');\n                term.writeln('Executing startup script: ~/.axunrc');\n                for (const command of commandsToRun) {\n                    const trimmedCommand = command.trim();\n                    if (trimmedCommand && !trimmedCommand.startsWith('#')) {\n                        await executeCommand(trimmedCommand, false); // Execute but don't add to history\n                    }\n                }\n            }\n        }\n\n        async function main() {\n            figlet.parseFont('Standard', await (await fetch('https://cdn.jsdelivr.net/npm/figlet/fonts/Standard.flf')).text());\n            const banner = figlet.textSync('Lorel Axun', { font: 'Standard' });\n            term.writeln(banner);\n            term.writeln('Welcome to Lorel Axun OS. Type \'help\' for a list of commands.');\n            \n            loadState();\n            await runStartupScript();\n            prompt();\n        }\n\n        main();\n    </script>\n</body>\n</html>