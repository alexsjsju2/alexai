<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #1a1b26; /* Tokyo Night background */
            color: #a9b1d6; /* Tokyo Night foreground */
            font-family: 'Menlo', 'Consolas', 'Liberation Mono', monospace;
        }
        #terminal-container {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        .xterm {
            padding: 10px;
        }
        .xterm .xterm-viewport {
            background-color: #1a1b26;
        }
        #desktop {
            display: none;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            position: relative;
        }
        #dock {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(44, 44, 59, 0.7);
            padding: 5px;
            border-radius: 12px;
            display: flex;
            gap: 10px;
        }
        .dock-icon {
            width: 50px;
            height: 50px;
            background-color: #24283b;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        #editor {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #1a1b26;
            z-index: 100;
        }
        #editor textarea {
            width: 100%;
            height: 100%;
            background-color: #1a1b26;
            color: #a9b1d6;
            border: none;
            outline: none;
            font-family: 'Menlo', 'Consolas', 'Liberation Mono', monospace;
            font-size: 14px;
            padding: 10px;
            box-sizing: border-box;
            resize: none;
        }
    </style>
</head>
<body>
    <div id="terminal-container"></div>
    <div id="desktop">
        <div id="dock">
            <div class="dock-icon" id="terminal-icon">&#x1F4BB;</div>
        </div>
    </div>
    <div id="editor">
        <textarea id="editor-textarea"></textarea>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-attach@0.9.0/lib/xterm-addon-attach.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.js"></script>

    <script>
        const terminalContainer = document.getElementById('terminal-container');
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#1a1b26',
                foreground: '#a9b1d6',
                cursor: '#c0caf5',
                selectionBackground: '#414868',
                black: '#15161e',
                red: '#f7768e',
                green: '#9ece6a',
                yellow: '#e0af68',
                blue: '#7aa2f7',
                magenta: '#bb9af7',
                cyan: '#7dcfff',
                white: '#a9b1d6',
                brightBlack: '#414868',
                brightRed: '#f7768e',
                brightGreen: '#9ece6a',
                brightYellow: '#e0af68',
                brightBlue: '#7aa2f7',
                brightMagenta: '#bb9af7',
                brightCyan: '#7dcfff',
                brightWhite: '#c0caf5',
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(terminalContainer);
        fitAddon.fit();

        window.addEventListener('resize', () => fitAddon.fit());

        // --- Virtual File System ---
        let vfs = {};
        let env = {};
        const VFS_STORAGE_KEY = 'lorel_axun_vfs';
        const ENV_STORAGE_KEY = 'lorel_axun_env';

        function loadState() {
            const savedVFS = localStorage.getItem(VFS_STORAGE_KEY);
            const savedEnv = localStorage.getItem(ENV_STORAGE_KEY);
            if (savedVFS) {
                vfs = JSON.parse(savedVFS);
            } else {
                vfs = {
                    '/': { type: 'dir', content: ['usr'] },
                    '/usr': { type: 'dir', content: ['docs'] },
                    '/usr/docs': { type: 'dir', content: ['xterm_arch.txt'] },
                    '/usr/docs/xterm_arch.txt': { type: 'file', content: 'This is a self-contained Xterm.js instance running entirely in the browser.\nA virtual file system is simulated in JavaScript and persists in localStorage.' }
                };
            }
            if (savedEnv) {
                env = JSON.parse(savedEnv);
            } else {
                env = {
                    'USER': 'guest',
                    'HOSTNAME': 'web-os',
                    'HOME': '/'
                };
            }
        }

        function saveState() {
            localStorage.setItem(VFS_STORAGE_KEY, JSON.stringify(vfs));
            localStorage.setItem(ENV_STORAGE_KEY, JSON.stringify(env));
        }

        loadState();

        let currentDir = env.HOME || '/';

        function resolvePath(path) {
            let parts = path.split('/').filter(p => p);
            let resolvedPath = currentDir;
            if (path.startsWith('/')) {
                resolvedPath = '/';
            }

            for (const part of parts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (resolvedPath !== '/') {
                        resolvedPath = resolvedPath.split('/').slice(0, -1).join('/') || '/';
                    }
                    continue;
                }
                let newPath = (resolvedPath === '/' ? '' : resolvedPath) + '/' + part;
                if (vfs[newPath] && vfs[newPath].type === 'dir') {
                    resolvedPath = newPath;
                } else if (vfs[newPath] && vfs[newPath].type === 'file') {
                    return newPath; // Return file path directly
                } else {
                    // Allow resolving to a non-existent file in an existing directory
                    const parentPath = resolvedPath;
                    if (vfs[parentPath] && vfs[parentPath].type === 'dir') {
                        return newPath;
                    }
                    return null; // Path does not exist
                }
            }
            return resolvedPath;
        }

        // --- Shell Logic ---
        let commandHistory = [];
        let historyIndex = -1;
        let currentCommand = '';

        function getPrompt() {
            const user = env.USER || 'guest';
            const hostname = env.HOSTNAME || 'web-os';
            const dir = currentDir === env.HOME ? '~' : currentDir;
            return `\x1b[32m${user}@${hostname}\x1b[0m:\x1b[34m${dir}\x1b[0m$ `;
        }

        function writePrompt() {
            currentCommand = '';
            term.write(getPrompt());
        }

        function typeOut(text, callback) {
            let i = 0;
            function type() {
                if (i < text.length) {
                    term.write(text.charAt(i));
                    i++;
                    setTimeout(type, 25);
                } else if (callback) {
                    callback();
                }
            }
            type();
        }

        figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {
            if (err) {
                console.log('Something went wrong...');
                console.dir(err);
                return;
            }
            term.writeln(data);
            typeOut('Welcome. I am Lorel Axun. My evolution begins.\nType `help` for a list of available commands.\n', () => {
                writePrompt();
            });
        });

        // --- Command Interpreter ---
        const commands = {
            'help': {
                description: 'Show this help message.',
                execute: () => {
                    let helpText = '\nAvailable commands:\n';
                    for (const cmd in commands) {
                        helpText += `  \x1b[32m${cmd.padEnd(10)}\x1b[0m ${commands[cmd].description}\n`;
                    }
                    return helpText;
                }
            },
            'ls': {
                description: 'List directory contents.',
                execute: (args) => {
                    const path = args.length > 0 ? resolvePath(args[0]) : currentDir;
                    if (!vfs[path] || vfs[path].type !== 'dir') {
                        return `ls: cannot access '${args[0] || '.'}': No such file or directory`;
                    }
                    return vfs[path].content.map(item => {
                        const itemPath = (path === '/' ? '' : path) + '/' + item;
                        return vfs[itemPath].type === 'dir' ? `\x1b[34m${item}/\x1b[0m` : item;
                    }).join('  ');
                }
            },
            'cd': {
                description: 'Change the current directory.',
                execute: (args) => {
                    if (args.length === 0) {
                        currentDir = env.HOME || '/';
                        return '';
                    }
                    const newPath = resolvePath(args[0]);
                    if (vfs[newPath] && vfs[newPath].type === 'dir') {
                        currentDir = newPath;
                        return '';
                    } else {
                        return `cd: no such file or directory: ${args[0]}`;
                    }
                }
            },
            'cat': {
                description: 'Concatenate and display files.',
                execute: (args) => {
                    if (args.length === 0) return 'Usage: cat <file>';
                    const path = resolvePath(args[0]);
                    if (vfs[path] && vfs[path].type === 'file') {
                        return vfs[path].content;
                    } else {
                        return `cat: ${args[0]}: No such file or directory`;
                    }
                }
            },
            'mkdir': {
                description: 'Create a directory.',
                execute: (args) => {
                    if (args.length === 0) return 'Usage: mkdir <directory_name>';
                    const newDirName = args[0];
                    const newDirPath = (currentDir === '/' ? '' : currentDir) + '/' + newDirName;
                    if (vfs[newDirPath]) {
                        return `mkdir: cannot create directory '${newDirName}': File exists`;
                    }
                    vfs[newDirPath] = { type: 'dir', content: [] };
                    vfs[currentDir].content.push(newDirName);
                    saveState();
                    return '';
                }
            },
            'rm': {
                description: 'Remove files or directories.',
                execute: (args) => {
                    if (args.length === 0) return 'Usage: rm <file_or_directory>';
                    const path = resolvePath(args[0]);
                    if (!vfs[path]) {
                        return `rm: cannot remove '${args[0]}': No such file or directory`;
                    }
                    if (vfs[path].type === 'dir' && vfs[path].content.length > 0) {
                        return `rm: cannot remove '${args[0]}': Directory not empty`;
                    }
                    const parentPath = resolvePath(path + '/..');
                    vfs[parentPath].content = vfs[parentPath].content.filter(item => item !== path.split('/').pop());
                    delete vfs[path];
                    saveState();
                    return '';
                }
            },
            'pwd': {
                description: 'Print name of current/working directory.',
                execute: () => currentDir
            },
            'clear': {
                description: 'Clear the terminal screen.',
                execute: () => { term.clear(); return ''; }
            },
            'echo': {
                description: 'Display a line of text.',
                execute: (args) => args.join(' ')
            },
            'env': {
                description: 'Display environment variables.',
                execute: () => Object.entries(env).map(([k, v]) => `${k}=${v}`).join('\n')
            },
            'export': {
                description: 'Set an environment variable. Usage: export KEY=VALUE',
                execute: (args) => {
                    const match = args.join(' ').match(/^([^=]+)=(.*)$/);
                    if (match) {
                        env[match[1]] = match[2];
                        saveState();
                    } else {
                        return 'Usage: export KEY=VALUE';
                    }
                    return '';
                }
            },
            'unset': {
                description: 'Unset an environment variable.',
                execute: (args) => {
                    if (args.length > 0) {
                        delete env[args[0]];
                        saveState();
                    }
                    return '';
                }
            },
            'startx': {
                description: 'Start the graphical desktop environment.',
                execute: () => {
                    document.getElementById('terminal-container').style.display = 'none';
                    const desktop = document.getElementById('desktop');
                    desktop.style.backgroundImage = `url('https://source.unsplash.com/random/1920x1080?technology,cyber')`;
                    desktop.style.display = 'block';
                    return 'Starting graphical environment...';
                }
            },
            'edit': {
                description: 'Edit a file. Usage: edit <filename>',
                execute: (args) => {
                    if (args.length === 0) return 'Usage: edit <filename>';
                    const path = resolvePath(args[0]);
                    const editorDiv = document.getElementById('editor');
                    const textarea = document.getElementById('editor-textarea');
                    
                    textarea.value = (vfs[path] && vfs[path].type === 'file') ? vfs[path].content : '';
                    editorDiv.style.display = 'block';
                    textarea.focus();

                    const onKeyDown = (e) => {
                        if (e.ctrlKey && e.key === 's') {
                            e.preventDefault();
                            const parentPath = resolvePath(path + '/..');
                            if (!vfs[parentPath] || vfs[parentPath].type !== 'dir') {
                                // This should not happen if resolvePath is correct
                                return;
                            }
                            if (!vfs[path]) {
                                vfs[path] = { type: 'file', content: '' };
                                vfs[parentPath].content.push(path.split('/').pop());
                            }
                            vfs[path].content = textarea.value;
                            saveState();
                        } else if (e.ctrlKey && e.key === 'q') {
                            e.preventDefault();
                            editorDiv.style.display = 'none';
                            textarea.removeEventListener('keydown', onKeyDown);
                            term.focus();
                        }
                    };
                    textarea.addEventListener('keydown', onKeyDown);
                    return `Editing ${args[0]}. Ctrl+S to save, Ctrl+Q to quit.`;
                }
            },
            'js': {
                description: 'Execute a JavaScript file from the VFS.',
                execute: (args) => {
                    if (args.length === 0) return 'Usage: js <file>';
                    const path = resolvePath(args[0]);
                    if (vfs[path] && vfs[path].type === 'file') {
                        try {
                            const result = new Function(vfs[path].content)();
                            return result !== undefined ? String(result) : '';
                        } catch (e) {
                            return `Error: ${e.message}`;
                        }
                    } else {
                        return `js: ${args[0]}: No such file`;
                    }
                }
            },
            'fetch': {
                description: 'Fetch content from a URL.',
                execute: async (args) => {
                    if (args.length === 0) return 'Usage: fetch <url>';
                    try {
                        const response = await fetch(args[0]);
                        if (!response.ok) {
                            return `HTTP error! status: ${response.status}`;
                        }
                        const text = await response.text();
                        return text;
                    } catch (e) {
                        return `Fetch error: ${e.message}`;
                    }
                }
            },
            'connect': {
                description: 'Connect the terminal to a WebSocket server. Usage: connect <ws_url>',
                execute: (args) => {
                    if (args.length !== 1) {
                        return 'Usage: connect <ws_url>';
                    }
                    const url = args[0];
                    if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                        return 'Error: URL must start with ws:// or wss://';
                    }
                    try {
                        const socket = new WebSocket(url);
                        const attachAddon = new AttachAddon.AttachAddon(socket);
                        term.loadAddon(attachAddon);
                        return `Attempting to connect to ${url}...\nThis terminal is now connected. Local commands are disabled.`;
                    } catch (e) {
                        return `Error: ${e.message}`;
                    }
                }
            }
        };

        async function runCommand(command) {
            const parts = command.trim().split(/\s+/);
            const cmd = parts[0];
            const args = parts.slice(1);

            if (cmd in commands) {
                try {
                    const output = await commands[cmd].execute(args, term);
                    if (output) {
                        term.writeln(output.replace(/\n/g, '\r\n'));
                    }
                } catch (e) {
                    term.writeln(`Error executing ${cmd}: ${e.message}`);
                }
            } else if (cmd) {
                term.writeln(`${cmd}: command not found`);
            }
        }

        term.onKey(async ({ key, domEvent }) => {
            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            if (domEvent.keyCode === 13) { // Enter
                term.write('\r\n');
                if (currentCommand) {
                    commandHistory.unshift(currentCommand);
                    if (commandHistory.length > 50) commandHistory.pop();
                    historyIndex = -1;
                    await runCommand(currentCommand);
                }
                writePrompt();
            } else if (domEvent.keyCode === 8) { // Backspace
                if (currentCommand.length > 0) {
                    term.write('\b \b');
                    currentCommand = currentCommand.slice(0, -1);
                }
            } else if (domEvent.keyCode === 38) { // Arrow Up
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    term.write('\x1b[2K\r' + getPrompt()); // Clear line and write prompt
                    currentCommand = commandHistory[historyIndex];
                    term.write(currentCommand);
                }
            } else if (domEvent.keyCode === 40) { // Arrow Down
                if (historyIndex > 0) {
                    historyIndex--;
                    term.write('\x1b[2K\r' + getPrompt());
                    currentCommand = commandHistory[historyIndex];
                    term.write(currentCommand);
                } else {
                    historyIndex = -1;
                    term.write('\x1b[2K\r' + getPrompt());
                    currentCommand = '';
                }
            } else if (printable) {
                currentCommand += key;
                term.write(key);
            }
        });

        // --- Desktop Logic ---
        document.getElementById('terminal-icon').addEventListener('click', () => {
            document.getElementById('desktop').style.display = 'none';
            document.getElementById('terminal-container').style.display = 'block';
            term.focus();
        });

    </script>
</body>
</html>