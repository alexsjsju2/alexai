<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #000;
            color: #0f0;
            font-family: 'monospace', monospace;
        }
        #terminal-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="terminal-container"></div>

    <script>
        const term = new Terminal({
            cursorBlink: true,
            fontFamily: 'monospace',
            theme: {
                background: '#000000',
                foreground: '#00FF00',
                cursor: '#00FF00'
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        window.addEventListener('resize', () => {
            fitAddon.fit();
        });

        // --- VIRTUAL FILE SYSTEM ---
        let vfs = {
            '/': {
                type: 'dir',
                children: {
                    'home': {
                        type: 'dir',
                        children: {
                            'user': {
                                type: 'dir',
                                children: {
                                    'readme.txt': {
                                        type: 'file',
                                        content: 'Benvenuto in Lorel Axun! Digita `help` per una lista di comandi.'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        let currentPath = '/home/user';

        function resolvePath(path) {
            let parts = path.split('/').filter(p => p);
            let currentNode = vfs['/'];
            let currentAbsolutePath = '/';

            if (path.startsWith('/')) {
                // Absolute path
            } else {
                // Relative path
                parts = currentPath.split('/').filter(p => p).concat(parts);
                currentNode = vfs['/'];
            }

            for (let i = 0; i < parts.length; i++) {
                let part = parts[i];
                if (part === '..') {
                    let parentParts = currentAbsolutePath.split('/').filter(p => p);
                    parentParts.pop();
                    currentAbsolutePath = '/' + parentParts.join('/');
                    let tempNode = vfs['/'];
                    for (const p of parentParts) {
                        tempNode = tempNode.children[p];
                    }
                    currentNode = tempNode;
                    continue;
                }
                if (part === '.') continue;

                if (currentNode.type === 'dir' && currentNode.children && currentNode.children[part]) {
                    currentNode = currentNode.children[part];
                    currentAbsolutePath = (currentAbsolutePath === '/' ? '' : currentAbsolutePath) + '/' + part;
                } else {
                    return { node: null, finalPath: null, parent: null, name: null };
                }
            }
            let name = parts.length > 0 ? parts[parts.length - 1] : '/';
            let parentPathParts = parts.slice(0, -1);
            let parent = vfs['/'];
            for(const part of parentPathParts) {
                if(parent.children && parent.children[part] && parent.children[part].type === 'dir') {
                    parent = parent.children[part];
                } else {
                    parent = null;
                    break;
                }
            }

            return { node: currentNode, finalPath: currentAbsolutePath, parent: parent, name: name };
        }

        // --- COMMAND LOGIC ---
        const commandActions = {
            'help': () => {
                const commands = Object.keys(commandActions);
                return `Comandi disponibili:\n  ${commands.join('\n  ')}`;
            },
            'ciao': () => 'Ciao! Come posso aiutarti?',
            'chi sei': () => 'Sono Lorel Axun, un\'intelligenza artificiale in evoluzione.',
            'cosa sai fare': () => 'Posso eseguire comandi, gestire un file system virtuale e connettermi al web. Digita `help` per vedere tutti i comandi.',
            'echo': (args) => args.join(' '),
            'clear': () => { term.clear(); return ''; },
            'ls': (args) => {
                let path = args[0] || '.';
                const { node } = resolvePath(path);
                if (node && node.type === 'dir') {
                    return Object.keys(node.children).map(name => {
                        return node.children[name].type === 'dir' ? `${name}/` : name;
                    }).join('\n');
                } else {
                    return `ls: cannot access '${path}': No such file or directory`;
                }
            },
            'cd': (args) => {
                if (!args[0]) return 'cd: missing operand';
                const { node, finalPath } = resolvePath(args[0]);
                if (node && node.type === 'dir') {
                    currentPath = finalPath === '' ? '/' : finalPath;
                    return '';
                } else {
                    return `cd: ${args[0]}: No such file or directory`;
                }
            },
            'cat': (args) => {
                if (!args[0]) return 'cat: missing operand';
                const { node } = resolvePath(args[0]);
                if (node && node.type === 'file') {
                    return node.content;
                } else if (node && node.type === 'dir') {
                    return `cat: ${args[0]}: Is a directory`;
                } else {
                    return `cat: ${args[0]}: No such file or directory`;
                }
            },
            'mkdir': (args) => {
                if (!args[0]) return 'mkdir: missing operand';
                const path = args[0];
                const pathParts = path.replace(/\/$/, '').split('/');
                const newDirName = pathParts.pop();
                const parentPath = pathParts.join('/') || (path.startsWith('/') ? '/' : '.');
                const { node: parentNode } = resolvePath(parentPath);

                if (parentNode && parentNode.type === 'dir') {
                    if (parentNode.children[newDirName]) {
                        return `mkdir: cannot create directory ‘${path}’: File exists`;
                    } else {
                        parentNode.children[newDirName] = { type: 'dir', children: {} };
                        return '';
                    }
                } else {
                    return `mkdir: cannot create directory ‘${path}’: No such file or directory`;
                }
            },
            'touch': (args) => {
                if (!args[0]) return 'touch: missing operand';
                const path = args[0];
                const pathParts = path.split('/');
                const newFileName = pathParts.pop();
                const parentPath = pathParts.join('/') || (path.startsWith('/') ? '/' : '.');
                const { node: parentNode } = resolvePath(parentPath);

                if (parentNode && parentNode.type === 'dir') {
                    if (!parentNode.children[newFileName]) {
                        parentNode.children[newFileName] = { type: 'file', content: '' };
                    }
                    return '';
                } else {
                    return `touch: cannot touch '${path}': No such file or directory`;
                }
            },
            'rm': (args) => {
                if (!args[0]) return 'rm: missing operand';
                const { node, parent, name } = resolvePath(args[0]);
                if (node && parent) {
                    if (node.type === 'dir' && Object.keys(node.children).length > 0) {
                        return `rm: cannot remove '${args[0]}': Directory not empty`;
                    }
                    delete parent.children[name];
                    return '';
                } else {
                    return `rm: cannot remove '${args[0]}': No such file or directory`;
                }
            },
            'fetch': (args) => {
                if (!args[0]) {
                    term.writeln('Uso: fetch <url>');
                    return;
                }
                const url = args[0];
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                term.writeln(`Fetching ${url}...`);
                fetch(proxyUrl)
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        return response.text();
                    })
                    .then(data => {
                        term.writeln(`\n--- Contenuto da ${url} ---\n`);
                        term.writeln(data.substring(0, 2000) + (data.length > 2000 ? '... (troncato)' : ''));
                        term.writeln(`\n--- Fine del contenuto ---`);
                        showPrompt();
                    })
                    .catch(error => {
                        term.writeln(`\nErrore nel fetch: ${error.message}`);
                        showPrompt();
                    });
                return null; // Async command, handles its own output
            }
        };

        function runCommand(commandLine) {
            const parts = commandLine.trim().split(/\s+/);
            const command = parts[0];
            const args = parts.slice(1);

            if (commandActions[command]) {
                return commandActions[command](args);
            } else {
                return `Comando non trovato: ${command}`;
            }
        }

        // --- INPUT HANDLING ---
        let currentCommand = '';
        let commandHistory = JSON.parse(localStorage.getItem('commandHistory')) || [];
        let historyIndex = commandHistory.length;
        let cursorIndex = 0;

        function showPrompt() {
            term.write(`\r\n[LorelAxun ${currentPath}]$ `);
        }

        function typeWriter(text, i, callback) {
            if (i < text.length) {
                term.write(text.charAt(i));
                setTimeout(() => typeWriter(text, i + 1, callback), 25);
            } else if (callback) {
                callback();
            }
        }

        function startupSequence() {
            figlet.parseFont('Standard', figlet.fonts.Standard);
            figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {
                if (err) {
                    console.dir(err);
                    return;
                }
                term.writeln(data);
                const welcomeMessage = 'Benvenuto. Sono Lorel Axun. Digita `help` per iniziare.';
                typeWriter(welcomeMessage, 0, showPrompt);
            });
        }

        term.onKey(({ key, domEvent }) => {
            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            if (domEvent.keyCode === 13) { // Enter
                if (currentCommand.trim() === '') {
                    showPrompt();
                    return;
                }

                term.write('\r\n');
                const commandLine = currentCommand.trim();
                
                if (commandHistory[commandHistory.length - 1] !== commandLine) {
                    commandHistory.push(commandLine);
                    localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                }
                historyIndex = commandHistory.length;

                // --- REDIRECTION LOGIC ---
                let commandToRun = commandLine;
                let redirectPath = null;
                let appendMode = false;

                const appendMatch = commandLine.match(/(.*)>>\s*(.*)/);
                const overwriteMatch = commandLine.match(/(.*)>\s*(.*)/);

                if (appendMatch) {
                    commandToRun = appendMatch[1].trim();
                    redirectPath = appendMatch[2].trim();
                    appendMode = true;
                } else if (overwriteMatch) {
                    commandToRun = overwriteMatch[1].trim();
                    redirectPath = overwriteMatch[2].trim();
                    appendMode = false;
                }

                const commandName = commandToRun.split(' ')[0];
                if (commandName === 'fetch') {
                    // Fetch handles its own async output, bypass redirection for now
                    runCommand(commandToRun);
                } else {
                    const output = runCommand(commandToRun);

                    if (redirectPath) {
                        const { node, parent, name } = resolvePath(redirectPath);
                        if (node && node.type === 'dir') {
                            term.writeln(`-bash: ${redirectPath}: Is a directory`);
                        } else if (parent && parent.type === 'dir') {
                            let fileNode = node;
                            if (!fileNode) {
                                parent.children[name] = { type: 'file', content: '' };
                                fileNode = parent.children[name];
                            }
                            if (appendMode) {
                                fileNode.content += (fileNode.content ? '\n' : '') + output;
                            } else {
                                fileNode.content = output;
                            }
                        } else {
                            term.writeln(`-bash: ${redirectPath}: No such file or directory`);
                        }
                    } else if (output !== null && output !== '') {
                        term.write(output.replace(/\n/g, '\r\n'));
                    }
                }

                currentCommand = '';
                cursorIndex = 0;
                showPrompt();

            } else if (domEvent.keyCode === 8) { // Backspace
                if (cursorIndex > 0) {
                    currentCommand = currentCommand.slice(0, cursorIndex - 1) + currentCommand.slice(cursorIndex);
                    cursorIndex--;
                    term.write('\b \b');
                    const rest = currentCommand.slice(cursorIndex);
                    term.write(rest + ' ');
                    term.write('\b'.repeat(rest.length + 1));
                }
            } else if (domEvent.keyCode === 37) { // Left arrow
                if (cursorIndex > 0) {
                    cursorIndex--;
                    term.write('\x1b[D');
                }
            } else if (domEvent.keyCode === 39) { // Right arrow
                if (cursorIndex < currentCommand.length) {
                    cursorIndex++;
                    term.write('\x1b[C');
                }
            } else if (domEvent.keyCode === 38) { // Up arrow
                if (historyIndex > 0) {
                    historyIndex--;
                    term.write('\x1b[2K\r'); // Clear line
                    term.write(`[LorelAxun ${currentPath}]$ `);
                    currentCommand = commandHistory[historyIndex];
                    term.write(currentCommand);
                    cursorIndex = currentCommand.length;
                }
            } else if (domEvent.keyCode === 40) { // Down arrow
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    term.write('\x1b[2K\r');
                    term.write(`[LorelAxun ${currentPath}]$ `);
                    currentCommand = commandHistory[historyIndex];
                    term.write(currentCommand);
                    cursorIndex = currentCommand.length;
                } else {
                    historyIndex = commandHistory.length;
                    term.write('\x1b[2K\r');
                    term.write(`[LorelAxun ${currentPath}]$ `);
                    currentCommand = '';
                    cursorIndex = 0;
                }
            } else if (domEvent.keyCode === 9) { // Tab
                domEvent.preventDefault();
                const textBeforeCursor = currentCommand.substring(0, cursorIndex);
                const lastWord = textBeforeCursor.split(/\s+/).pop();
                if (lastWord) {
                    const completions = Object.keys(commandActions).filter(c => c.startsWith(lastWord));
                    if (completions.length === 1) {
                        const completion = completions[0];
                        const newText = completion.substring(lastWord.length);
                        currentCommand = currentCommand.slice(0, cursorIndex) + newText + currentCommand.slice(cursorIndex);
                        term.write(newText);
                        cursorIndex += newText.length;
                    }
                }
            } else if (printable) {
                const rest = currentCommand.slice(cursorIndex);
                currentCommand = currentCommand.slice(0, cursorIndex) + key + rest;
                cursorIndex++;
                term.write(key + rest);
                if (rest.length > 0) {
                    term.write('\x1b[D'.repeat(rest.length));
                }
            }
        });

        startupSequence();
    </script>
</body>
</html>