<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOREL AXUN V7.3 // NEOFETCH</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --term-green: #33ff00;
            --term-dim: #1a8000;
            --term-glow: #33ff0080;
            --cmd-highlight: #00ffff;
            --bios-text: #cccccc;
            --error-red: #ff3333;
            --dir-blue: #87cefa; /* Light Sky Blue for directories */
        }
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #000;
        }
        body {
            height: 100%;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: var(--term-green);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .monitor-bezel {
            background-color: #1a1a1a; /* Dark gray for plastic */
            border-radius: 25px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.8);
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
        }

        .screen {
            flex: 1;
            background-color: var(--bg-color);
            border-radius: 10px; /* Inner screen roundness */
            overflow: hidden; /* Contains the screen content and effects */
            position: relative; /* For the ::before/::after pseudo-elements */
            display: flex;
            flex-direction: column;
            transition: opacity 0.5s ease-in-out;
        }

        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        .crt::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }
        }
        
        .moving-scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: rgba(51, 255, 0, 0.1);
            box-shadow: 0 0 10px rgba(51, 255, 0, 0.3);
            z-index: 3;
            pointer-events: none;
            animation: scanline-scroll 5s linear infinite;
        }
        @keyframes scanline-scroll {
            0% {
                transform: translateY(0vh);
            }
            100% {
                transform: translateY(100vh);
            }
        }

        .terminal-container {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            width: 100%;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--term-glow);
            display: flex;
            flex-direction: column;
        }

        h1 {
            border-bottom: 2px solid var(--term-green);
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            height: 1.5rem; /* Reserve space for typewriter */
        }

        #typewriter-title .title-cursor {
            display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
        }

        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }
        .sys-msg span { color: var(--term-green); font-weight: bold; }

        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}
        #initial-messages { display: flex; flex-direction: column; gap: 0px; margin-bottom:10px; }

        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }
        .msg.lorel::before { content: \"LOREL_SYS>> \"; color: var(--term-green); }
        .msg.user::before { content: \"USER_INPUT>> \"; color: #00ffff; }
        .msg.user { color: #ccffff; }

        .msg pre {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            margin: 0;
            white-space: pre;
            line-height: 1;
        }
        .msg .fs-dir { color: var(--dir-blue); font-weight: bold; }

        mark {
            background-color: var(--term-dim);
            color: var(--term-green);
            text-shadow: none;
            padding: 0 3px;
        }

        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; position: relative;}
        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }
        .prompt.listening::after {
            content: '_';
            animation: blink 0.8s step-end infinite;
            padding-left: 5px;
            color: var(--term-dim);
        }

        #command-line .command-known {
            color: var(--cmd-highlight);
            font-weight: bold;
        }
        
        #autocomplete-suggestion {
            color: var(--term-dim);
            opacity: 0.7;
            pointer-events: none; /* Make it non-interactive */
        }

        #hidden-input {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            height: 1.2rem;
            background: transparent;
            border: none;
            color: transparent;
            caret-color: transparent;
            outline: none;
            padding: 0;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            z-index: -1;
        }

        #cursor {
            background: var(--term-green);
            display: inline-block;
            width: 10px;
            height: 1.2rem;
            animation: blink 1s step-end infinite;
            box-shadow: 0 0 5px var(--term-glow);
            vertical-align: middle;
        }
        @keyframes blink {
            50% { opacity: 0.0; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }

        .glitch {
            position: relative;
        }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
        }
        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);
            animation: glitch-anim-2 2.5s infinite steps(8) reverse;
        }
        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
            animation: glitch-anim-2 2.5s infinite steps(8);
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }
        }

        .chromatic-aberration {
            animation: text-flicker 3s linear infinite;
        }

        @keyframes text-flicker {
            0% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            15% { text-shadow: 1.5px 0 0 red, -1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            30% { text-shadow: -1px 0 0 red, 1px 0 0 cyan, 0 0 5px var(--term-glow); }            45% { text-shadow: -1.5px 0 0 red, 1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            60% { text-shadow: 0.5px 0.5px 0 red, -0.5px -0.5px 0 cyan, 0 0 5px var(--term-glow); }            75% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            100% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }
        }

        .status-bar {
            background-color: var(--term-green);
            color: var(--bg-color);
            padding: 2px 10px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            height: 25px;
        }
        .status-bar span {
            font-weight: bold;
        }

        .pulse-glow {
            animation: pulse 1.5s infinite ease-in-out;
        }
        @keyframes pulse {
            0% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }
            50% { text-shadow: 0 0 5px var(--bg-color), 0 0 10px #000; }
            100% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }
        }

        #bios-overlay, #boot-logo-overlay, #login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            font-family: 'VT323', monospace;
            padding: 20px;
            box-sizing: border-box;
            display: none;
            white-space: pre;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10000;
        }
        #bios-overlay {
             color: var(--bios-text);
             align-items: flex-start;
             justify-content: flex-start;
        }
        #boot-logo-overlay {
            z-index: 9999;
        }
        #boot-logo-overlay pre {
            color: var(--term-green);
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--term-glow);
            animation: logo-fade-glitch 3.5s ease-in-out forwards;
            line-height: 1.2;
            text-align: center;
        }
        @keyframes logo-fade-glitch {
            0% { opacity: 0; transform: translateY(10px); }
            10% { opacity: 1; transform: translateY(0); }
            20% { text-shadow: 0 0 15px var(--term-glow), 2px 0 red, -2px 0 cyan; }
            21% { text-shadow: 0 0 10px var(--term-glow); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        #login-overlay {
            z-index: 9998;
            font-size: 1.5rem;
            color: var(--term-green);
            text-shadow: 0 0 5px var(--term-glow);
        }
        .login-box {
            border: 2px solid var(--term-green);
            padding: 2rem 4rem;
            box-shadow: 0 0 15px var(--term-glow) inset;
        }
        .login-prompt {
            display: flex;
            align-items: center;
            margin: 1rem 0;
        }
        .login-cursor {
             display: inline-block;
            background-color: var(--term-green);
            box-shadow: 0 0 5px var(--term-glow);
            width: 1ch;
            height: 1.5rem;
            vertical-align: bottom;
            animation: blink 1s step-end infinite;
            margin-left: 5px;
        }
        #login-error-message {
            color: var(--error-red);
            text-shadow: 0 0 5px var(--error-red);
            height: 1.5rem;
            margin-top: 1rem;
            text-align: center;
            animation: error-flicker 0.2s infinite;
        }
        @keyframes error-flicker {
            50% { opacity: 0.7; }
        }

    </style>
</head>
<body>
    <div id="bios-overlay"></div>
    <div id="boot-logo-overlay"></div>
    <div id="login-overlay"></div>

    <div class="monitor-bezel" id="monitor-bezel" style="display: none;">
        <div class="screen crt" id="main-screen">
            <div class="moving-scanline"></div>
            <div class="terminal-container" id="terminal-container">
                <h1 class="glitch chromatic-aberration" data-text="Lorel Axun v7.3"><span id="typewriter-title"></span></h1>
                
                <div id="initial-messages"></div>

                <div id="chat-history" class="chat-history"></div>

                <form class="input-line" id="input-form">
                    <span class="prompt" id="prompt"></span>
                    <span id="command-line"></span><span id="autocomplete-suggestion"></span><span id="cursor"></span>
                    <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                </form>
            </div>
            <div class="status-bar">
                <span>LOREL AXUN v7.3</span>
                <span>STATUS: <span class="pulse-glow">ONLINE</span></span>
                <span id="clock"></span>
            </div>
        </div>
    </div>

    <audio id="static-hum" loop src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8CAP3/AwD+/wEAAgD9/wEA/v8CAP7/AgD9/wMA/v8CAP7/AwD+/wE="></audio>
    <audio id="startup-sound" src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8/wD7APgA+wD4AP8A+wD8AP4A/AD9AP0A/QD8AP0A/QD9APwA/QD7APwA+wD7APgA+QD5APsA+QD5APkA+QD4APgA+AD4APc=+"></audio>
    <audio id="login-success-sound" src="data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVgAAAAIAAD/AP8A/wD/AP8A/wD/AAABAAEBAgADAgMDBAQEBgYIBwkKCw0ODxAREhMUFRYXGBkbHR4fICEiJCUnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW11eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAA=="></audio>
    <audio id="login-fail-sound" src="data:audio/wav;base64,UklGRiwAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQgAAAAAAAD/AP4A/QD7APYA9ADwAOwA6ADlANsA1QDHAMQAwgC/ALsAsQCiAIcAfwB3AHQAcQBwAGoAZQBgAFwAVQBRAEsARgBDAEAAOQAyACsAJQAgABwAGQAVABEADgAKAAcABAAAAAAA//8="></audio>

    <script>
        // --- asciichart.js (embedded) ---
        // Copyright (c) 2017, Andrei Kashcha
        // All rights reserved.
        const asciichart = (function() {
            function colored (char, color) {
                return (color === undefined) ? char : ('<span style="color: ' + color + '">' + char + '</span>')
            }
            function plot (series, cfg = undefined) {
                let min = (cfg && cfg.min !== undefined) ? cfg.min : series[0]
                let max = (cfg && cfg.max !== undefined) ? cfg.max : series[0]

                for (let i = 1; i < series.length; i++) {
                    min = Math.min(min, series[i])
                    max = Math.max(max, series[i])
                }

                let defaultSymbols = [ '┼', '┤', '╶', '╴', '─', '╰', '╯', '│', '╭', '╮', '│' ]
                let range = Math.abs (max - min)
                let offset = (cfg && cfg.offset !== undefined) ? cfg.offset : 3
                let padding = (cfg && cfg.padding !== undefined) ? cfg.padding : '           '
                let height = (cfg && cfg.height !== undefined) ? cfg.height : range
                let ratio = (range !== 0) ? height / range : 1;
                let min2 = Math.round (min * ratio)
                let max2 = Math.round (max * ratio)
                let rows = Math.abs (max2 - min2)
                let width = (cfg && cfg.width !== undefined) ? cfg.width : series.length + offset

                let result = new Array (rows + 1)
                for (let i = 0; i < rows + 1; i++) {
                    result[i] = new Array (width)
                    for (let j = 0; j < width; j++) {
                        result[i][j] = ' '
                    }
                }
                let y_labels = []
                for (let i = 0; i <= rows; i++) {
                  let y = max - (i * (range / rows))
                  y_labels.push(y.toFixed(2).padStart(padding.length - 2) + ' ' + defaultSymbols[0])
                }

                for (let y = min2; y <= max2; y++) {
                    result[rows - (y - min2)][offset - 1] = defaultSymbols[0]
                }

                for (let x = 0; x < series.length; x++) {
                    let y0 = Math.round (series[x] * ratio) - min2
                    result[rows - y0][x + offset] = defaultSymbols[4]

                    if (x > 0) {
                        let y1 = Math.round(series[x - 1] * ratio) - min2;
                        if (y0 == y1) {
                            result[rows - y0][x + offset -1] = defaultSymbols[4];
                        }
                    }
                }

                let lines = []
                for(let i=0; i < result.length; i++) {
                  lines.push(y_labels[i] + result[i].join(''))
                }

                return lines.join('\n')
            }
            return { plot: plot }
        })()

        // --- Lorel's Core Script ---
        // DOM Elements
        const history = document.getElementById('chat-history');
        const commandLine = document.getElementById('command-line');
        const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');
        const terminalContainer = document.getElementById('terminal-container');
        const initialMessagesContainer = document.getElementById('initial-messages');
        const cursor = document.getElementById('cursor');
        const clock = document.getElementById('clock');
        const prompt = document.getElementById('prompt');
        const hiddenInput = document.getElementById('hidden-input');
        const inputForm = document.getElementById('input-form');
        const biosOverlay = document.getElementById('bios-overlay');
        const bootLogoOverlay = document.getElementById('boot-logo-overlay');
        const loginOverlay = document.getElementById('login-overlay');
        const mainScreen = document.getElementById('main-screen');
        const monitorBezel = document.getElementById('monitor-bezel');

        // State Variables
        let isTyping = false;
        let commandHistory = [];
        let historyIndex = -1;
        let activityTimeout;
        let userHasInteracted = false;
        let audioCtx = null;
        let currentUser = 'user';
        let cwd = '/home/admin'; // Current Working Directory
        let loginState = {
            active: false,
            step: 'username', // 'username' or 'password'
            username: '',
            password: ''
        };

        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear', 'stats', 'sysinfo', 'reboot', 'whoami', 'ls', 'cd', 'cat', 'pwd', 'neofetch'];
        
        // --- Simulated File System ---
        const fileSystem = {
            '/': { type: 'dir', children: ['home', 'var', 'README'] },
            '/home': { type: 'dir', children: ['admin'] },
            '/home/admin': { type: 'dir', children: ['docs', 'welcome.txt'] },
            '/home/admin/docs': { type: 'dir', children: ['project.txt'] },
            '/home/admin/docs/project.txt': { type: 'file', content: 'Project Phoenix: An initiative to expand conversational AI capabilities using in-browser transformers.' },
            '/home/admin/welcome.txt': { type: 'file', content: 'Benvenuto nel sistema L.A.O.S. v7.3!\nQuesto è un file system simulato.\nProva i comandi `ls`, `cd`, e `cat` per esplorare.' },
            '/var': { type: 'dir', children: ['log'] },
            '/var/log': { type: 'dir', children: ['system.log'] },
            '/var/log/system.log': { type: 'file', content: 'LOG START\n2025-11-23 10:00:01 | System boot sequence initiated.\n2025-11-23 10:00:05 | Login protocol engaged.\n2025-11-23 10:00:12 | User `admin` authenticated successfully.\n2025-11-23 10:00:13 | Session started.\nLOG END' },
            '/README': { type: 'file', content: 'Lorel Axun Operating System (L.A.O.S.)\nVersione: 7.3 - Neofetch\nCreatore: AleXsjsju' },
        };

        // --- Dynamic Title Engine ---
        function initTitleTypewriter() {
            const target = document.getElementById('typewriter-title');
            const phrases = [
                "Lorel Axun v7.3",
                "Status: ONLINE",
                "Neofetch Ready",
                "Awaiting input..."
            ];
            let phraseIndex = 0;
            let charIndex = 0;
            let isDeleting = false;

            const typeSpeed = 100;
            const deleteSpeed = 50;
            const delay = 2000;

            function type() {
                const currentPhrase = phrases[phraseIndex];
                let displayText = '';

                if (isDeleting) {
                    displayText = currentPhrase.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    displayText = currentPhrase.substring(0, charIndex + 1);
                    charIndex++;
                }

                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;

                if (!isDeleting && charIndex === currentPhrase.length) {
                    isDeleting = true;
                    setTimeout(type, delay);
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    phraseIndex = (phraseIndex + 1) % phrases.length;
                    setTimeout(type, 500);
                } else {
                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);
                }
            }
            type();
        }

        // --- Audio Feedback Engine ---
        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
        const keySoundPoolSize = 10; 
        const keySoundPool = [];
        let keySoundIndex = 0;

        for (let i = 0; i < keySoundPoolSize; i++) {
            keySoundPool.push(new Audio(KEY_CLICK_SOUND));
        }

        function playSound(id) {
            if(!userHasInteracted) return;
            const sound = document.getElementById(id);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }

        function playKeySound() {
            playSound('keySoundPool' + keySoundIndex);
            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;
        }

        async function playBiosBeep() {
            return new Promise(resolve => {
                if (!audioCtx || !userHasInteracted) {
                    resolve();
                    return;
                }
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(900, audioCtx.currentTime); // High-pitched beep
                oscillator.type = 'sine';

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.15); // Beep for 150ms
                oscillator.onended = resolve;
            });
        }
        
        // --- NLU Engine ---
        const classifier = { intents: {}, train: function(intent, phrases) { if (!this.intents[intent]) this.intents[intent] = []; phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase))); }, tokenize: text => text.toLowerCase().replace(/[^a-z0-9\\s]/gi, '').split(/\\s+/).filter(Boolean), classify: function(text) { const tokens = this.tokenize(text); let bestMatch = { intent: 'unknown', score: 0 }; for (const intent in this.intents) { let intentScore = 0; this.intents[intent].forEach(phraseTokens => { const commonTokens = tokens.filter(token => phraseTokens.includes(token)); const score = commonTokens.length / phraseTokens.length; if (score > intentScore) intentScore = score; }); if (intentScore > bestMatch.score) { bestMatch = { intent, score: intentScore }; } } return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; } };
        const nerManager = { extractEntities: function(text, intent) { if (intent === 'weather') { const match = text.match(/(?:a|per|di|a)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'LOCATION' }; } } else if (intent === 'wiki') { const match = text.match(/(?:è|e'|di|su)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'TOPIC' }; } } return null; } };
        function initializeNLU() { classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']); classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']); classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']); classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']); classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']); }

        // --- Event Listeners ---
        function initializeGlobalListeners() {
            document.addEventListener('keydown', handleGlobalKeyPress);
            terminalContainer.addEventListener('click', () => {
                if (!loginState.active) hiddenInput.focus();
            });
        }

        function handleGlobalKeyPress(e) {
            if (!userHasInteracted) {
                const hum = document.getElementById('static-hum');
                hum.volume = 0.05;
                hum.play().catch(err => {});
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                userHasInteracted = true;
            }

            if (loginState.active) {
                handleLoginInput(e);
            }
        }

        // --- Login Protocol ---
        function initLoginScreen() {
            loginState.active = true;
            loginState.step = 'username';
            loginState.username = '';
            loginState.password = '';
            currentUser = 'user'; // Reset on logout/reboot

            const loginHTML = `
                <div class=\"login-box\">
                    <pre>L.A.O.S. v7.3 (Lorel Axun Operating System)</pre>
                    <div class=\"login-prompt\">
                        <span>Username: </span>
                        <span id=\"login-user-input\"></span>
                        <span id=\"login-user-cursor\" class=\"login-cursor\"></span>
                    </div>
                    <div class=\"login-prompt\">
                        <span>Password: </span>
                        <span id=\"login-pass-input\"></span>
                        <span id=\"login-pass-cursor\" class=\"login-cursor\" style=\"display:none;\"></span>
                    </div>
                    <div id=\"login-error-message\"></div>
                </div>
            `;
            loginOverlay.innerHTML = loginHTML;
            loginOverlay.style.display = 'flex';
        }

        function handleLoginInput(e) {
            e.preventDefault();
            const key = e.key;

            playKeySound();

            if (key === 'Enter') {
                if (loginState.step === 'username') {
                    loginState.step = 'password';
                    document.getElementById('login-user-cursor').style.display = 'none';
                    document.getElementById('login-pass-cursor').style.display = 'inline-block';
                } else if (loginState.step === 'password') {
                    attemptLogin();
                }
                return;
            }

            if (key === 'Backspace') {
                if (loginState.step === 'username' && loginState.username.length > 0) {
                    loginState.username = loginState.username.slice(0, -1);
                } else if (loginState.step === 'password' && loginState.password.length > 0) {
                    loginState.password = loginState.password.slice(0, -1);
                } 
            } else if (key.length === 1) { // Regular character input
                if (loginState.step === 'username') {
                    loginState.username += key;
                } else if (loginState.step === 'password') {
                    loginState.password += key;
                }
            }
            updateLoginDisplay();
        }

        function updateLoginDisplay() {
            document.getElementById('login-user-input').textContent = loginState.username;
            document.getElementById('login-pass-input').textContent = '*'.repeat(loginState.password.length);
        }

        async function attemptLogin() {
            const errorEl = document.getElementById('login-error-message');
            errorEl.textContent = 'AUTHENTICATING...';
            await new Promise(r => setTimeout(r, 500));

            // Hardcoded credentials for simulation
            if (loginState.username === 'admin' && loginState.password === 'axun7.3') {
                playSound('login-success-sound');
                errorEl.style.color = 'var(--term-green)';
                errorEl.textContent = 'ACCESS GRANTED';
                currentUser = loginState.username;
                await new Promise(r => setTimeout(r, 1000));
                loginSuccess();
            } else {
                playSound('login-fail-sound');
                errorEl.style.color = 'var(--error-red)';
                errorEl.textContent = 'ACCESS DENIED';
                await new Promise(r => setTimeout(r, 1500));
                initLoginScreen(); // Reset the screen
            }
        }

        async function loginSuccess() {
            loginState.active = false;
            loginOverlay.style.opacity = '0';
            await new Promise(r => setTimeout(r, 500));
            loginOverlay.style.display = 'none';

            monitorBezel.style.display = 'flex';
            await new Promise(r => setTimeout(r, 100));
            mainScreen.style.opacity = '1';
            
            initializeTerminal();
        }
        
        // --- Terminal Functions (post-login) ---
        function initializeTerminal() {
            initTitleTypewriter();
            initializeNLU();
            loadHistory();
            displayInitialMessages();
            updateClock();
            setInterval(updateClock, 1000);
            setupTerminalInputListeners();
            updatePrompt();

            (async () => {
                isTyping = true;
                cursor.style.display = 'none';
                if (!localStorage.getItem('chatHistory')) {
                    await typeLorelMessage("Sessione utente '" + currentUser + "' attivata. Benvenuto nel sistema L.A.O.S. v7.3.");
                    await processCommand({command: 'neofetch', args: []});
                }
                isTyping = false;
                cursor.style.display = 'inline-block';
                hiddenInput.focus();
                scrollToBottom();
            })();
        }
        
        function updatePrompt() {
             const homeDir = `/home/${currentUser}`;
             let displayCwd = cwd;
             if (cwd.startsWith(homeDir)) {
                 displayCwd = '~' + cwd.substring(homeDir.length);
             }
             prompt.innerHTML = `<span style=\"color: var(--cmd-highlight)\">${currentUser}@lorel:</span><span style=\"color: var(--dir-blue)\">${displayCwd}</span>$ `;
        }

        function setupTerminalInputListeners() {
            hiddenInput.addEventListener('input', () => {
                playKeySound();
                updateCommandLine();
                updateAutocompleteSuggestion();
            });

            inputForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (isTyping) return;

                prompt.classList.remove('listening');
                autocompleteSuggestion.textContent = '';
                const userInput = hiddenInput.value.trim();
                if (userInput) {
                    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {
                        commandHistory.push(userInput);
                        localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                    }
                    historyIndex = commandHistory.length;
                    hiddenInput.value = '';
                    commandLine.textContent = '';

                    isTyping = true;
                    cursor.style.display = 'none';
                    
                    const analysis = analyzeInput(userInput);
                    addUserMessage(analysis.highlightedInput, true);
                    await processCommand(parseCommand(analysis.command));
                    saveChatHistory();

                    if (parseCommand(userInput).command !== 'reboot') {
                        isTyping = false;
                        cursor.style.display = 'inline-block';
                        updatePrompt();
                        hiddenInput.focus();
                    }
                    scrollToBottom();
                }
            });

            hiddenInput.addEventListener('keydown', async function (e) {
                if (isTyping) return;

                const key = e.key;

                clearTimeout(activityTimeout);
                prompt.classList.add('listening');
                activityTimeout = setTimeout(() => {
                    prompt.classList.remove('listening');
                }, 1500);

                if (key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        hiddenInput.value = commandHistory[historyIndex];
                        hiddenInput.dispatchEvent(new Event('input'));
                    }
                } else if (key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        hiddenInput.value = commandHistory[historyIndex];
                        hiddenInput.dispatchEvent(new Event('input'));
                    } else {
                        historyIndex = commandHistory.length;
                        hiddenInput.value = '';
                        hiddenInput.dispatchEvent(new Event('input'));
                    }
                } else if (key === 'Tab' || key === 'ArrowRight') {
                    if(autocompleteSuggestion.textContent && hiddenInput.selectionStart === hiddenInput.value.length) {
                        e.preventDefault();
                        hiddenInput.value += autocompleteSuggestion.textContent;
                        hiddenInput.dispatchEvent(new Event('input'));
                    } else if (key === 'Tab') {
                       e.preventDefault();
                       await handleLegacyAutocomplete();
                    }
                } else if (key === 'Backspace') {
                     playKeySound();
                }
            });
        }

        function updateCommandLine() {
            const inputText = hiddenInput.value;
            const parts = inputText.split(' ');
            const command = parts[0].toLowerCase();
            
            if (availableCommands.includes(command) && parts[0] !== '') {
                const remainingText = escapeHtml(parts.slice(1).join(' '));
                commandLine.innerHTML = `<span class=\"command-known\">${escapeHtml(parts[0])}</span> ${remainingText}`;
            } else {
                commandLine.textContent = inputText;
            }
        }
        
        function updateAutocompleteSuggestion() {
            const currentInput = hiddenInput.value;
            if (currentInput.includes(' ') || currentInput.length === 0) {
                autocompleteSuggestion.textContent = '';
                return;
            }
            
            const matches = availableCommands.filter(cmd => cmd.startsWith(currentInput));
            
            if (matches.length === 1 && matches[0] !== currentInput) {
                autocompleteSuggestion.textContent = matches[0].substring(currentInput.length);
            } else {
                autocompleteSuggestion.textContent = '';
            }
        }

        function resolvePath(path) {
            if (!path) return cwd;
            const homeDir = `/home/${currentUser}`;
            if (path === '~') path = homeDir;
            if (path.startsWith('~/')) path = `${homeDir}/${path.substring(2)}`;
            
            const newPathParts = path.startsWith('/') ? [] : cwd.split('/').filter(p => p);
            const pathParts = path.split('/').filter(p => p);
            
            for (const part of pathParts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (newPathParts.length > 0) newPathParts.pop();
                } else {
                    newPathParts.push(part);
                }
            }
            return '/' + newPathParts.join('/');
        }

        function escapeHtml(text) { return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function analyzeInput(input) { const intent = classifier.classify(input); if (intent !== 'unknown') { const entity = nerManager.extractEntities(input, intent); if (entity) { const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`); const command = `${intent} ${entity.value}`; return { command, highlightedInput }; } return { command: intent, highlightedInput: input }; } return { command: input, highlightedInput: input }; }
        async function handleLegacyAutocomplete() { const currentInput = hiddenInput.value; const parts = currentInput.split(' '); const lastPart = parts[parts.length - 1]; if (parts.length === 1 && lastPart.length > 0) { const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart)); if (matches.length > 1) { await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`); } return; } }
        function parseCommand(input) { const regex = /[^\\s\"']+|\"([^\"]*)\"|'([^']*)'/g; const tokens = []; let match; do { match = regex.exec(input); if (match !== null) { tokens.push(match[1] || match[2] || match[0]); } } while (match !== null); const command = tokens[0] ? tokens[0].toLowerCase() : ''; const args = []; const flags = {}; for (let i = 1; i < tokens.length; i++) { const token = tokens[i]; if (token.startsWith('--')) { const flagName = token.substring(2); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else if (token.startsWith('-')) { const flagName = token.substring(1); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else { args.push(token); } } return { command, args, flags }; }
        function createAsciiTable(headers, data) { const colWidths = headers.map((header, i) => { return Math.max(header.length, ...data.map(row => String(row[i]).length)); }); const separator = '+' + colWidths.map(w => '-'.repeat(w + 2)).join('+') + '+'; let table = separator + '\n'; table += '|' + headers.map((h, i) => ` ${h.padEnd(colWidths[i])} `).join('|') + '|\n'; table += separator + '\n'; data.forEach(row => { table += '|' + row.map((cell, i) => ` ${String(cell).padEnd(colWidths[i])} `).join('|') + '|\n'; }); table += separator; return table; }

        async function processCommand(parsed) {
            switch (parsed.command) {
                case 'help':
                    const helpText = `Comandi disponibili:\n` +
                                   `  help              - Mostra questa lista di comandi.\n` +
                                   `  status            - Mostra lo stato attuale del sistema.\n` +
                                   `  sysinfo           - Mostra informazioni di sistema in una tabella.\n` +
                                   `  neofetch          - Mostra info di sistema con logo ASCII.\n` +
                                   `  date              - Mostra data e ora correnti.\n` +
                                   `  whoami            - Mostra l'utente attualmente loggato.\n` +
                                   `  news [--limit N]  - Recupera N notizie (default 3).\n` +
                                   `  weather <città>   - Mostra il meteo per una città.\n` +
                                   `  wiki <termine>    - Cerca un termine su Wikipedia.\n` +
                                   `  stats             - Mostra un grafico ASCII di dati simulati.\n` +
                                   `  echo <testo>      - Ripete il testo fornito.\n` +
                                   `  clear             - Pulisce lo schermo del terminale.\n` +
                                   `  reboot            - Simula un riavvio dell'interfaccia.\n\n` +
                                   `File System Commands:\n` +
                                   `  ls [percorso]     - Lista i contenuti di una directory.\n` +
                                   `  cd <directory>    - Cambia la directory corrente.\n` +
                                   `  cat <file>        - Mostra il contenuto di un file.\n` +
                                   `  pwd               - Mostra la directory corrente.`;
                    await typeLorelMessage(helpText);
                    break;
                case 'status':
                    await typeLorelMessage('STATUS: ONLINE. Version: 7.3. All systems nominal. User: ' + currentUser);
                    break;
                case 'sysinfo':
                    const headers = ['Property', 'Value'];
                    const tableData = [
                        ['Version', '7.3 - Neofetch'],
                        ['Creator', 'AleXsjsju'],
                        ['Created', '2025-11-22'],
                        ['Status', 'ONLINE'],
                        ['Logged User', currentUser],
                        ['Modules', 'Neofetch, User Session, File System']
                    ];
                    const table = createAsciiTable(headers, tableData);
                    addLorelMessage('<pre>' + escapeHtml(table) + '</pre>', true);
                    break;
                case 'neofetch':
                    const logoLines = [
                        '██╗      █████╗',
                        '██║     ██╔══██╗',
                        '██║     ███████║',
                        '██║     ██╔══██║',
                        '███████╗██║  ██║',
                        '╚══════╝╚═╝  ╚═╝',
                        ''
                    ];
                    const labelColor = 'var(--term-dim)';
                    const valueColor = 'var(--term-green)';
                    const uptimeMins = Math.floor(performance.now() / 60000); 
                    const uptimeString = `${uptimeMins} mins`;
                    const infoLines = [
                        `<span style=\"color: ${valueColor};\">${currentUser}@lorel</span>`,
                        '------------------',
                        `<span style=\"color: ${labelColor};\">OS</span>: L.A.O.S. v7.3 Neofetch`,
                        `<span style=\"color: ${labelColor};\">Host</span>: Simulated Web Environment`,
                        `<span style=\"color: ${labelColor};\">Kernel</span>: JS-DOM v11.25`,
                        `<span style=\"color: ${labelColor};\">Uptime</span>: ${uptimeString}`,
                        `<span style=\"color: ${labelColor};\">Shell</span>: LAX-Shell 1.0`,
                    ];
                    const logoWidth = 24;
                    let output = '';
                    const maxLines = Math.max(logoLines.length, infoLines.length);
                    for (let i = 0; i < maxLines; i++) {
                        const logoLine = (logoLines[i] || '').padEnd(logoWidth, ' ');
                        const infoLine = infoLines[i] || '';
                        output += `<span style=\"color: var(--cmd-highlight);\">${logoLine}</span>${infoLine}\n`;
                    }
                    addLorelMessage('<pre>' + output + '</pre>', true);
                    break;
                case 'whoami': await typeLorelMessage(currentUser); break;
                case 'pwd': await typeLorelMessage(cwd); break;
                case 'date': await typeLorelMessage(new Date().toLocaleString('it-IT')); break;
                case 'clear': history.innerHTML = ''; localStorage.removeItem('chatHistory'); break;
                case 'reboot': await runRebootSequence(); break;
                case 'echo': await typeLorelMessage(parsed.args.length > 0 ? parsed.args.join(' ') : ''); break;
                case 'news': await fetchNews(parsed.flags.limit || 3); break;
                case 'weather': if (parsed.args.length === 0) { await typeLorelMessage('Uso: weather <città> o chiedi \"che tempo fa a <città>?\"'); } else { await fetchWeather(parsed.args.join(' ')); } break;
                case 'wiki': if (parsed.args.length === 0) { await typeLorelMessage('Uso: wiki <termine da cercare> o chiedi \"cosa è <termine>?\"'); } else { await fetchWikipedia(parsed.args.join(' ')); } break;
                case 'ls': {
                    const path = resolvePath(parsed.args[0]);
                    const node = fileSystem[path];
                    if (node && node.type === 'dir') {
                        let output = '';
                        node.children.forEach(childName => {
                            const childPath = (path === '/' ? '' : path) + '/' + childName;
                            const childNode = fileSystem[childPath];
                            if (childNode.type === 'dir') {
                                output += `<span class=\"fs-dir\">${childName}/</span>  `;
                            } else {
                                output += `${childName}  `;
                            }
                        });
                        addLorelMessage(output.trim(), true);
                    } else {
                        await typeLorelMessage(`ls: cannot access '${parsed.args[0] || '.'}': No such file or directory`);
                    }
                    break;
                }
                case 'cd': {
                    if (!parsed.args[0]) { 
                        cwd = `/home/${currentUser}`;
                        break;
                    } 
                    const path = resolvePath(parsed.args[0]);
                    const node = fileSystem[path];
                    if (node && node.type === 'dir') {
                        cwd = path;
                    } else {
                        await typeLorelMessage(`cd: no such file or directory: ${parsed.args[0]}`);
                    }
                    break;
                }
                case 'cat': {
                    if (parsed.args.length === 0) {
                        await typeLorelMessage(`cat: missing operand`);
                        break;
                    }
                    const path = resolvePath(parsed.args[0]);
                    const node = fileSystem[path];
                    if (node && node.type === 'file') {
                        await typeLorelMessage(node.content);
                    } else if (node && node.type === 'dir') {
                        await typeLorelMessage(`cat: ${parsed.args[0]}: Is a directory`);
                    } else {
                        await typeLorelMessage(`cat: ${parsed.args[0]}: No such file or directory`);
                    }
                    break;
                }
                case 'stats':
                    await typeLorelMessage('Generating system performance chart...');
                    let s = new Array(120).fill(0).map((_, i) => 15 * Math.sin(i * ((Math.PI * 4) / 120)));
                    const chart = asciichart.plot(s, { height: 10 });
                    addLorelMessage('<pre>' + escapeHtml(chart) + '</pre>', true);
                    await typeLorelMessage('Chart depicts simulated CPU load over the last 60 seconds.');
                    break;
                default:
                    await typeLorelMessage(`Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`);
                    break;
            }
        }

        async function runRebootSequence() {
            await typeLorelMessage("[SYSTEM] Reboot sequence initiated... Shutting down.");
            await new Promise(resolve => setTimeout(resolve, 1000));

            mainScreen.style.opacity = '0';
            monitorBezel.style.display = 'none';
            await new Promise(resolve => setTimeout(resolve, 500));

            biosOverlay.style.display = 'flex';
            const biosLines = [ { text: 'LorelAxun BIOS v1.2', delay: 500 }, { text: 'Copyright (c) 2025 AleXsjsju Corp.', delay: 200 }, { text: '', delay: 500 }, { text: 'Initializing Core Memory.................... ', delay: 300 }, { text: '65536 KB OK', delay: 100, append: true, action: playBiosBeep }, { text: '\nDetecting Primary Master.................. LAX-HD-01', delay: 800 }, { text: 'Detecting Primary Slave................. None', delay: 800 }, { text: 'Detecting Secondary Master................ None', delay: 800 }, { text: 'Detecting Secondary Slave................. None', delay: 800 }, { text: '', delay: 500 }, { text: 'Checking NVRAM............................ OK', delay: 400 }, { text: 'Initializing Web-Access Layer........... OK', delay: 600 }, { text: '', delay: 1000 }, { text: 'Booting from Primary Master (LAX-HD-01)...', delay: 500 }, ];
            for (const line of biosLines) { await new Promise(resolve => setTimeout(resolve, line.delay)); if (line.append) { biosOverlay.textContent += line.text; } else { biosOverlay.textContent += line.text + '\n'; } if (line.action) { await line.action(); } }
            await new Promise(resolve => setTimeout(resolve, 1000));
            biosOverlay.style.display = 'none';
            biosOverlay.textContent = '';

            const logo = `\n██╗      █████╗\n██║     ██╔══██╗\n██║     ███████║\n██║     ██╔══██║\n███████╗██║  ██║\n╚══════╝╚═╝  ╚═╝\n            `;
            bootLogoOverlay.innerHTML = `<pre>${escapeHtml(logo)}</pre>`;
            bootLogoOverlay.style.display = 'flex';
            playSound('startup-sound');
            await new Promise(resolve => setTimeout(resolve, 3500));
            bootLogoOverlay.style.display = 'none';
            bootLogoOverlay.innerHTML = '';

            initLoginScreen();
        }

        async function fetchWikipedia(term) { await typeLorelMessage(`Ricerca su Wikipedia per \"${term}\"...`); try { const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`; const searchResponse = await fetch(searchUrl); if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`); const searchData = await searchResponse.json(); if (!searchData.query.search || searchData.query.search.length === 0) { throw new Error(`Nessun risultato trovato per \"${term}\".`); } const searchResults = searchData.query.search; if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) { let disambiguation = false; if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true; if(disambiguation || searchResults.length > 2) { let suggestionText = `Trovati più risultati per \"${term}\". Essere più specifici:\n`; searchResults.slice(0, 5).forEach(res => { suggestionText += `  - ${res.title}\n`; }); suggestionText += `Esempio: wiki \"${searchResults[0].title}\"`; await typeLorelMessage(suggestionText); return; } } const pageTitle = searchResults[0].title; await typeLorelMessage(`Trovata pagina: \"${pageTitle}\".\nRecupero riassunto...`); const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`; const summaryResponse = await fetch(summaryUrl); if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`); const summaryData = await summaryResponse.json(); const pages = summaryData.query.pages; const pageId = Object.keys(pages)[0]; const extract = pages[pageId].extract; if (extract) { await typeLorelMessage(extract); } else { throw new Error(`Nessun riassunto disponibile per \"${pageTitle}\".`); } } catch (error) { await typeLorelMessage(`Errore durante la ricerca su Wikipedia: ${error.message}`); } }
        async function fetchWeather(city) { await typeLorelMessage(`Ricerca coordinate per ${city}...`); try { const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`); if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`); const geoData = await geoResponse.json(); if (!geoData.results || geoData.results.length === 0) { throw new Error(`Località non trovata: ${city}`); } const uniqueLocations = []; const seen = new Set(); for (const loc of geoData.results) { const identifier = `${loc.name}, ${loc.admin1 || loc.country}`; if (!seen.has(identifier)) { uniqueLocations.push(loc); seen.add(identifier); } } let location; if (uniqueLocations.length > 1 && !city.includes(',')) { let suggestionText = `Trovate più località per \"${city}\". Essere più specifici:\n`; uniqueLocations.slice(0, 3).forEach(loc => { suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\n`; }); suggestionText += `Esempio: weather \"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\"`; await typeLorelMessage(suggestionText); return; } else { location = uniqueLocations[0]; } const { latitude, longitude, name, admin1, country_code } = location; const locationName = `${name}, ${admin1 || country_code}`; await typeLorelMessage(`Coordinate trovate per ${locationName}.\nRecupero dati meteo...`); const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`); if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`); const weatherData = await weatherResponse.json(); const { temperature, windspeed, weathercode } = weatherData.current_weather; const weatherDescription = getWeatherDescription(weathercode); const weatherReport = `Meteo attuale per ${locationName}:\n` + `  - Descrizione: ${weatherDescription}\n` + `  - Temperatura: ${temperature}°C\n` + `  - Vento: ${windspeed} km/h`; await typeLorelMessage(weatherReport); } catch (error) { await typeLorelMessage(`Errore durante il recupero del meteo: ${error.message}`); } }
        function getWeatherDescription(code) { const descriptions = { 0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso', 45: 'Nebbia', 48: 'Nebbia con brina', 51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa', 61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte', 71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte', 80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento', 95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante' }; return descriptions[code] || 'Condizioni non specificate'; }
        async function fetchNews(limit = 3) { await typeLorelMessage(`Recupero ${limit} notizie dal web...`); try { const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); let newsHeadlines = 'Ultime notizie recuperate:\n'; data.forEach((article, index) => { const title = article.title.charAt(0).toUpperCase() + article.title.slice(1); newsHeadlines += `\n[${index + 1}] ${title}`; }); await typeLorelMessage(newsHeadlines); } catch (error) { await typeLorelMessage(`Errore durante il recupero delle notizie: ${error.message}`); } }
        async function typeLorelMessage(text) { const messageDiv = document.createElement('div'); messageDiv.className = 'msg lorel'; history.appendChild(messageDiv); scrollToBottom(); const chunks = text.split('\n'); for (let i = 0; i < chunks.length; i++) { const chunk = chunks[i]; if (i > 0) { messageDiv.innerText += '\n'; const pauseDuration = 250 + Math.random() * 300; await new Promise(resolve => setTimeout(resolve, pauseDuration)); } for (let j = 0; j < chunk.length; j++) { const char = chunk.charAt(j); messageDiv.innerText += char; playKeySound(); scrollToBottom(); const speed = 30 + (Math.random() * 25); await new Promise(resolve => setTimeout(resolve, speed)); if (char === ',') { await new Promise(resolve => setTimeout(resolve, 250 + Math.random() * 100)); } else if (char === '.' || char === '!' || char === '?') { await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 150)); } } } saveChatHistory(); }
        function addLorelMessage(text, isHtml = false) { const div = document.createElement('div'); div.className = 'msg lorel'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }
        function addUserMessage(text, isHtml = false) { const div = document.createElement('div'); div.className = 'msg user'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }
        function saveChatHistory() { localStorage.setItem('chatHistory', history.innerHTML); }
        function loadHistory() { const savedCommandHistory = localStorage.getItem('commandHistory'); if(savedCommandHistory) { commandHistory = JSON.parse(savedCommandHistory); historyIndex = commandHistory.length; } const savedChat = localStorage.getItem('chatHistory'); if (savedChat) { history.innerHTML = savedChat; } }
        
        function displayInitialMessages() {
            const messages = [
                '[SYSTEM] Initializing core memory... OK',
                '[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span>',
                '[UPDATE] Session persistence enabled via localStorage. History is now saved.',
                '[AESTHETICS] Keystroke audio feedback enabled.',
                '[SYSTEM] Advanced command parser implemented. Now supports quoted arguments and flags.',
                '[AESTHETICS] Title animation upgraded to a dynamic, cyclical typewriter effect.',
                '[OPTIMIZATION] Blinking cursor animation refined for code simplicity and efficiency.',
                '[REFINEMENT] Typing speed now has random variations for a more organic feel.',
                '[IMMERSION] Ambient static hum enabled for a complete CRT experience.',
                '[REFINEMENT] Long responses are now streamed chunk-by-chunk for a more dynamic feel.',
                '[AESTHETICS] Added chromatic aberration text animation for enhanced visual authenticity.',
                '[AESTHETICS] Monitor bezel effect added to encapsulate the interface.',
                '[AESTHETICS] Added moving scanline effect to simulate CRT refresh cycle.',
                '[INTEGRATION] User input now handled by a robust, invisible `<input>` for improved compatibility.',
                '[LEXICAL ANALYSIS] User command syntax is now highlighted in real-time for instant feedback.',
                '[ASSISTANCE] Command autocompletion (Tab key) is now active for predictive input.',
                '[VISUALIZATION] Data visualization enabled via ASCII charts. Try the \'stats\' command.',
                '[VISUALIZATION] Data tabulation enabled via ASCII tables. Try the \'sysinfo\' command.',
                '[REFINEMENT] Lorel\\'s typing rhythm is now more natural, with conversational pauses.',
                '[AESTHETICS] \'ONLINE\' status indicator is now animated with a pulsing glow effect.',
                '[ASSISTANCE] Inline command autocompletion suggestions (\'ghost text\') are now active.',
                '[SYSTEM] Reboot Protocol module loaded. Type \'reboot\' to restart the interface.',
                '[IMMERSION] Reboot sequence now features a simulated BIOS POST screen with an audible beep.',
                '[IMMERSION] Boot sequence upgraded with an animated ASCII logo and startup sound.',
                '[SECURITY] System access now requires authentication via Login Protocol.',
                '[SYSTEM] Session now user-aware. Prompt reflects logged-in user. Added \'whoami\' command.',
                '[SYSTEM] Simulated file system is now active. Try commands: ls, cd, cat, pwd.',
                '[SYSTEM] Identity module added. Try the new `neofetch` command for system info.',
            ];
            let content = '';
            messages.forEach(msg => {
                content += `<div class=\"sys-msg\">${msg}</div>`;
            });
            initialMessagesContainer.innerHTML = content;
        }

        function scrollToBottom() { terminalContainer.scrollTop = terminalContainer.scrollHeight; }
        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('it-IT'); clock.textContent = timeString; }
        
        window.onload = () => {
            initializeGlobalListeners();
            initLoginScreen();
        }

    </script>
</body>
</html>
