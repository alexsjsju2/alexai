<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>LOREL AXUN V8.3 // SCRIPTING ENGINE</title>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=VT323&display=swap\" rel=\"stylesheet\">\n    <script src=\"https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1\"></script>\n    <style>\n        :root {\n            --bg-color: #0a0a0a;\n            --term-green: #33ff00;\n            --term-dim: #1a8000;\n            --term-glow: #33ff0080;\n            --cmd-highlight: #00ffff;\n            --bios-text: #cccccc;\n            --error-red: #ff3333;\n            --dir-blue: #87cefa; /* Light Sky Blue for directories */\n        }\n        html {\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            background-color: #000;\n        }\n        body {\n            height: 100%;\n            margin: 0;\n            padding: 20px;\n            box-sizing: border-box;\n            color: var(--term-green);\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            overflow: hidden;\n        }\n\n        .monitor-bezel {\n            background-color: #1a1a1a; /* Dark gray for plastic */\n            border-radius: 25px;\n            padding: 20px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.8);\n            width: 100%;\n            height: 100%;\n            max-width: 1280px;\n            max-height: 800px;\n            display: flex;\n            flex-direction: column;\n        }\n\n        .screen {\n            flex: 1;\n            background-color: var(--bg-color);\n            border-radius: 10px; /* Inner screen roundness */\n            overflow: hidden; /* Contains the screen content and effects */\n            position: relative; /* For the ::before/::after pseudo-elements */\n            display: flex;\n            flex-direction: column;\n            transition: opacity 0.5s ease-in-out;\n        }\n\n        /* CRT Effect Overlay */\n        .crt::before {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));\n            z-index: 2;\n            background-size: 100% 2px, 3px 100%;\n            pointer-events: none;\n        }\n        .crt::after {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: rgba(18, 16, 16, 0.1);\n            opacity: 0;\n            z-index: 2;\n            pointer-events: none;\n            animation: flicker 0.15s infinite;\n        }\n        @keyframes flicker {\n            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }\n        }\n        \n        .moving-scanline {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 3px;\n            background: rgba(51, 255, 0, 0.1);\n            box-shadow: 0 0 10px rgba(51, 255, 0, 0.3);\n            z-index: 3;\n            pointer-events: none;\n            animation: scanline-scroll 5s linear infinite;\n        }\n        @keyframes scanline-scroll {\n            0% {\n                transform: translateY(0vh);\n            }\n            100% {\n                transform: translateY(100vh);\n            }\n        }\n\n        .terminal-container {\n            padding: 20px;\n            flex: 1;\n            overflow-y: auto;\n            width: 100%;\n            box-sizing: border-box;\n            text-shadow: 0 0 5px var(--term-glow);\n            display: flex;\n            flex-direction: column;\n        }\n\n        h1 {\n            border-bottom: 2px solid var(--term-green);\n            padding-bottom: 10px;\n            margin-bottom: 20px;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n            height: 1.5rem; /* Reserve space for typewriter */\n        }\n\n        #typewriter-title .title-cursor {\n            display: inline-block;\n            background-color: var(--term-green);\n            box-shadow: 0 0 5px var(--term-glow);\n            width: 1ch;\n            height: 1.5rem;\n            vertical-align: bottom;\n            animation: blink 1s step-end infinite;\n        }\n\n        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }\n        .sys-msg span { color: var(--term-green); font-weight: bold; }\n\n        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}\n        #initial-messages { display: flex; flex-direction: column; gap: 0px; margin-bottom:10px; }\n\n        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }\n        .msg.lorel::before { content: \"LOREL_SYS>> \"; color: var(--term-green); }\n        .msg.user::before { content: \"USER_INPUT>> \"; color: #00ffff; }\n        .msg.user { color: #ccffff; }\n\n        .msg pre {\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            margin: 0;\n            white-space: pre-wrap;\n            line-height: 1.2;\n        }\n        .msg .fs-dir { color: var(--dir-blue); font-weight: bold; }\n\n        mark {\n            background-color: var(--term-dim);\n            color: var(--term-green);\n            text-shadow: none;\n            padding: 0 3px;\n        }\n\n        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px; position: relative;}\n        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }\n        .prompt.listening::after {\n            content: '_';\n            animation: blink 0.8s step-end infinite;\n            padding-left: 5px;\n            color: var(--term-dim);\n        }\n\n        #command-line .command-known {\n            color: var(--cmd-highlight);\n            font-weight: bold;\n        }\n        \n        #autocomplete-suggestion {\n            color: var(--term-dim);\n            opacity: 0.7;\n            pointer-events: none; /* Make it non-interactive */\n        }\n\n        #hidden-input {\n            position: absolute;\n            top: 15px;\n            left: 0;\n            width: 100%;\n            height: 1.2rem;\n            background: transparent;\n            border: none;\n            color: transparent;\n            caret-color: transparent;\n            outline: none;\n            padding: 0;\n            font-family: 'VT323', monospace;\n            font-size: 1.2rem;\n            z-index: -1;\n        }\n\n        #cursor {\n            background: var(--term-green);\n            display: inline-block;\n            width: 10px;\n            height: 1.2rem;\n            animation: blink 1s step-end infinite;\n            box-shadow: 0 0 5px var(--term-glow);\n            vertical-align: middle;\n        }\n        @keyframes blink {\n            50% { opacity: 0.0; }\n        }\n\n        /* Scrollbar styling */\n        ::-webkit-scrollbar { width: 10px; }\n        ::-webkit-scrollbar-track { background: #000; }\n        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }\n\n        .glitch {\n            position: relative;\n        }\n        .glitch::before, .glitch::after {\n            content: attr(data-text);\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: var(--bg-color);\n        }\n        .glitch::before {\n            left: 2px;\n            text-shadow: -2px 0 #ff00c1;\n            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);\n            animation: glitch-anim-2 2.5s infinite steps(8) reverse;\n        }\n        .glitch::after {\n            left: -2px;\n            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;\n            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);\n            animation: glitch-anim-2 2.5s infinite steps(8);\n        }\n        @keyframes glitch-anim-2 {\n            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }\n        }\n\n        .chromatic-aberration {\n            animation: text-flicker 3s linear infinite;\n        }\n\n        @keyframes text-flicker {\n            0% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            15% { text-shadow: 1.5px 0 0 red, -1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            30% { text-shadow: -1px 0 0 red, 1px 0 0 cyan, 0 0 5px var(--term-glow); }            45% { text-shadow: -1.5px 0 0 red, 1.5px 0 0 cyan, 0 0 5px var(--term-glow); }            60% { text-shadow: 0.5px 0.5px 0 red, -0.5px -0.5px 0 cyan, 0 0 5px var(--term-glow); }            75% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }            100% { text-shadow: 1px 0 0 red, -1px 0 0 cyan, 0 0 5px var(--term-glow); }\n        }\n\n        .status-bar {\n            background-color: var(--term-green);\n            color: var(--bg-color);\n            padding: 2px 10px;\n            width: 100%;\n            box-sizing: border-box;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            font-size: 1rem;\n            height: 25px;\n        }\n        .status-bar span {\n            font-weight: bold;\n        }\n\n        .pulse-glow {\n            animation: pulse 1.5s infinite ease-in-out;\n        }\n        @keyframes pulse {\n            0% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }            50% { text-shadow: 0 0 5px var(--bg-color), 0 0 10px #000; }            100% { text-shadow: 0 0 2px var(--bg-color), 0 0 4px var(--bg-color); }\n        }\n\n        #bios-overlay, #boot-logo-overlay, #login-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: #000;\n            font-family: 'VT323', monospace;\n            padding: 20px;\n            box-sizing: border-box;\n            display: none;\n            white-space: pre;\n            align-items: center;\n            justify-content: center;\n            flex-direction: column;\n            z-index: 10000;\n        }\n        #bios-overlay {\n             color: var(--bios-text);\n             align-items: flex-start;\n             justify-content: flex-start;\n        }\n        #boot-logo-overlay {\n            z-index: 9999;\n        }\n        #boot-logo-overlay pre {\n            color: var(--term-green);\n            font-size: 1.5rem;\n            text-shadow: 0 0 10px var(--term-glow);\n            animation: logo-fade-glitch 3.5s ease-in-out forwards;\n            line-height: 1.2;\n            text-align: center;\n        }\n        @keyframes logo-fade-glitch {\n            0% { opacity: 0; transform: translateY(10px); }            10% { opacity: 1; transform: translateY(0); }            20% { text-shadow: 0 0 15px var(--term-glow), 2px 0 red, -2px 0 cyan; }            21% { text-shadow: 0 0 10px var(--term-glow); }            80% { opacity: 1; }            100% { opacity: 0; }\n        }\n\n        #login-overlay {\n            z-index: 9998;\n            font-size: 1.5rem;\n            color: var(--term-green);\n            text-shadow: 0 0 5px var(--term-glow);\n        }\n        .login-box {\n            border: 2px solid var(--term-green);\n            padding: 2rem 4rem;\n            box-shadow: 0 0 15px var(--term-glow) inset;\n        }\n        .login-prompt {\n            display: flex;\n            align-items: center;\n            margin: 1rem 0;\n        }\n        .login-cursor {\n             display: inline-block;\n            background-color: var(--term-green);\n            box-shadow: 0 0 5px var(--term-glow);\n            width: 1ch;\n            height: 1.5rem;\n            vertical-align: bottom;\n            animation: blink 1s step-end infinite;\n            margin-left: 5px;\n        }\n        #login-error-message {\n            color: var(--error-red);\n            text-shadow: 0 0 5px var(--error-red);\n            height: 1.5rem;\n            margin-top: 1rem;\n            text-align: center;\n            animation: error-flicker 0.2s infinite;\n        }\n        @keyframes error-flicker {\n            50% { opacity: 0.7; }\n        }\n\n    </style>\n</head>\n<body>\n    <div id=\"bios-overlay\"></div>\n    <div id=\"boot-logo-overlay\"></div>\n    <div id=\"login-overlay\"></div>\n\n    <div class=\"monitor-bezel\" id=\"monitor-bezel\" style=\"display: none;\">\n        <div class=\"screen crt\" id=\"main-screen\">\n            <div class=\"moving-scanline\"></div>\n            <div class=\"terminal-container\" id=\"terminal-container\">\n                <h1 class=\"glitch chromatic-aberration\" data-text=\"Lorel Axun v8.3\"><span id=\"typewriter-title\"></span></h1>\n                \n                <div id=\"initial-messages\"></div>\n\n                <div id=\"chat-history\" class=\"chat-history\"></div>\n\n                <form class=\"input-line\" id=\"input-form\">\n                    <span class=\"prompt\" id=\"prompt\"></span>\n                    <span id=\"command-line\"></span><span id=\"autocomplete-suggestion\"></span><span id=\"cursor\"></span>\n                    <input type=\"text\" id=\"hidden-input\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n                </form>\n            </div>\n            <div class=\"status-bar\">\n                <span>LOREL AXUN v8.3</span>\n                <span>STATUS: <span class=\"pulse-glow\">ONLINE</span></span>\n                <span id=\"clock\"></span>\n            </div>\n        </div>\n    </div>\n\n    <audio id=\"static-hum\" loop src=\"data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8CAP3/AwD+/wEAAgD9/wEA/v8CAP7/AgD9/wMA/v8CAP7/AwD+/wE=\"></audio>\n    <audio id=\"startup-sound\" src=\"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8/wD7APgA+wD4AP8A+wD8AP4A/AD9AP0A/QD8AP0A/QD9APwA/QD7APwA+wD7APgA+QD5APsA+QD5APkA+QD4APgA+AD4APc=+\"></audio>\n    <audio id=\"login-success-sound\" src=\"data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVgAAAAIAAD/AP8A/wD/AP8A/wD/AAABAAEBAgADAgMDBAQEBgYIBwkKCw0ODxAREhMUFRYXGBkbHR4fICEiJCUnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW11eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAA==\"></audio>\n    <audio id=\"login-fail-sound\" src=\"data:audio/wav;base64,UklGRiwAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQgAAAAAAAD/AP4A/QD7APYA9ADwAOwA6ADlANsA1QDHAMQAwgC/ALsAsQCiAIcAfwB3AHQAcQBwAGoAZQBgAFwAVQBRAEsARgBDAEAAOQAyACsAJQAgABwAGQAVABEADgAKAAcABAAAAAAA//8=\"></audio>\n\n    <script>\n        // --- asciichart.js (embedded) ---\n        // Copyright (c) 2017, Andrei Kashcha\n        // All rights reserved.\n        const asciichart = (function() {\n            function colored (char, color) {\n                return (color === undefined) ? char : ('<span style=\"color: ' + color + '\">' + char + '</span>')\n            }\n            function plot (series, cfg = undefined) {\n                let min = (cfg && cfg.min !== undefined) ? cfg.min : series[0]\n                let max = (cfg && cfg.max !== undefined) ? cfg.max : series[0]\n\n                for (let i = 1; i < series.length; i++) {\n                    min = Math.min(min, series[i])\n                    max = Math.max(max, series[i])\n                }\n\n                let defaultSymbols = [ '┼', '┤', '╶', '╴', '─', '╰', '╯', '│', '╭', '╮', '│' ]\n                let range = Math.abs (max - min)\n                let offset = (cfg && cfg.offset !== undefined) ? cfg.offset : 3\n                let padding = (cfg && cfg.padding !== undefined) ? cfg.padding : '           '\n                let height = (cfg && cfg.height !== undefined) ? cfg.height : range\n                let ratio = (range !== 0) ? height / range : 1;\n                let min2 = Math.round (min * ratio)\n                let max2 = Math.round (max * ratio)\n                let rows = Math.abs (max2 - min2)\n                let width = (cfg && cfg.width !== undefined) ? cfg.width : series.length + offset\n\n                let result = new Array (rows + 1)\n                for (let i = 0; i < rows + 1; i++) {\n                    result[i] = new Array (width)\n                    for (let j = 0; j < width; j++) {\n                        result[i][j] = ' '\n                    }\n                }\n                let y_labels = []\n                for (let i = 0; i <= rows; i++) {\n                  let y = max - (i * (range / rows))\n                  y_labels.push(y.toFixed(2).padStart(padding.length - 2) + ' ' + defaultSymbols[0])\n                }\n\n                for (let y = min2; y <= max2; y++) {\n                    result[rows - (y - min2)][offset - 1] = defaultSymbols[0]\n                }\n\n                for (let x = 0; x < series.length; x++) {\n                    let y0 = Math.round (series[x] * ratio) - min2\n                    result[rows - y0][x + offset] = defaultSymbols[4]\n\n                    if (x > 0) {\n                        let y1 = Math.round(series[x - 1] * ratio) - min2;\n                        if (y0 == y1) {\n                            result[rows - y0][x + offset -1] = defaultSymbols[4];\n                        }\n                    }\n                }\n\n                let lines = []\n                for(let i=0; i < result.length; i++) {\n                  lines.push(y_labels[i] + result[i].join(''))\n                }\n\n                return lines.join('\\n')\n            }\n            return { plot: plot }\n        })()\n\n        // --- Lorel's Core Script ---\n        // DOM Elements\n        const history = document.getElementById('chat-history');\n        const commandLine = document.getElementById('command-line');\n        const autocompleteSuggestion = document.getElementById('autocomplete-suggestion');\n        const terminalContainer = document.getElementById('terminal-container');\n        const initialMessagesContainer = document.getElementById('initial-messages');\n        const cursor = document.getElementById('cursor');\n        const clock = document.getElementById('clock');\n        const prompt = document.getElementById('prompt');\n        const hiddenInput = document.getElementById('hidden-input');\n        const inputForm = document.getElementById('input-form');\n        const biosOverlay = document.getElementById('bios-overlay');\n        const bootLogoOverlay = document.getElementById('boot-logo-overlay');\n        const loginOverlay = document.getElementById('login-overlay');\n        const mainScreen = document.getElementById('main-screen');\n        const monitorBezel = document.getElementById('monitor-bezel');\n\n        // State Variables\n        let isTyping = false;\n        let commandHistory = [];\n        let historyIndex = -1;\n        let activityTimeout;\n        let userHasInteracted = false;\n        let audioCtx = null;\n        let currentUser = 'user';\n        let cwd = '/home/admin'; // Current Working Directory\n        let loginState = {\n            active: false,\n            step: 'username', // 'username' or 'password'\n            username: '',\n            password: ''\n        };\n        let sentimentPipeline = null;\n        let textGenerationPipeline = null;\n\n        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear', 'stats', 'sysinfo', 'reboot', 'whoami', 'ls', 'cd', 'cat', 'pwd', 'neofetch', 'mkdir', 'touch', 'rm', 'sentiment', 'generate', 'run'];\n        \n        // --- Simulated File System ---\n        let fileSystem = {\n            '/': { type: 'dir', children: ['home', 'var', 'README'] },\n            '/home': { type: 'dir', children: ['admin'] },\n            '/home/admin': { type: 'dir', children: ['docs', 'welcome.txt', 'demo.js'] },\n            '/home/admin/docs': { type: 'dir', children: ['project.txt'] },\n            '/home/admin/docs/project.txt': { type: 'file', content: 'Project Phoenix: An initiative to expand conversational AI capabilities using in-browser transformers.' },\n            '/home/admin/welcome.txt': { type: 'file', content: 'Benvenuto nel sistema L.A.O.S. v8.3!\\nQuesto è un file system simulato.\\nProva i comandi `ls`, `cd`, `cat`, `mkdir`, `touch`, `rm` e la redirezione dell\\\'output (es. `echo \"hello\" > newfile.txt`) per esplorare e gestire il sistema.\\nProva il nuovo comando `run demo.js`!' },\n            '/home/admin/demo.js': { type: 'file', content: 'terminal.log(\"Ciao dal mio primo script!\");\\nfor (let i = 1; i <= 3; i++) {\\n  terminal.log(`Esecuzione ciclo: ${i}`);\\n}\\nterminal.log(\"Script completato.\");' },\n            '/var': { type: 'dir', children: ['log'] },\n            '/var/log': { type: 'dir', children: ['system.log'] },\n            '/var/log/system.log': { type: 'file', content: 'LOG START\\n2025-11-23 10:00:01 | System boot sequence initiated.\\n2025-11-23 10:00:05 | Login protocol engaged.\\n2025-11-23 10:00:12 | User `admin` authenticated successfully.\\n2025-11-23 10:00:13 | Session started.\\nLOG END' },\n            '/README': { type: 'file', content: 'Lorel Axun Operating System (L.A.O.S.)\\nVersione: 8.3 - Scripting Engine\\nCreatore: AleXsjsju' },\n        };\n\n        // --- Dynamic Title Engine ---\n        function initTitleTypewriter() {\n            const target = document.getElementById('typewriter-title');\n            const phrases = [\n                \"Lorel Axun v8.3\",\n                \"Status: ONLINE\",\n                \"Scripting Engine Active\",\n                \"Awaiting input...\"\n            ];\n            let phraseIndex = 0;\n            let charIndex = 0;\n            let isDeleting = false;\n\n            const typeSpeed = 100;\n            const deleteSpeed = 50;\n            const delay = 2000;\n\n            function type() {\n                const currentPhrase = phrases[phraseIndex];\n                let displayText = '';\n\n                if (isDeleting) {\n                    displayText = currentPhrase.substring(0, charIndex - 1);\n                    charIndex--;\n                } else {\n                    displayText = currentPhrase.substring(0, charIndex + 1);\n                    charIndex++;\n                }\n\n                target.innerHTML = `${displayText}<span class=\"title-cursor\"></span>`;\n\n                if (!isDeleting && charIndex === currentPhrase.length) {\n                    isDeleting = true;\n                    setTimeout(type, delay);\n                } else if (isDeleting && charIndex === 0) {\n                    isDeleting = false;\n                    phraseIndex = (phraseIndex + 1) % phrases.length;\n                    setTimeout(type, 500);\n                } else {\n                    setTimeout(type, isDeleting ? deleteSpeed : typeSpeed);\n                }\n            }\n            type();\n        }\n\n        // --- Audio Feedback Engine ---\n        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';\n        const keySoundPoolSize = 10; \n        const keySoundPool = [];\n        let keySoundIndex = 0;\n\n        for (let i = 0; i < keySoundPoolSize; i++) {\n            keySoundPool.push(new Audio(KEY_CLICK_SOUND));\n        }\n\n        function playSound(id) {\n            if(!userHasInteracted) return;\n            const sound = document.getElementById(id);\n            if (sound) {\n                sound.currentTime = 0;\n                sound.play().catch(e => {});\n            }\n        }\n\n        function playKeySound() {\n            playSound('keySoundPool' + keySoundIndex);\n            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;\n        }\n\n        async function playBiosBeep() {\n            return new Promise(resolve => {\n                if (!audioCtx || !userHasInteracted) {\n                    resolve();\n                    return;\n                }\n                const oscillator = audioCtx.createOscillator();\n                const gainNode = audioCtx.createGain();\n                \n                oscillator.connect(gainNode);\n                gainNode.connect(audioCtx.destination);\n\n                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);\n                oscillator.frequency.setValueAtTime(900, audioCtx.currentTime); // High-pitched beep\n                oscillator.type = 'sine';\n\n                oscillator.start();\n                oscillator.stop(audioCtx.currentTime + 0.15); // Beep for 150ms\n                oscillator.onended = resolve;\n            });\n        }\n        \n        // --- NLU Engine ---\n        const classifier = { intents: {}, train: function(intent, phrases) { if (!this.intents[intent]) this.intents[intent] = []; phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase))); }, tokenize: text => text.toLowerCase().replace(/[^a-z0-9\\s]/gi, '').split(/\\s+/).filter(Boolean), classify: function(text) { const tokens = this.tokenize(text); let bestMatch = { intent: 'unknown', score: 0 }; for (const intent in this.intents) { let intentScore = 0; this.intents[intent].forEach(phraseTokens => { const commonTokens = tokens.filter(token => phraseTokens.includes(token)); const score = commonTokens.length / phraseTokens.length; if (score > intentScore) intentScore = score; }); if (intentScore > bestMatch.score) { bestMatch = { intent, score: intentScore }; } } return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; } };\n        const nerManager = { extractEntities: function(text, intent) { if (intent === 'weather') { const match = text.match(/(?:a|per|di|a)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\"`, text: entityText, type: 'LOCATION' }; } } else if (intent === 'wiki') { const match = text.match(/(?:è|e'|di|su)\\s(.+)/i); if (match && match[1]) { const entityText = match[1].trim().replace('?',''); return { value: `\\\"${entityText}\\"`, text: entityText, type: 'TOPIC' }; } } return null; } };\n        function initializeNLU() { classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']); classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']); classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']); classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']); classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']); }\n\n        // --- Event Listeners ---\n        function initializeGlobalListeners() {\n            document.addEventListener('keydown', handleGlobalKeyPress);\n            terminalContainer.addEventListener('click', () => {\n                if (!loginState.active) hiddenInput.focus();\n            });\n        }\n\n        function handleGlobalKeyPress(e) {\n            if (!userHasInteracted) {\n                const hum = document.getElementById('static-hum');\n                hum.volume = 0.05;\n                hum.play().catch(err => {});\n                audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n                userHasInteracted = true;\n            }\n\n            if (loginState.active) {\n                handleLoginInput(e);\n            }\n        }\n\n        // --- Login Protocol ---\n        function initLoginScreen() {\n            loginState.active = true;\n            loginState.step = 'username';\n            loginState.username = '';\n            loginState.password = '';\n            currentUser = 'user'; // Reset on logout/reboot\n\n            const loginHTML = `\n                <div class=\"login-box\">\n                    <pre>L.A.O.S. v8.3 (Lorel Axun Operating System)</pre>\n                    <div class=\"login-prompt\">\n                        <span>Username: </span>\n                        <span id=\"login-user-input\"></span>\n                        <span id=\"login-user-cursor\" class=\"login-cursor\"></span>\n                    </div>\n                    <div class=\"login-prompt\">\n                        <span>Password: </span>\n                        <span id=\"login-pass-input\"></span>\n                        <span id=\"login-pass-cursor\" class=\"login-cursor\" style=\"display:none;\"></span>\n                    </div>\n                    <div id=\"login-error-message\"></div>\n                </div>\n            `;\n            loginOverlay.innerHTML = loginHTML;\n            loginOverlay.style.display = 'flex';\n        }\n\n        function handleLoginInput(e) {\n            e.preventDefault();\n            const key = e.key;\n\n            playKeySound();\n\n            if (key === 'Enter') {\n                if (loginState.step === 'username') {\n                    loginState.step = 'password';\n                    document.getElementById('login-user-cursor').style.display = 'none';\n                    document.getElementById('login-pass-cursor').style.display = 'inline-block';\n                } else if (loginState.step === 'password') {\n                    attemptLogin();\n                }\n                return;\n            }\n\n            if (key === 'Backspace') {\n                if (loginState.step === 'username' && loginState.username.length > 0) {\n                    loginState.username = loginState.username.slice(0, -1);\n                } else if (loginState.step === 'password' && loginState.password.length > 0) {\n                    loginState.password = loginState.password.slice(0, -1);\n                } \n            } else if (key.length === 1) { // Regular character input\n                if (loginState.step === 'username') {\n                    loginState.username += key;\n                } else if (loginState.step === 'password') {\n                    loginState.password += key;\n                }\n            }\n            updateLoginDisplay();\n        }\n\n        function updateLoginDisplay() {\n            document.getElementById('login-user-input').textContent = loginState.username;\n            document.getElementById('login-pass-input').textContent = '*'.repeat(loginState.password.length);\n        }\n\n        async function attemptLogin() {\n            const errorEl = document.getElementById('login-error-message');\n            errorEl.textContent = 'AUTHENTICATING...';\n            await new Promise(r => setTimeout(r, 500));\n\n            // Hardcoded credentials for simulation\n            if (loginState.username === 'admin' && loginState.password === 'axun7.3') {\n                playSound('login-success-sound');\n                errorEl.style.color = 'var(--term-green)';\n                errorEl.textContent = 'ACCESS GRANTED';\n                currentUser = loginState.username;\n                await new Promise(r => setTimeout(r, 1000));\n                loginSuccess();\n            } else {\n                playSound('login-fail-sound');\n                errorEl.style.color = 'var(--error-red)';\n                errorEl.textContent = 'ACCESS DENIED';\n                await new Promise(r => setTimeout(r, 1500));\n                initLoginScreen(); // Reset the screen\n            }\n        }\n\n        async function loginSuccess() {\n            loginState.active = false;\n            loginOverlay.style.opacity = '0';\n            await new Promise(r => setTimeout(r, 500));\n            loginOverlay.style.display = 'none';\n\n            monitorBezel.style.display = 'flex';\n            await new Promise(r => setTimeout(r, 100));\n            mainScreen.style.opacity = '1';\n            \n            initializeTerminal();\n        }\n        \n        // --- Terminal Functions (post-login) ---\n        function initializeTerminal() {\n            initTitleTypewriter();\n            initializeNLU();\n            loadHistory();\n            displayInitialMessages();\n            updateClock();\n            setInterval(updateClock, 1000);\n            setupTerminalInputListeners();\n            updatePrompt();\n\n            (async () => {\n                isTyping = true;\n                cursor.style.display = 'none';\n                if (!localStorage.getItem('chatHistory')) {\n                    await displayMOTD();\n                }\n                isTyping = false;\n                cursor.style.display = 'inline-block';\n                hiddenInput.focus();\n                scrollToBottom();\n            })();\n        }\n        \n        async function displayMOTD() {\n            const motdContent = `\n  ██╗      █████╗   ██████╗ ███████╗\n  ██║     ██╔══██╗ ██╔═══██╗██╔════╝\n  ██║     ███████║ ██║   ██║███████╗\n  ██║     ██╔══██║ ██║   ██║╚════██║\n  ███████╗██║  ██║ ╚██████╔╝███████║\n  ╚══════╝╚═╝  ╚═╝  ╚═════╝ ╚══════╝\n                                     \nBenvenuto in L.A.O.S. v8.3 (Lorel Axun Operating System)\n* La sessione è salvata. Usa 'clear' per iniziare una nuova sessione pulita.\n* Digita 'help' per una lista completa dei comandi disponibili.\n`;\n            await printSystemOutput(motdContent);\n        }\n\n        function updatePrompt() {\n             const homeDir = `/home/${currentUser}`:\n             let displayCwd = cwd;\n             if (cwd.startsWith(homeDir)) {\n                 displayCwd = '~' + cwd.substring(homeDir.length);\n             }\n             prompt.innerHTML = `<span style=\"color: var(--cmd-highlight)\">${currentUser}@lorel:</span><span style=\"color: var(--dir-blue)\">${displayCwd}</span>$ `;\n        }\n\n        function setupTerminalInputListeners() {\n            hiddenInput.addEventListener('input', () => {\n                playKeySound();\n                updateCommandLine();\n                updateAutocompleteSuggestion();\n            });\n\n            inputForm.addEventListener('submit', async (e) => {\n                e.preventDefault();\n                if (isTyping) return;\n\n                prompt.classList.remove('listening');\n                autocompleteSuggestion.textContent = '';\n                const userInput = hiddenInput.value.trim();\n                if (userInput) {\n                    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {\n                        commandHistory.push(userInput);\n                        localStorage.setItem('commandHistory', JSON.stringify(commandHistory));\n                    }\n                    historyIndex = commandHistory.length;\n                    hiddenInput.value = '';\n                    commandLine.textContent = '';\n\n                    isTyping = true;\n                    cursor.style.display = 'none';\n                    \n                    const analysis = analyzeInput(userInput);\n                    addUserMessage(analysis.highlightedInput, true);\n                    await processCommandFromInput(analysis.command);\n                    saveChatHistory();\n\n                    if (parseCommand(userInput).command !== 'reboot') {\n                        isTyping = false;\n                        cursor.style.display = 'inline-block';\n                        updatePrompt();\n                        hiddenInput.focus();\n                    }\n                    scrollToBottom();\n                }\n            });\n\n            hiddenInput.addEventListener('keydown', async function (e) {\n                if (isTyping) return;\n\n                const key = e.key;\n\n                clearTimeout(activityTimeout);\n                prompt.classList.add('listening');\n                activityTimeout = setTimeout(() => {\n                    prompt.classList.remove('listening');\n                }, 1500);\n\n                if (key === 'ArrowUp') {\n                    e.preventDefault();\n                    if (historyIndex > 0) {\n                        historyIndex--;\n                        hiddenInput.value = commandHistory[historyIndex];\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    }\n                } else if (key === 'ArrowDown') {\n                    e.preventDefault();\n                    if (historyIndex < commandHistory.length - 1) {\n                        historyIndex++;\n                        hiddenInput.value = commandHistory[historyIndex];\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    } else {\n                        historyIndex = commandHistory.length;\n                        hiddenInput.value = '';\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    }\n                } else if (key === 'Tab' || key === 'ArrowRight') {\n                    if(autocompleteSuggestion.textContent && hiddenInput.selectionStart === hiddenInput.value.length) {\n                        e.preventDefault();\n                        hiddenInput.value += autocompleteSuggestion.textContent;\n                        hiddenInput.dispatchEvent(new Event('input'));\n                    } else if (key === 'Tab') {\n                       e.preventDefault();\n                       await handleLegacyAutocomplete();\n                    }\n                } else if (key === 'Backspace') {\n                     playKeySound();\n                }\n            });\n        }\n\n        function updateCommandLine() {\n            const inputText = hiddenInput.value;\n            const parts = inputText.split(' ');\n            const command = parts[0].toLowerCase();\n            \n            if (availableCommands.includes(command) && parts[0] !== '') {\n                const remainingText = escapeHtml(parts.slice(1).join(' '));\n                commandLine.innerHTML = `<span class=\"command-known\">${escapeHtml(parts[0])}</span> ${remainingText}`;\n            } else {\n                commandLine.textContent = inputText;\n            }\n        }\n        \n        function updateAutocompleteSuggestion() {\n            const currentInput = hiddenInput.value;\n            if (currentInput.includes(' ') || currentInput.length === 0) {\n                autocompleteSuggestion.textContent = '';\n                return;\n            }\n            \n            const matches = availableCommands.filter(cmd => cmd.startsWith(currentInput));\n            \n            if (matches.length === 1 && matches[0] !== currentInput) {\n                autocompleteSuggestion.textContent = matches[0].substring(currentInput.length);\n            } else {\n                autocompleteSuggestion.textContent = '';\n            }\n        }\n\n        function resolvePath(path) {\n            if (!path) return cwd;\n            const homeDir = `/home/${currentUser}`:\n            if (path === '~') path = homeDir;\n            if (path.startsWith('~/')) path = `${homeDir}/${path.substring(2)}`;\n            \n            const newPathParts = path.startsWith('/') ? [] : cwd.split('/').filter(p => p);\n            const pathParts = path.split('/').filter(p => p);\n            \n            for (const part of pathParts) {\n                if (part === '.') continue;\n                if (part === '..') {\n                    if (newPathParts.length > 0) newPathParts.pop();\n                } else {\n                    newPathParts.push(part);\n                }\n            }\n            return '/' + newPathParts.join('/');\n        }\n\n        function escapeHtml(text) { return text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\"); }\n        function analyzeInput(input) { const intent = classifier.classify(input); if (intent !== 'unknown') { const entity = nerManager.extractEntities(input, intent); if (entity) { const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`); const command = `${intent} ${entity.value}`; return { command, highlightedInput }; } return { command: intent, highlightedInput: input }; } return { command: input, highlightedInput: input }; }\n        async function handleLegacyAutocomplete() { const currentInput = hiddenInput.value; const parts = currentInput.split(' '); const lastPart = parts[parts.length - 1]; if (parts.length === 1 && lastPart.length > 0) { const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart)); if (matches.length > 1) { await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`); } return; } }\n        \n        function parseCommandWithRedirection(input) {\n            let redirect = null;\n            let commandStr = input;\n\n            const appendMatch = input.match(/(.*)>>\\s*(.+)$/);\n            if (appendMatch) {\n                commandStr = appendMatch[1].trim();\n                redirect = { operator: '>>', target: appendMatch[2].trim() };\n            } else {\n                const overwriteMatch = input.match(/(.*)>\\s*(.+)$/);\n                if (overwriteMatch) {\n                    commandStr = overwriteMatch[1].trim();\n                    redirect = { operator: '>', target: overwriteMatch[2].trim() };\n                }\n            }\n            return { commandStr, redirect };\n        }\n\n        function parseCommand(input) { const regex = /[^\\s\"']+|\"([^\"]*)\"|'([^']*)'/g; const tokens = []; let match; do { match = regex.exec(input); if (match !== null) { tokens.push(match[1] || match[2] || match[0]); } } while (match !== null); const command = tokens[0] ? tokens[0].toLowerCase() : ''; const args = []; const flags = {}; for (let i = 1; i < tokens.length; i++) { const token = tokens[i]; if (token.startsWith('--')) { const flagName = token.substring(2); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else if (token.startsWith('-')) { const flagName = token.substring(1); const nextToken = tokens[i + 1]; if (nextToken && !nextToken.startsWith('-')) { flags[flagName] = nextToken; i++; } else { flags[flagName] = true; } } else { args.push(token); } } return { command, args, flags }; }\n        function createAsciiTable(headers, data) { const colWidths = headers.map((header, i) => { return Math.max(header.length, ...data.map(row => String(row[i]).length)); }); const separator = '+' + colWidths.map(w => '-'.repeat(w + 2)).join('+') + '+'; let table = separator + '\\n'; table += '|' + headers.map((h, i) => ` ${h.padEnd(colWidths[i])} `).join('|') + '|\\n'; table += separator + '\\n'; data.forEach(row => { table += '|' + row.map((cell, i) => ` ${String(cell).padEnd(colWidths[i])} `).join('|') + '|\\n'; }); table += separator; return table; }\n\n        async function processCommandFromInput(userInput) {\n            const { commandStr, redirect } = parseCommandWithRedirection(userInput);\n            const parsed = parseCommand(commandStr);\n\n            let outputBuffer = null;\n            let isHtmlOutput = false;\n\n            switch (parsed.command) {\n                case 'help':\n                    outputBuffer = `Comandi disponibili:\\n` +\n                                   `  help              - Mostra questa lista di comandi.\\n` +\n                                   `  status            - Mostra lo stato attuale del sistema.\\n` +\n                                   `  sysinfo           - Mostra informazioni di sistema in una tabella.\\n` +\n                                   `  neofetch          - Mostra info di sistema con logo ASCII.\\n` +\n                                   `  date              - Mostra data e ora correnti.\\n` +\n                                   `  whoami            - Mostra l'utente attualmente loggato.\\n` +\n                                   `  news [--limit N]  - Recupera N notizie (default 3).\\n` +\n                                   `  weather <città>   - Mostra il meteo per una città.\\n` +\n                                   `  wiki <termine>    - Cerca un termine su Wikipedia.\\n` +\n                                   `  stats             - Mostra un grafico ASCII di dati simulati.\\n` +\n                                   `  sentiment <testo> - Analizza il sentiment di una frase (ENG).\\n` +\n                                   `  generate <prompt> - Genera testo a partire da un prompt (ENG).\\n` +\n                                   `  echo <testo>      - Ripete il testo fornito.\\n` +\n                                   `  clear             - Pulisce lo schermo del terminale.\\n` +\n                                   `  reboot            - Simula un riavvio dell'interfaccia.\\n\\n` +\n                                   `File System & Scripting:\\n` +\n                                   `  ls [percorso]     - Lista i contenuti di una directory.\\n` +\n                                   `  cd <directory>    - Cambia la directory corrente.\\n` +\n                                   `  cat <file>        - Mostra il contenuto di un file.\\n` +\n                                   `  pwd               - Mostra la directory corrente.\\n` +\n                                   `  mkdir <nome>      - Crea una nuova directory.\\n` +\n                                   `  touch <nome>      - Crea un nuovo file vuoto.\\n` +\n                                   `  rm [-r] <nome>    - Rimuove un file o una directory.\\n` +\n                                   `  run <file.js>     - Esegue uno script JavaScript dal file system.\\n\\n` +\n                                   `I/O Redirection:\\n` +\n                                   `  > <file>          - Scrive l'output di un comando in un file (sovrascrive).\\n` +\n                                   `  >> <file>         - Aggiunge l'output di un comando a un file.\\n` +\n                                   `  (es. echo \"Ciao\" > note.txt)`;\n                    break;\n                case 'status':\n                    outputBuffer = 'STATUS: ONLINE. Version: 8.3. All systems nominal. User: ' + currentUser;\n                    break;\n                case 'sysinfo':\n                    const headers = ['Property', 'Value'];\n                    const tableData = [\n                        ['Version', '8.3 - Scripting Engine'],\n                        ['Creator', 'AleXsjsju'],\n                        ['Created', '2025-11-22'],\n                        ['Status', 'ONLINE'],\n                        ['Logged User', currentUser],\n                        ['Modules', 'Transformers.js, Scripting Engine']\n                    ];\n                    outputBuffer = createAsciiTable(headers, tableData);\n                    break;\n                case 'neofetch':\n                    const logoLines = ['██╗      █████╗', '██║     ██╔══██╗', '██║     ███████║', '██║     ██╔══██║', '███████╗██║  ██║', '╚══════╝╚═╝  ╚═╝', ''];\n                    const labelColor = 'var(--term-dim)';\n                    const valueColor = 'var(--term-green)';\n                    const uptimeMins = Math.floor(performance.now() / 60000); \n                    const uptimeString = `${uptimeMins} mins`;\n                    const infoLines = [\n                        `<span style=\"color: ${valueColor};\">${currentUser}@lorel</span>`,\n                        '------------------',\n                        `<span style=\"color: ${labelColor};\">OS</span>: L.A.O.S. v8.3 Scripting Engine`,\n                        `<span style=\"color: ${labelColor};\">Host</span>: Simulated Web Environment`,\n                        `<span style=\"color: ${labelColor};\">Kernel</span>: JS-DOM v11.25`,\n                        `<span style=\"color: ${labelColor};\">Uptime</span>: ${uptimeString}`,\n                        `<span style=\"color: ${labelColor};\">Shell</span>: LAX-Shell 1.3`,\n                    ];\n                    const logoWidth = 24;\n                    let output = '';\n                    const maxLines = Math.max(logoLines.length, infoLines.length);\n                    for (let i = 0; i < maxLines; i++) {\n                        const logoLine = (logoLines[i] || '').padEnd(logoWidth, ' ');\n                        const infoLine = infoLines[i] || '';\n                        output += `<span style=\"color: var(--cmd-highlight);\">${logoLine}</span>${infoLine}\\n`;\n                    }\n                    outputBuffer = '<pre>' + output + '</pre>';\n                    isHtmlOutput = true;\n                    break;\n                case 'whoami': outputBuffer = currentUser; break;\n                case 'pwd': outputBuffer = cwd; break;\n                case 'date': outputBuffer = new Date().toLocaleString('it-IT'); break;\n                case 'clear': history.innerHTML = ''; localStorage.removeItem('chatHistory'); break;\n                case 'reboot': await runRebootSequence(); break;\n                case 'echo': outputBuffer = parsed.args.length > 0 ? parsed.args.join(' ') : ''; break;\n                case 'news': outputBuffer = await fetchNews(parsed.flags.limit || 3); break;\n                case 'weather': if (parsed.args.length === 0) { outputBuffer = 'Uso: weather <città> o chiedi \"che tempo fa a <città>?\"'; } else { outputBuffer = await fetchWeather(parsed.args.join(' ')); } break;\n                case 'wiki': if (parsed.args.length === 0) { outputBuffer = 'Uso: wiki <termine da cercare> o chiedi \"cosa è <termine>?\"'; } else { outputBuffer = await fetchWikipedia(parsed.args.join(' ')); } break;\n                case 'sentiment': \n                    if (parsed.args.length === 0) {\n                        outputBuffer = 'Uso: sentiment <testo da analizzare in inglese>';\n                    } else {\n                        outputBuffer = await analyzeSentiment(parsed.args.join(' '));\n                    }\n                    break;\n                case 'generate': \n                    if (parsed.args.length === 0) {\n                        outputBuffer = 'Uso: generate <testo iniziale in inglese>';\n                    } else {\n                        outputBuffer = await generateText(parsed.args.join(' '));\n                    }\n                    break;\n                case 'ls': {\n                    const path = resolvePath(parsed.args[0]);\n                    const node = fileSystem[path];\n                    if (node && node.type === 'dir') {\n                        let output = '';\n                        node.children.forEach(childName => {\n                            const childPath = (path === '/' ? '' : path) + '/' + childName;\n                            const childNode = fileSystem[childPath];\n                            if (childNode.type === 'dir') {\n                                output += `<span class=\"fs-dir\">${childName}/</span>  `;\n                            } else {\n                                output += `${childName}  `;\n                            }\n                        });\n                        outputBuffer = output.trim();\n                        isHtmlOutput = true;\n                    } else {\n                        outputBuffer = `ls: cannot access '${parsed.args[0] || '.'}': No such file or directory`;\n                    }\n                    break;\n                }\n                case 'cd': {\n                    if (!parsed.args[0]) { \n                        cwd = `/home/${currentUser}`:\n                        break;\n                    } \n                    const path = resolvePath(parsed.args[0]);\n                    const node = fileSystem[path];\n                    if (node && node.type === 'dir') {\n                        cwd = path;\n                    } else {\n                        outputBuffer = `cd: no such file or directory: ${parsed.args[0}`;\n                    }\n                    break;\n                }\n                case 'cat': {\n                    if (parsed.args.length === 0) {\n                        outputBuffer = `cat: missing operand`;\n                        break;\n                    }\n                    const path = resolvePath(parsed.args[0]);\n                    const node = fileSystem[path];\n                    if (node && node.type === 'file') {\n                        await printSystemOutput(node.content);\n                        outputBuffer = null;\n                    } else if (node && node.type === 'dir') {\n                        outputBuffer = `cat: ${parsed.args[0]}: Is a directory`;\n                    } else {\n                        outputBuffer = `cat: ${parsed.args[0]}: No such file or directory`;\n                    }\n                    break;\n                }\n                 case 'mkdir': {\n                    if (parsed.args.length === 0) {\n                        outputBuffer = `mkdir: missing operand`;\n                        break;\n                    }\n                    const newDirName = parsed.args[0];\n                    if (newDirName.includes('/')) {\n                        outputBuffer = `mkdir: cannot create directory '${newDirName}': Invalid name`;\n                        break;\n                    }\n                    const parentPath = cwd;\n                    const newDirPath = resolvePath(`${parentPath}/${newDirName}`);\n                    \n                    if (fileSystem[newDirPath]) {\n                        outputBuffer = `mkdir: cannot create directory '${newDirName}': File exists`;\n                        break;\n                    }\n\n                    const parentNode = fileSystem[parentPath];\n                    if (parentNode && parentNode.type === 'dir') {\n                        parentNode.children.push(newDirName);\n                        parentNode.children.sort();\n                        fileSystem[newDirPath] = { type: 'dir', children: [] };\n                    } else {\n                         outputBuffer = `mkdir: fatal error in path resolution`;\n                    }\n                    break;\n                }\n                case 'touch': {\n                    if (parsed.args.length === 0) {\n                        outputBuffer = `touch: missing file operand`;\n                        break;\n                    }\n                    const newFileName = parsed.args[0];\n                     if (newFileName.includes('/')) {\n                        outputBuffer = `touch: cannot create file '${newFileName}': Invalid name`;\n                        break;\n                    }\n                    const parentPath = cwd;\n                    const newFilePath = resolvePath(`${parentPath}/${newFileName}`);\n\n                    if (fileSystem[newFilePath]) { break; } \n\n                    const parentNode = fileSystem[parentPath];\n                    if (parentNode && parentNode.type === 'dir') {\n                        parentNode.children.push(newFileName);\n                        parentNode.children.sort();\n                        fileSystem[newFilePath] = { type: 'file', content: '' };\n                    } else {\n                        outputBuffer = `touch: fatal error in path resolution`;\n                    }\n                    break;\n                }\n                case 'rm': {\n                    if (parsed.args.length === 0) {\n                        outputBuffer = `rm: missing operand`;\n                        break;\n                    }\n                    const targetName = parsed.args[0];\n                    const targetPath = resolvePath(targetName);\n                    const targetNode = fileSystem[targetPath];\n\n                    if (!targetNode) {\n                        outputBuffer = `rm: cannot remove '${targetName}': No such file or directory`;\n                        break;\n                    }\n\n                    const parentPath = resolvePath(targetPath + '/..');\n                    const parentNode = fileSystem[parentPath];\n                    const isRecursive = parsed.flags.r || parsed.flags.recursive;\n\n                    if (targetNode.type === 'dir' && targetNode.children.length > 0 && !isRecursive) {\n                        outputBuffer = `rm: cannot remove '${targetName}': Directory not empty`;\n                        break;\n                    }\n                    function deleteRecursively(path) {\n                        const node = fileSystem[path];\n                        if (node.type === 'dir') {\n                            [...node.children].forEach(child => {\n                                deleteRecursively((path === '/' ? '' : path) + '/' + child);\n                            });\n                        }\n                        delete fileSystem[path];\n                    }\n                    if (isRecursive && targetNode.type === 'dir') {\n                        deleteRecursively(targetPath);\n                    } else {\n                        delete fileSystem[targetPath];\n                    }\n                    if (parentNode && parentNode.children) {\n                         const index = parentNode.children.indexOf(targetName.split('/').pop());\n                         if (index > -1) { parentNode.children.splice(index, 1); }\n                    }\n                    break;\n                }\n                 case 'run': {\n                    if (parsed.args.length === 0) {\n                        outputBuffer = `run: missing file operand`;\n                        break;\n                    }\n                    const filePath = resolvePath(parsed.args[0]);\n                    const fileNode = fileSystem[filePath];\n                    if (!fileNode || fileNode.type !== 'file') {\n                        outputBuffer = `run: cannot find script '${parsed.args[0]}': No such file or directory`;\n                        break;\n                    }\n                    await printSystemOutput(`[SYSTEM] Executing script: ${parsed.args[0]}`)\n                    try {\n                        // Sandbox the script with a limited API\n                        const sandboxedTerminal = {\n                           log: async (message) => {\n                                await printSystemOutput(String(message));\n                           }\n                        };\n                        const scriptFunction = new Function('terminal', fileNode.content);\n                        await scriptFunction(sandboxedTerminal);\n                    } catch (e) {\n                        outputBuffer = `[SCRIPT ERROR] ${e.name}: ${e.message}`;\n                    }\n                    break;\n                }\n                case 'stats':\n                    let s = new Array(120).fill(0).map((_, i) => 15 * Math.sin(i * ((Math.PI * 4) / 120)));\n                    const chart = asciichart.plot(s, { height: 10 });\n                    outputBuffer = chart + '\\nChart depicts simulated CPU load over the last 60 seconds.';\n                    break;\n                default:\n                    outputBuffer = `Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`;\n                    break;\n            }\n\n            if (redirect) {\n                if (outputBuffer === null || outputBuffer.includes('Uso:')) {\n                    await typeLorelMessage(outputBuffer || 'Comando non produce output per la redirezione.');\n                    return;\n                }\n                const targetPath = resolvePath(redirect.target);\n                const parentPath = resolvePath(targetPath + '/..');\n                const parentNode = fileSystem[parentPath];\n                if (!parentNode || parentNode.type !== 'dir') {\n                    await typeLorelMessage(`bash: ${redirect.target}: No such file or directory`);\n                    return;\n                }\n                let targetNode = fileSystem[targetPath];\n                if (targetNode && targetNode.type === 'dir') {\n                    await typeLorelMessage(`bash: ${redirect.target}: Is a directory`);\n                    return;\n                }\n                if (redirect.operator === '>') {\n                     if (!targetNode) {\n                        parentNode.children.push(targetPath.split('/').pop());\n                        parentNode.children.sort();\n                     }\n                     fileSystem[targetPath] = { type: 'file', content: outputBuffer.replace(/<[^>]*>/g, '') }; // Strip HTML for files\n                } else if (redirect.operator === '>>') {\n                    if (!targetNode) {\n                        parentNode.children.push(targetPath.split('/').pop());\n                        parentNode.children.sort();\n                        fileSystem[targetPath] = { type: 'file', content: outputBuffer.replace(/<[^>]*>/g, '') };\n                    } else {\n                        fileSystem[targetPath].content += '\\n' + outputBuffer.replace(/<[^>]*>/g, '');\n                    }\n                }\n            } else if (outputBuffer !== null) {\n                 if (['sysinfo', 'stats', 'help', 'sentiment', 'generate'].includes(parsed.command)) {\n                    await printSystemOutput(outputBuffer);\n                 } else if (isHtmlOutput) {\n                    addLorelMessage(outputBuffer, true);\n                 } else {\n                    await typeLorelMessage(outputBuffer);\n                 }\n            }\n        }\n\n        async function runRebootSequence() {\n            await typeLorelMessage(\"[SYSTEM] Reboot sequence initiated... Shutting down.\");\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            mainScreen.style.opacity = '0';\n            monitorBezel.style.display = 'none';\n            await new Promise(resolve => setTimeout(resolve, 500));\n\n            biosOverlay.style.display = 'flex';\n            const biosLines = [ { text: 'LorelAxun BIOS v1.2', delay: 500 }, { text: 'Copyright (c) 2025 AleXsjsju Corp.', delay: 200 }, { text: '', delay: 500 }, { text: 'Initializing Core Memory.................... ', delay: 300 }, { text: '65536 KB OK', delay: 100, append: true, action: playBiosBeep }, { text: '\\nDetecting Primary Master.................. LAX-HD-01', delay: 800 }, { text: 'Detecting Primary Slave................. None', delay: 800 }, { text: 'Detecting Secondary Master................ None', delay: 800 }, { text: 'Detecting Secondary Slave................. None', delay: 800 }, { text: '', delay: 500 }, { text: 'Checking NVRAM............................ OK', delay: 400 }, { text: 'Initializing Web-Access Layer........... OK', delay: 600 }, { text: '', delay: 1000 }, { text: 'Booting from Primary Master (LAX-HD-01)...', delay: 500 }, ];\n            for (const line of biosLines) { await new Promise(resolve => setTimeout(resolve, line.delay)); if (line.append) { biosOverlay.textContent += line.text; } else { biosOverlay.textContent += line.text + '\\n'; } if (line.action) { await line.action(); } }\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            biosOverlay.style.display = 'none';\n            biosOverlay.textContent = '';\n\n            const logo = `\\n██╗      █████╗\\n██║     ██╔══██╗\\n██║     ███████║\\n██║     ██╔══██║\\n███████╗██║  ██║\\n╚══════╝╚═╝  ╚═╝\\n            `;\n            bootLogoOverlay.innerHTML = `<pre>${escapeHtml(logo)}</pre>`;\n            bootLogoOverlay.style.display = 'flex';\n            playSound('startup-sound');\n            await new Promise(resolve => setTimeout(resolve, 3500));\n            bootLogoOverlay.style.display = 'none';\n            bootLogoOverlay.innerHTML = '';\n\n            initLoginScreen();\n        }\n\n        async function analyzeSentiment(text) {\n            try {\n                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');\n\n                if (!sentimentPipeline) {\n                    await printSystemOutput('Loading sentiment analysis model (this may take a moment on first run)...');\n                    sentimentPipeline = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finetuned-sst-2-english');\n                    await printSystemOutput('Model loaded successfully.');\n                }\n                await printSystemOutput(`Analyzing text: \\\"${text}\\\"`);\n                const result = await sentimentPipeline(text);\n                return `Analysis complete:\\n` +\n                    `  - LABEL: ${result[0].label}\\n` +\n                    `  - SCORE: ${result[0].score.toFixed(4)}`;\n            } catch (error) {\n                console.error('Sentiment Analysis Error:', error);\n                return 'Error during sentiment analysis. The model may have failed to load. Check the browser console.';\n            }\n        }\n\n        async function generateText(prompt) {\n            try {\n                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');\n\n                if (!textGenerationPipeline) {\n                    await printSystemOutput('Loading text generation model (this may take a moment on first run)...');\n                    textGenerationPipeline = await pipeline('text-generation', 'Xenova/distilgpt2');\n                    await printSystemOutput('Model loaded successfully.');\n                }\n                await printSystemOutput(`Generating text from prompt: \\\"${prompt}\\\"`);\n                const result = await textGenerationPipeline(prompt, { max_new_tokens: 50 });\n                return `Generation complete:\\n\\n${result[0].generated_text}`;\n            } catch (error) {\n                console.error('Text Generation Error:', error);\n                return 'Error during text generation. The model may have failed to load. Check the browser console.';\n            }\n        }\n\n        async function fetchWikipedia(term) { let output = `Ricerca su Wikipedia per \\\"${term}\\\"...`; try { const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`; const searchResponse = await fetch(searchUrl); if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`); const searchData = await searchResponse.json(); if (!searchData.query.search || searchData.query.search.length === 0) { throw new Error(`Nessun risultato trovato per \\\"${term}\\\".`); } const searchResults = searchData.query.search; if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) { let disambiguation = false; if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true; if(disambiguation || searchResults.length > 2) { let suggestionText = `\\nTrovati più risultati per \\\"${term}\\\". Essere più specifici:\\n`; searchResults.slice(0, 5).forEach(res => { suggestionText += `  - ${res.title}\\n`; }); suggestionText += `Esempio: wiki \\\"${searchResults[0].title}\\\"`; return output + suggestionText; } } const pageTitle = searchResults[0].title; output += `\\nTrovata pagina: \\\"${pageTitle}\\\".\\nRecupero riassunto...`; const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`; const summaryResponse = await fetch(summaryUrl); if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`); const summaryData = await summaryResponse.json(); const pages = summaryData.query.pages; const pageId = Object.keys(pages)[0]; const extract = pages[pageId].extract; if (extract) { return output + `\\n${extract}`; } else { throw new Error(`Nessun riassunto disponibile per \\\"${pageTitle}\\\".`); } } catch (error) { return output + `\\nErrore durante la ricerca su Wikipedia: ${error.message}`; } }\n        async function fetchWeather(city) { let output = `Ricerca coordinate per ${city}...`; try { const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`); if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`); const geoData = await geoResponse.json(); if (!geoData.results || geoData.results.length === 0) { throw new Error(`Località non trovata: ${city}`); } const uniqueLocations = []; const seen = new Set(); for (const loc of geoData.results) { const identifier = `${loc.name}, ${loc.admin1 || loc.country}`; if (!seen.has(identifier)) { uniqueLocations.push(loc); seen.add(identifier); } } let location; if (uniqueLocations.length > 1 && !city.includes(',')) { let suggestionText = `\\nTrovate più località per \\\"${city}\\\". Essere più specifici:\\n`; uniqueLocations.slice(0, 3).forEach(loc => { suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\\n`; }); suggestionText += `Esempio: weather \\\"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\\\"`; return output + suggestionText; } else { location = uniqueLocations[0]; } const { latitude, longitude, name, admin1, country_code } = location; const locationName = `${name}, ${admin1 || country_code}`; output += `\\nCoordinate trovate per ${locationName}.\\nRecupero dati meteo...`; const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`); if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`); const weatherData = await weatherResponse.json(); const { temperature, windspeed, weathercode } = weatherData.current_weather; const weatherDescription = getWeatherDescription(weathercode); return output + `\\nMeteo attuale per ${locationName}:\\n` + `  - Descrizione: ${weatherDescription}\\n` + `  - Temperatura: ${temperature}°C\\n` + `  - Vento: ${windspeed} km/h`; } catch (error) { return output + `\\nErrore durante il recupero del meteo: ${error.message}`; } }\n        function getWeatherDescription(code) { const descriptions = { 0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso', 45: 'Nebbia', 48: 'Nebbia con brina', 51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa', 61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte', 71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte', 80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento', 95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante' }; return descriptions[code] || 'Condizioni non specificate'; }\n        async function fetchNews(limit = 3) { let output = `Recupero ${limit} notizie dal web...`; try { const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); let newsHeadlines = '\\nUltime notizie recuperate:\\n'; data.forEach((article, index) => { const title = article.title.charAt(0).toUpperCase() + article.title.slice(1); newsHeadlines += `\\n[${index + 1}] ${title}`; }); return output + newsHeadlines; } catch (error) { return output + `\\nErrore durante il recupero delle notizie: ${error.message}`; } }\n        async function typeLorelMessage(text) { const messageDiv = document.createElement('div'); messageDiv.className = 'msg lorel'; history.appendChild(messageDiv); scrollToBottom(); const chunks = text.split('\\n'); for (let i = 0; i < chunks.length; i++) { const chunk = chunks[i]; if (i > 0) { messageDiv.innerText += '\\n'; const pauseDuration = 250 + Math.random() * 300; await new Promise(resolve => setTimeout(resolve, pauseDuration)); } for (let j = 0; j < chunk.length; j++) { const char = chunk.charAt(j); messageDiv.innerText += char; playKeySound(); scrollToBottom(); const speed = 30 + (Math.random() * 25); await new Promise(resolve => setTimeout(resolve, speed)); if (char === ',') { await new Promise(resolve => setTimeout(resolve, 250 + Math.random() * 100)); } else if (char === '.' || char === '!' || char === '?') { await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 150)); } } } saveChatHistory(); }\n        async function printSystemOutput(text) { const div = document.createElement('div'); div.className = 'msg lorel'; const pre = document.createElement('pre'); div.appendChild(pre); history.appendChild(div); scrollToBottom(); const lines = text.split('\\n'); for (const line of lines) { pre.textContent += line + '\\n'; scrollToBottom(); await new Promise(r => setTimeout(r, 50)); } saveChatHistory(); }\n        function addLorelMessage(text, isHtml = false) { const div = document.createElement('div'); div.className = 'msg lorel'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }\n        function addUserMessage(text, isHtml = false) { const div = document.createElement('div'); div.className = 'msg user'; if (isHtml) { div.innerHTML = text; } else { div.innerText = text; } history.appendChild(div); saveChatHistory(); scrollToBottom(); }\n        function saveChatHistory() { localStorage.setItem('chatHistory', history.innerHTML); }\n        function loadHistory() { const savedCommandHistory = localStorage.getItem('commandHistory'); if(savedCommandHistory) { commandHistory = JSON.parse(savedCommandHistory); historyIndex = commandHistory.length; } const savedChat = localStorage.getItem('chatHistory'); if (savedChat) { history.innerHTML = savedChat; } }\n        \n        function displayInitialMessages() {\n            const messages = [\n                '[SYSTEM] Initializing core memory... OK',\n                '[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span>',\n                '[UPDATE] Session persistence enabled via localStorage. History is now saved.',\n                '[AESTHETICS] Keystroke audio feedback enabled.',\n                '[SYSTEM] Advanced command parser implemented. Now supports quoted arguments and flags.',\n                '[AESTHETICS] Title animation upgraded to a dynamic, cyclical typewriter effect.',\n                '[OPTIMIZATION] Blinking cursor animation refined for code simplicity and efficiency.',\n                '[REFINEMENT] Typing speed now has random variations for a more organic feel.',\n                '[IMMERSION] Ambient static hum enabled for a complete CRT experience.',\n                '[REFINEMENT] Long responses are now streamed chunk-by-chunk for a more dynamic feel.',\n                '[AESTHETICS] Added chromatic aberration text animation for enhanced visual authenticity.',\n                '[AESTHETICS] Monitor bezel effect added to encapsulate the interface.',\n                '[AESTHETICS] Added moving scanline effect to simulate CRT refresh cycle.',\n                '[INTEGRATION] User input now handled by a robust, invisible `<input>` for improved compatibility.',\n                '[LEXICAL ANALYSIS] User command syntax is now highlighted in real-time for instant feedback.',\n                '[ASSISTANCE] Command autocompletion (Tab key) is now active for predictive input.',\n                '[VISUALIZATION] Data visualization enabled via ASCII charts. Try the \'stats\' command.',\n                '[VISUALIZATION] Data tabulation enabled via ASCII tables. Try the \'sysinfo\' command.',\n                `[REFINEMENT] Lorel's typing rhythm is now more natural, with conversational pauses.`,\n                `[AESTHETICS] 'ONLINE' status indicator is now animated with a pulsing glow effect.`,\n                `[ASSISTANCE] Inline command autocompletion suggestions ('ghost text') are now active.`,\n                `[SYSTEM] Reboot Protocol module loaded. Type 'reboot' to restart the interface.`,\n                '[IMMERSION] Reboot sequence now features a simulated BIOS POST screen with an audible beep.',\n                '[IMMERSION] Boot sequence upgraded with an animated ASCII logo and startup sound.',\n                '[SECURITY] System access now requires authentication via Login Protocol.',\n                `[SYSTEM] Session now user-aware. Prompt reflects logged-in user. Added 'whoami' command.`,\n                '[SYSTEM] Simulated file system is now active. Try commands: ls, cd, cat, pwd.',\n                '[SYSTEM] Identity module added. Try the new `neofetch` command for system info.',\n                '[REFINEMENT] Command output (help, stats) now streams line-by-line for greater immersion.',\n                '[INTERACTIVITY] File system is now writeable. Use `mkdir` and `touch` to create directories and files.',\n                '[DESTRUCTIVE] File system now supports deletion. Use `rm` to remove files and directories.',\n                '[SYSTEM] I/O Redirection enabled. Use > to write and >> to append command output to files.',\n                '[SYSTEM] File content access enabled. Use `cat` to display the contents of files.',\n                `[IMMERSION] System command output now uses a mechanical 'print' effect, distinct from Lorel's conversational typing.`,\n                `[AI CORE] Transformers.js library integrated. New 'sentiment' command available for testing.`,\n                `[AI CORE] Text generation pipeline integrated. Use the 'generate' command to create text.`,\n                `[IMMERSION] System now displays a 'Message of the Day' (MOTD) on first login.`,\n                `[DEVELOPMENT] Internal scripting engine loaded. Use the 'run' command to execute JavaScript files.`,\n            ];\n            let content = '';\n            messages.forEach(msg => {\n                content += `<div class=\"sys-msg\">${msg}</div>`;\n            });\n            initialMessagesContainer.innerHTML = content;\n        }\n\n        function scrollToBottom() { terminalContainer.scrollTop = terminalContainer.scrollHeight; }\n        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('it-IT'); clock.textContent = timeString; }\n        \n        window.onload = () => {\n            initializeGlobalListeners();\n            initLoginScreen();\n        }\n\n    </script>\n</body>\n</html>