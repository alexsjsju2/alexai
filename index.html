<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>LOREL AXUN V4.6 // CODE REFINEMENT</title>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=VT323&display=swap\" rel=\"stylesheet\">\n    <style>\n        :root {\n            --bg-color: #0a0a0a;\n            --term-green: #33ff00;\n            --term-dim: #1a8000;\n            --term-glow: #33ff0080;\n        }\n        html, body {\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n        }\n        body {\n            background-color: var(--bg-color);\n            color: var(--term-green);\n            font-family: 'VT323', monospace;\n            display: flex;\n            flex-direction: column;\n            font-size: 1.2rem;\n        }\n        /* CRT Effect Overlay */\n        .crt::before {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));\n            z-index: 2;\n            background-size: 100% 2px, 3px 100%;\n            pointer-events: none;\n        }\n        .crt::after {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: rgba(18, 16, 16, 0.1);\n            opacity: 0;\n            z-index: 2;\n            pointer-events: none;\n            animation: flicker 0.15s infinite;\n        }\n        @keyframes flicker {\n            0% { opacity: 0.02795; } 5% { opacity: 0.04853; } 10% { opacity: 0.01701; } 15% { opacity: 0.04272; } 20% { opacity: 0.01297; } 25% { opacity: 0.03961; } 30% { opacity: 0.01826; } 35% { opacity: 0.04932; } 40% { opacity: 0.01543; } 45% { opacity: 0.04348; } 50% { opacity: 0.02146; } 55% { opacity: 0.04884; } 60% { opacity: 0.01921; } 65% { opacity: 0.04176; } 70% { opacity: 0.01439; } 75% { opacity: 0.04695; } 80% { opacity: 0.02363; } 85% { opacity: 0.04141; } 90% { opacity: 0.01717; } 95% { opacity: 0.04719; } 100% { opacity: 0.02322; }\n        }\n        \n        .terminal-container {\n            padding: 20px;\n            flex: 1;\n            overflow-y: auto;\n            max-width: 1000px;\n            margin: 0 auto;\n            width: 100%;\n            box-sizing: border-box;\n            text-shadow: 0 0 5px var(--term-glow);\n            display: flex;\n            flex-direction: column;\n        }\n\n        h1 {\n            border-bottom: 2px solid var(--term-green);\n            padding-bottom: 10px;\n            margin-bottom: 20px;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n        }\n\n        .typewriter {\n            display: inline-block;\n            overflow: hidden;\n            white-space: nowrap;\n            border-right: 3px solid var(--term-green);\n            width: 0;\n            animation: typing 2s steps(16) forwards,\n                       blink-border .75s step-end infinite;\n        }\n\n        @keyframes typing {\n            from { width: 0; }\n            to { width: 16ch; } /* Length of \"Lorel Axun v4.6\" */\n        }\n\n        @keyframes blink-border {\n            0%, 100% { border-color: var(--term-green); }\n            50% { border-color: transparent; }\n        }\n\n        .sys-msg { color: var(--term-dim); margin-bottom: 10px; }\n        .sys-msg span { color: var(--term-green); font-weight: bold; }\n\n        .chat-history { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1;}\n\n        .msg { line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; }\n        .msg.lorel::before { content: \"LOREL_SYS>> \"; color: var(--term-green); }\n        .msg.user::before { content: \"USER_INPUT>> \"; color: #00ffff; }\n        .msg.user { color: #ccffff; }\n\n        mark {\n            background-color: var(--term-dim);\n            color: var(--term-green);\n            text-shadow: none;\n            padding: 0 3px;\n        }\n\n        .input-line { display: flex; align-items: center; border-top: 1px solid var(--term-dim); padding-top: 15px;}\n        .prompt { margin-right: 10px; color: var(--term-green); transition: color 0.3s; }\n        .prompt.listening::after {\n            content: '_';\n            animation: blink 0.8s step-end infinite;\n            padding-left: 5px;\n            color: var(--term-dim);\n        }\n        \n        #command-line {\n            outline: none;\n        }\n        #cursor {\n            background: var(--term-green);\n            display: inline-block;\n            width: 10px;\n            height: 1.2rem;\n            animation: blink 1s step-end infinite;\n            box-shadow: 0 0 5px var(--term-glow);\n            vertical-align: middle;\n        }\n        @keyframes blink {\n            0%, 100% { opacity: 1; }\n            50% { opacity: 0; }\n        }\n\n        .typing-indicator {\n            display: inline-flex;\n            align-items: center;\n            height: 1.2rem;\n        }\n        .typing-indicator span {\n            height: 8px;\n            width: 8px;\n            background-color: var(--term-dim);\n            border-radius: 50%;\n            display: inline-block;\n            margin: 0 2px;\n            animation: bounce 1.4s infinite ease-in-out both;\n            box-shadow: 0 0 3px var(--term-glow);\n        }\n        .typing-indicator span:nth-child(1) {\n            animation-delay: -0.32s;\n        }\n        .typing-indicator span:nth-child(2) {\n            animation-delay: -0.16s;\n        }\n        @keyframes bounce {\n            0%, 80%, 100% { transform: scale(0); }\n            40% { transform: scale(1.0); }\n        }\n        \n        /* Scrollbar styling */\n        ::-webkit-scrollbar { width: 10px; }\n        ::-webkit-scrollbar-track { background: #000; }\n        ::-webkit-scrollbar-thumb { background: var(--term-dim); border: 1px solid var(--term-green); }\n\n        .glitch {\n            position: relative;\n        }\n        .glitch::before, .glitch::after {\n            content: attr(data-text);\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: var(--bg-color);\n        }\n        .glitch::before {\n            left: 2px;\n            text-shadow: -2px 0 #ff00c1;\n            clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);\n            animation: glitch-anim-2 2.5s infinite steps(8) reverse;\n        }\n        .glitch::after {\n            left: -2px;\n            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;\n            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);\n            animation: glitch-anim-2 2.5s infinite steps(8);\n        }\n        @keyframes glitch-anim-2 {\n            0% { clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%); } 5% { clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%); } 10% { clip-path: polygon(0 15%, 100% 15%, 100% 20%, 0 20%); } 15% { clip-path: polygon(0 80%, 100% 80%, 100% 85%, 0 85%); } 20% { clip-path: polygon(0 55%, 100% 55%, 100% 60%, 0 60%); } 25% { clip-path: polygon(0 5%, 100% 5%, 100% 10%, 0 10%); } 30% { clip-path: polygon(0 90%, 100% 90%, 100% 95%, 0 95%); } 35% { clip-path: polygon(0 30%, 100% 30%, 100% 35%, 0 35%); } 40% { clip-path: polygon(0 70%, 100% 70%, 100% 75%, 0 75%); } 45% { clip-path: polygon(0 40%, 100% 40%, 100% 45%, 0 45%); } 50% { clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%); } 55% { clip-path: polygon(0 0, 100% 0, 100% 5%, 0 5%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 100% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); }\n        }\n\n        .status-bar {\n            background-color: var(--term-green);\n            color: var(--bg-color);\n            padding: 2px 10px;\n            width: 100%;\n            box-sizing: border-box;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            font-size: 1rem;\n            height: 25px;\n        }\n        .status-bar span {\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body class=\"crt\">\n    <div class=\"terminal-container\" id=\"terminal-container\">\n        <h1 class=\"glitch\" data-text=\"Lorel Axun v4.6\"><span class=\"typewriter\">Lorel Axun v4.6</span></h1>\n        \n        <div class=\"sys-msg\">[SYSTEM] Initializing core memory... OK</div>\n        <div class=\"sys-msg\">[NETWORK] Testing connection... <span style=\"color:var(--term-green)\">SUCCESS</span></div>\n        <div class=\"sys-msg\">[UPDATE] Session persistence enabled via localStorage. History is now saved.</div>\n        <div class=\"sys-msg\">[AESTHETICS] Title typewriter animation enabled.</div>\n        <div class=\"sys-msg\">[AESTHETICS] CRT scanline effect enabled for enhanced immersion.</div>\n        <div class=\"sys-msg\">[AESTHETICS] Keystroke audio feedback enabled.</div>\n        <div class=\"sys-msg\">[SYSTEM] CSS animation logic consolidated for improved consistency.</div>\n        \n        <div id=\"chat-history\" class=\"chat-history\"></div>\n\n        <div class=\"input-line\" id=\"input-line\">\n            <span class=\"prompt\">user@lorel:~$</span>\n            <span id=\"command-line\"></span><span id=\"cursor\"></span>\n        </div>\n    </div>\n    <div class=\"status-bar\">\n        <span>LOREL AXUN v4.6</span>\n        <span>STATUS: <span style=\"animation: blinker 1s linear infinite;\">ONLINE</span></span>\n        <span id=\"clock\"></span>\n    </div>\n\n    <script>\n        const history = document.getElementById('chat-history');\n        const commandLine = document.getElementById('command-line');\n        const terminalContainer = document.getElementById('terminal-container');\n        const cursor = document.getElementById('cursor');\n        const clock = document.getElementById('clock');\n        const prompt = document.querySelector('.prompt');\n\n        let isTyping = false;\n        let commandHistory = [];\n        let historyIndex = -1;\n        let activityTimeout;\n\n        const availableCommands = ['help', 'status', 'date', 'news', 'weather', 'wiki', 'echo', 'clear'];\n        const commandArgs = {};\n\n        // --- Audio Feedback Engine ---\n        const KEY_CLICK_SOUND = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA='; // A very short keyboard tick\n        const keySoundPoolSize = 5;\n        const keySoundPool = [];\n        let keySoundIndex = 0;\n\n        for (let i = 0; i < keySoundPoolSize; i++) {\n            keySoundPool.push(new Audio(KEY_CLICK_SOUND));\n        }\n\n        function playKeySound() {\n            const sound = keySoundPool[keySoundIndex];\n            sound.currentTime = 0;\n            sound.play().catch(e => { /* Ignore errors from rapid playback or browser policy */ });\n            keySoundIndex = (keySoundIndex + 1) % keySoundPoolSize;\n        }\n        // --- End Audio ---\n\n        // --- NLU Engine ---\n        const classifier = {\n            intents: {},\n            train: function(intent, phrases) {\n                if (!this.intents[intent]) this.intents[intent] = [];\n                phrases.forEach(phrase => this.intents[intent].push(this.tokenize(phrase)));\n            },\n            tokenize: text => text.toLowerCase().replace(/[^a-z0-9\\s]/gi, '').split(/\\s+/).filter(Boolean),\n            classify: function(text) {\n                const tokens = this.tokenize(text);\n                let bestMatch = { intent: 'unknown', score: 0 };\n                for (const intent in this.intents) {\n                    let intentScore = 0;\n                    this.intents[intent].forEach(phraseTokens => {\n                        const commonTokens = tokens.filter(token => phraseTokens.includes(token));\n                        const score = commonTokens.length / phraseTokens.length;\n                        if (score > intentScore) intentScore = score;\n                    });\n                    if (intentScore > bestMatch.score) {\n                        bestMatch = { intent, score: intentScore };\n                    }\n                }\n                return bestMatch.score > 0.4 ? bestMatch.intent : 'unknown'; // Confidence threshold\n            }\n        };\n\n        const nerManager = {\n            extractEntities: function(text, intent) {\n                if (intent === 'weather') {\n                    const match = text.match(/(?:a|per|di|a)\\s(.+)/i);\n                    if (match && match[1]) {\n                        const entityText = match[1].trim().replace('?','');\n                        return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'LOCATION' };\n                    }\n                } else if (intent === 'wiki') {\n                    const match = text.match(/(?:è|e'|di|su)\\s(.+)/i);\n                     if (match && match[1]) {\n                        const entityText = match[1].trim().replace('?','');\n                        return { value: `\\\"${entityText}\\\"`, text: entityText, type: 'TOPIC' };\n                     }\n                }\n                return null; // No entity found\n            }\n        };\n\n        function initializeNLU() {\n            classifier.train('weather', ['che tempo fa a', 'meteo per', 'previsioni del tempo a']);\n            classifier.train('date', ['che giorno è', 'dimmi la data', 'che ore sono', 'data e ora']);\n            classifier.train('news', ['ultime notizie', 'dammi le news', 'leggi le notizie']);\n            classifier.train('help', ['aiuto', 'mostrami i comandi', 'cosa posso fare']);\n            classifier.train('wiki', ['cerca su wikipedia', 'cosa è', 'chi è', 'dimmi di']);\n        }\n        // --- End NLU ---\n\n        document.addEventListener('keydown', async function (e) {\n            if (isTyping) return;\n            const key = e.key;\n\n            clearTimeout(activityTimeout);\n            if (key !== 'Enter') {\n                prompt.classList.add('listening');\n                activityTimeout = setTimeout(() => {\n                    prompt.classList.remove('listening');\n                }, 1500);\n            }\n\n            if (key === 'Enter') {\n                e.preventDefault();\n                prompt.classList.remove('listening');\n                const userInput = commandLine.textContent.trim();\n                if (userInput) {\n                    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== userInput) {\n                         commandHistory.push(userInput);\n                         localStorage.setItem('commandHistory', JSON.stringify(commandHistory));\n                    }\n                    historyIndex = commandHistory.length;\n                    commandLine.textContent = '';\n                    isTyping = true;\n                    cursor.style.display = 'none';\n                    \n                    const analysis = analyzeInput(userInput);\n                    addUserMessage(analysis.highlightedInput, true);\n                    await processCommand(analysis.command);\n                    saveChatHistory();\n\n                    isTyping = false;\n                    cursor.style.display = 'inline-block';\n                    scrollToBottom();\n                }\n            } else if (key === 'Backspace') {\n                e.preventDefault();\n                commandLine.textContent = commandLine.textContent.slice(0, -1);\n                playKeySound();\n            } else if (key === 'ArrowUp') {\n                e.preventDefault();\n                if (historyIndex > 0) {\n                    historyIndex--;\n                    commandLine.textContent = commandHistory[historyIndex];\n                }\n            } else if (key === 'ArrowDown') {\n                e.preventDefault();\n                if (historyIndex < commandHistory.length - 1) {\n                    historyIndex++;\n                    commandLine.textContent = commandHistory[historyIndex];\n                } else {\n                    historyIndex = commandHistory.length;\n                    commandLine.textContent = '';\n                }\n            } else if (key === 'Tab') {\n                e.preventDefault();\n                await handleAutocomplete();\n            } else if (key.length === 1 && !e.ctrlKey && !e.metaKey) {\n                e.preventDefault();\n                commandLine.textContent += key;\n                playKeySound();\n            }\n        });\n\n        function analyzeInput(input) {\n            const intent = classifier.classify(input);\n            \n            if (intent !== 'unknown') {\n                const entity = nerManager.extractEntities(input, intent);\n                if (entity) {\n                    const highlightedInput = input.replace(entity.text, `<mark>${entity.text}</mark>`);\n                    const command = `${intent} ${entity.value}`\n                    return { command, highlightedInput };\n                }\n                return { command: intent, highlightedInput: input }; // Intent recognized, but no entity\n            }\n            return { command: input, highlightedInput: input }; // Fallback to original input\n        }\n\n        async function handleAutocomplete() {\n            const currentInput = commandLine.textContent;\n            const parts = currentInput.split(' ');\n            const command = parts[0];\n            const lastPart = parts[parts.length - 1];\n\n            if (parts.length === 1) {\n                const matches = availableCommands.filter(cmd => cmd.startsWith(lastPart));\n                if (matches.length === 1) {\n                    commandLine.textContent = matches[0] + ' ';\n                } else if (matches.length > 1) {\n                    await typeLorelMessage(`Possibili comandi: ${matches.join('  ')}`, true);\n                }\n                return;\n            }\n\n            if (command === 'weather' && parts.length > 1) {\n                const currentArg = parts[parts.length - 1];\n                if (currentArg.length < 2) {\n                    await typeLorelMessage('Digita almeno 2 caratteri per la ricerca della città.', true);\n                    return;\n                }\n                const suggestions = await fetchCitySuggestions(currentArg);\n                if (suggestions.length === 1) {\n                    parts[parts.length - 1] = suggestions[0];\n                    commandLine.textContent = parts.join(' ') + ' ';\n                } else if (suggestions.length > 1) {\n                    await typeLorelMessage(`Suggerimenti: ${suggestions.join('  ')}`, true);\n                } else {\n                    await typeLorelMessage('Nessuna città trovata.', true);\n                }\n                return;\n            }\n\n            if (commandArgs[command]) {\n                const argSuggestions = commandArgs[command];\n                const currentArg = parts.length > 1 ? lastPart : '';\n                const matches = argSuggestions.filter(arg => arg.toLowerCase().startsWith(currentArg.toLowerCase()));\n                if (matches.length === 1) {\n                    parts[parts.length - 1] = matches[0];\n                    commandLine.textContent = parts.join(' ') + ' ';\n                } else if (matches.length > 1) {\n                    await typeLorelMessage(`Suggerimenti: ${matches.join('  ')}`, true);\n                }\n            }\n        }\n\n        async function fetchCitySuggestions(partialName) {\n            try {\n                const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(partialName)}&count=5&language=it&format=json`);\n                if (!response.ok) return [];\n                const data = await response.json();\n                if (data.results) {\n                    const uniqueNames = new Set();\n                    return data.results.map(loc => {\n                        const name = `${loc.name}, ${loc.country_code}`\n                        if(uniqueNames.has(name)) return null;\n                        uniqueNames.add(name);\n                        return name;\n                    }).filter(name => name !== null);\n                }\n                return [];\n            } catch (error) {\n                console.error(\"City suggestion fetch error:\", error);\n                return [];\n            }\n        }\n        \n        function parseCommand(input) {\n            const regex = /[^\\s\\\"']+|\\\"([^\\\"]*)\\\"|'([^']*)'/g;\n            const tokens = [];\n            let match;\n            do {\n                match = regex.exec(input);\n                if (match !== null) {\n                    tokens.push(match[1] || match[2] || match[0]);\n                }\n            } while (match !== null);\n\n            const command = tokens[0] ? tokens[0].toLowerCase() : '';\n            const args = [];\n            const flags = {};\n\n            for (let i = 1; i < tokens.length; i++) {\n                const token = tokens[i];\n                if (token.startsWith('--')) {\n                    const flagName = token.substring(2);\n                    const nextToken = tokens[i + 1];\n                    if (nextToken && !nextToken.startsWith('-')) {\n                        flags[flagName] = nextToken;\n                        i++;\n                    } else {\n                        flags[flagName] = true;\n                    }\n                } else if (token.startsWith('-')) {\n                    const flagName = token.substring(1);\n                     const nextToken = tokens[i + 1];\n                    if (nextToken && !nextToken.startsWith('-')) {\n                        flags[flagName] = nextToken;\n                        i++;\n                    } else {\n                        flags[flagName] = true;\n                    }\n                } else {\n                    args.push(token);\n                }\n            }\n            return { command, args, flags };\n        }\n\n        async function processCommand(command) {\n            const parsed = parseCommand(command);\n\n            switch (parsed.command) {\n                case 'help':\n                    const helpText = `Comandi disponibili:\\n` +\n                                   `  help              - Mostra questa lista di comandi.\\n` +\n                                   `  status            - Mostra lo stato attuale del sistema.\\n` +\n                                   `  date              - Mostra data e ora correnti.\\n` +\n                                   `  news [--limit N]  - Recupera N notizie (default 3).\\n` +\n                                   `  weather <città>   - Mostra il meteo per una città.\\n` +\n                                   `  wiki <termine>    - Cerca un termine su Wikipedia.\\n` +\n                                   `  echo <testo>      - Ripete il testo fornito.\\n` +\n                                   `  clear             - Pulisce lo schermo del terminale.`;\n                    await typeLorelMessage(helpText);\n                    break;\n                case 'status':\n                    await typeLorelMessage('STATUS: ONLINE. Version: 4.6. Modules: NLU, API Fetch, Session Persistence, CSS Aesthetics, Audio Feedback.');\n                    break;\n                case 'date':\n                    await typeLorelMessage(new Date().toLocaleString('it-IT'));\n                    break;\n                case 'clear':\n                    history.innerHTML = '';\n                    localStorage.removeItem('chatHistory');\n                    break;\n                case 'echo':\n                    await typeLorelMessage(parsed.args.length > 0 ? parsed.args.join(' ') : '');\n                    break;\n                case 'news':\n                    const limit = parsed.flags.limit || 3;\n                    await fetchNews(limit);\n                    break;\n                case 'weather':\n                    if (parsed.args.length === 0) {\n                        await typeLorelMessage('Uso: weather <città> o chiedi \\\"che tempo fa a <città>?\\\"');\n                    } else {\n                        await fetchWeather(parsed.args.join(' '));\n                    }\n                    break;\n                case 'wiki':\n                     if (parsed.args.length === 0) {\n                        await typeLorelMessage('Uso: wiki <termine da cercare> o chiedi \\\"cosa è <termine>?\\\"');\n                    } else {\n                        await fetchWikipedia(parsed.args.join(' '));\n                    }\n                    break;\n                default:\n                    await typeLorelMessage(`Comando non riconosciuto: '${parsed.command}'. Digita 'help' per la lista dei comandi.`);\n                    break;\n            }\n        }\n\n        async function fetchWikipedia(term) {\n            await typeLorelMessage(`Ricerca su Wikipedia per \\\"${term}\\\"...`);\n            try {\n                const searchUrl = `https://it.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&format=json&origin=*`;\n                const searchResponse = await fetch(searchUrl);\n                if (!searchResponse.ok) throw new Error(`Errore API Wikipedia (Search): ${searchResponse.status}`);\n                const searchData = await searchResponse.json();\n\n                if (!searchData.query.search || searchData.query.search.length === 0) {\n                    throw new Error(`Nessun risultato trovato per \\\"${term}\\\".`);\n                }\n\n                const searchResults = searchData.query.search;\n                \n                if (searchResults.length > 1 && searchResults[0].title.toLowerCase() !== term.toLowerCase()) {\n                    let disambiguation = false;\n                    if (searchResults[0].snippet.toLowerCase().includes('disambigua')) disambiguation = true;\n\n                    if(disambiguation || searchResults.length > 2) {\n                        let suggestionText = `Trovati più risultati per \\\"${term}\\\". Essere più specifici:\\n`;\n                        searchResults.slice(0, 5).forEach(res => {\n                            suggestionText += `  - ${res.title}\\n`;\n                        });\n                        suggestionText += `Esempio: wiki \\\"${searchResults[0].title}\\\"`;\n                        await typeLorelMessage(suggestionText);\n                        return;\n                    }\n                }\n\n                const pageTitle = searchResults[0].title;\n                await typeLorelMessage(`Trovata pagina: \\\"${pageTitle}\\\". Recupero riassunto...`);\n\n                const summaryUrl = `https://it.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(pageTitle)}&format=json&origin=*`;\n                const summaryResponse = await fetch(summaryUrl);\n                if (!summaryResponse.ok) throw new Error(`Errore API Wikipedia (Extract): ${summaryResponse.status}`);\n                const summaryData = await summaryResponse.json();\n\n                const pages = summaryData.query.pages;\n                const pageId = Object.keys(pages)[0];\n                const extract = pages[pageId].extract;\n\n                if (extract) {\n                    await typeLorelMessage(extract);\n                } else {\n                    throw new Error(`Nessun riassunto disponibile per \\\"${pageTitle}\\\". Potrebbe essere una pagina di reindirizzamento o disambiguazione.`);\n                }\n\n            } catch (error) {\n                await typeLorelMessage(`Errore durante la ricerca su Wikipedia: ${error.message}`);\n            }\n        }\n\n        async function fetchWeather(city) {\n            await typeLorelMessage(`Ricerca coordinate per ${city}...`);\n            try {\n                const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=5&language=it&format=json`);\n                if (!geoResponse.ok) throw new Error(`Errore Geocoding: ${geoResponse.status}`);\n                const geoData = await geoResponse.json();\n                \n                if (!geoData.results || geoData.results.length === 0) {\n                    throw new Error(`Località non trovata: ${city}`);\n                }\n\n                const uniqueLocations = [];\n                const seen = new Set();\n                for (const loc of geoData.results) {\n                    const identifier = `${loc.name}, ${loc.admin1 || loc.country}`\n                    if (!seen.has(identifier)) {\n                        uniqueLocations.push(loc);\n                        seen.add(identifier);\n                    }\n                }\n\n                let location;\n                if (uniqueLocations.length > 1 && !city.includes(',')) {\n                    let suggestionText = `Trovate più località per \\\"${city}\\\". Essere più specifici:\\n`;\n                    uniqueLocations.slice(0, 3).forEach(loc => {\n                        suggestionText += `  - ${loc.name}, ${loc.admin1 || loc.country_code}\\n`;\n                    });\n                    suggestionText += `Esempio: weather \\\"${uniqueLocations[0].name}, ${uniqueLocations[0].country_code}\\\"`;\n                    await typeLorelMessage(suggestionText);\n                    return;\n                } else {\n                    location = uniqueLocations[0];\n                }\n\n                const { latitude, longitude, name, admin1, country_code } = location;\n                const locationName = `${name}, ${admin1 || country_code}`\n                await typeLorelMessage(`Coordinate trovate per ${locationName}. Recupero dati meteo...`);\n\n                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);\n                if (!weatherResponse.ok) throw new Error(`Errore API Meteo: ${weatherResponse.status}`);\n                const weatherData = await weatherResponse.json();\n                \n                const { temperature, windspeed, weathercode } = weatherData.current_weather;\n                const weatherDescription = getWeatherDescription(weathercode);\n\n                const weatherReport = `Meteo attuale per ${locationName}:\\n` +\n                                    `  - Descrizione: ${weatherDescription}\\n` +\n                                    `  - Temperatura: ${temperature}°C\\n` +\n                                    `  - Vento: ${windspeed} km/h`;\n                await typeLorelMessage(weatherReport);\n\n            } catch (error) {\n                await typeLorelMessage(`Errore durante il recupero del meteo: ${error.message}`);\n            }\n        }\n\n        function getWeatherDescription(code) {\n            const descriptions = {\n                0: 'Sereno', 1: 'Prevalentemente sereno', 2: 'Parzialmente nuvoloso', 3: 'Nuvoloso',\n                45: 'Nebbia', 48: 'Nebbia con brina',\n                51: 'Pioggerella leggera', 53: 'Pioggerella moderata', 55: 'Pioggerella intensa',\n                61: 'Pioggia leggera', 63: 'Pioggia moderata', 65: 'Pioggia forte',\n                71: 'Nevicata leggera', 73: 'Nevicata moderata', 75: 'Nevicata forte',\n                80: 'Rovescio leggero', 81: 'Rovescio moderato', 82: 'Rovescio violento',\n                95: 'Temporale', 96: 'Temporale con grandine leggera', 99: 'Temporale con grandine pesante'\n            };\n            return descriptions[code] || 'Condizioni non specificate';\n        }\n\n        async function fetchNews(limit = 3) {\n            await typeLorelMessage(`Recupero ${limit} notizie dal web...`);\n            try {\n                const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`);\n                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n                const data = await response.json();\n                let newsHeadlines = 'Ultime notizie recuperate:\\n\\n';\n                data.forEach((article, index) => {\n                    const title = article.title.charAt(0).toUpperCase() + article.title.slice(1);\n                    newsHeadlines += `[${index + 1}] ${title}\\n`;\n                });\n                await typeLorelMessage(newsHeadlines);\n            } catch (error) {\n                await typeLorelMessage(`Errore durante il recupero delle notizie: ${error.message}`);\n            }\n        }\n\n        function typeLorelMessage(text, isSuggestion = false) {\n            return new Promise(resolve => {\n                if (isSuggestion) {\n                    const div = document.createElement('div');\n                    div.className = 'msg lorel';\n                    div.style.color = 'var(--term-dim)';\n                    history.appendChild(div);\n                    scrollToBottom();\n                    let i = 0;\n                    const speed = 10;\n                    function typeSuggestion() {\n                        if (i < text.length) {\n                            div.innerText += text.charAt(i);\n                            i++;\n                            scrollToBottom();\n                            setTimeout(typeSuggestion, speed);\n                        } else {\n                            setTimeout(() => {\n                                if (div.parentNode) div.parentNode.removeChild(div);\n                                resolve();\n                            }, 2500);\n                        }\n                    }\n                    typeSuggestion();\n                    return;\n                }\n\n                const messageDiv = document.createElement('div');\n                messageDiv.className = 'msg lorel';\n                messageDiv.innerHTML = '<div class=\"typing-indicator\"><span></span><span></span><span></span></div>';\n                history.appendChild(messageDiv);\n                scrollToBottom();\n\n                const thinkTime = 600 + Math.random() * 400;\n                setTimeout(() => {\n                    messageDiv.innerHTML = '';\n                    let i = 0;\n                    const speed = 25;\n                    function type() {\n                        if (i < text.length) {\n                            messageDiv.innerText += text.charAt(i);\n                            i++;\n                            scrollToBottom();\n                            setTimeout(type, speed);\n                        } else {\n                            resolve();\n                        }\n                    }\n                    type();\n                }, thinkTime);\n            });\n        }\n        \n        function addUserMessage(text, isHtml = false) {\n            const div = document.createElement('div');\n            div.className = 'msg user';\n            if (isHtml) {\n                div.innerHTML = text;\n            } else {\n                div.innerText = text;\n            }\n            history.appendChild(div);\n            saveChatHistory();\n            scrollToBottom();\n        }\n\n        function saveChatHistory() {\n            localStorage.setItem('chatHistory', history.innerHTML);\n        }\n\n        function loadHistory() {\n            const savedCommandHistory = localStorage.getItem('commandHistory');\n            if(savedCommandHistory) {\n                commandHistory = JSON.parse(savedCommandHistory);\n                historyIndex = commandHistory.length;\n            }\n            const savedChat = localStorage.getItem('chatHistory');\n            if (savedChat) {\n                history.innerHTML = savedChat;\n            }\n        }\n\n        function scrollToBottom() {\n             terminalContainer.scrollTop = terminalContainer.scrollHeight;\n        }\n\n        function updateClock() {\n            const now = new Date();\n            const timeString = now.toLocaleTimeString('it-IT');\n            clock.textContent = timeString;\n        }\n        \n        window.onload = async () => {\n            initializeNLU();\n            loadHistory();\n            updateClock();\n            setInterval(updateClock, 1000);\n            isTyping = true;\n            cursor.style.display = 'none';\n            if (!localStorage.getItem('chatHistory')) {\n                await typeLorelMessage(\"Interfaccia v4.6. Codice interno ottimizzato per una maggiore coerenza. Stabilità migliorata.\");\n                saveChatHistory();\n            }\n            isTyping = false;\n            cursor.style.display = 'inline-block';\n            scrollToBottom();\n        }\n\n    </script>\n</body>\n</html>