<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        #terminal-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="terminal-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet/lib/figlet.js"></script>

    <script>
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#000000',
                foreground: '#00ff00',
                cursor: '#00ff00'
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        window.addEventListener('resize', () => fitAddon.fit());

        let currentInput = '';
        let commandHistory = JSON.parse(localStorage.getItem('commandHistory')) || [];
        let historyIndex = commandHistory.length;
        let cursorPos = 0;

        const prompt = 'LorelAxun> ';

        const commandActions = {
            'help': () => {
                term.writeln('\nComandi disponibili:');
                Object.keys(commandActions).forEach(cmd => term.writeln(`- ${cmd}`));
            },
            'ciao': () => term.writeln('\nCiao! Come posso aiutarti?'),
            'chi sei': () => term.writeln('\nSono Lorel Axun, un\'IA in continua evoluzione.'),
            'cosa sai fare': () => commandActions.help(),
            'echo': (args) => term.writeln(`\n${args.join(' ')}`),
            'clear': () => term.clear()
        };
        const commandList = Object.keys(commandActions);

        function handleCommand(input) {
            const parts = input.trim().split(' ');
            const command = parts[0];
            const args = parts.slice(1);

            if (command in commandActions) {
                commandActions[command](args);
            } else if (command.length > 0) {
                term.writeln(`\nComando non trovato: ${command}`);
            }
        }

        function typeWriter(text, callback) {
            let i = 0;
            function type() {
                if (i < text.length) {
                    term.write(text.charAt(i));
                    i++;
                    setTimeout(type, 50);
                } else if (callback) {
                    callback();
                }
            }
            type();
        }

        figlet.parseFont('Standard', figlet.textSync('Lorel Axun'));
        term.writeln(figlet.textSync('Lorel Axun'));
        typeWriter('Benvenuto. Digita \'help\' per la lista dei comandi.\n', () => term.write(prompt));

        term.onKey(e => {
            const key = e.key;
            const ev = e.domEvent;

            const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey;

            switch (key) {
                case '\r': // Enter
                    term.write('\r\n');
                    if (currentInput.trim() !== '') {
                        handleCommand(currentInput);
                        if (commandHistory[commandHistory.length - 1] !== currentInput) {
                            commandHistory.push(currentInput);
                            localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                        }
                    }
                    historyIndex = commandHistory.length;
                    currentInput = '';
                    cursorPos = 0;
                    term.write(prompt);
                    break;
                case '\u007f': // Backspace
                    if (cursorPos > 0) {
                        const left = currentInput.slice(0, cursorPos - 1);
                        const right = currentInput.slice(cursorPos);
                        currentInput = left + right;
                        term.write('\x1b[D'); // Move cursor left
                        term.write('\x1b[K'); // Clear from cursor to end of line
                        term.write(right); // Write the rest of the string
                        term.write(`\x1b[${right.length}D`); // Move cursor back
                        cursorPos--;
                    }
                    break;
                case '\t': // Tab for autocomplete
                    ev.preventDefault();
                    const potentialCommands = commandList.filter(name => name.startsWith(currentInput));
                    if (potentialCommands.length > 0) {
                        const completion = potentialCommands[0];
                        const clearLine = '\x1b[2K\r';
                        term.write(clearLine + prompt + completion);
                        currentInput = completion;
                        cursorPos = completion.length;
                    }
                    break;
                case '\x1b[A': // Up arrow
                    if (historyIndex > 0) {
                        historyIndex--;
                        currentInput = commandHistory[historyIndex];
                        const clearLine = '\x1b[2K\r';
                        term.write(clearLine + prompt + currentInput);
                        cursorPos = currentInput.length;
                    }
                    break;
                case '\x1b[B': // Down arrow
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        currentInput = commandHistory[historyIndex];
                        const clearLine = '\x1b[2K\r';
                        term.write(clearLine + prompt + currentInput);
                        cursorPos = currentInput.length;
                    } else {
                        historyIndex = commandHistory.length;
                        currentInput = '';
                        const clearLine = '\x1b[2K\r';
                        term.write(clearLine + prompt);
                        cursorPos = 0;
                    }
                    break;
                case '\x1b[C': // Right arrow
                    if (cursorPos < currentInput.length) {
                        term.write(key);
                        cursorPos++;
                    }
                    break;
                case '\x1b[D': // Left arrow
                    if (cursorPos > 0) {
                        term.write(key);
                        cursorPos--;
                    }
                    break;
                default:
                    if (printable && key.length === 1) {
                        const left = currentInput.slice(0, cursorPos);
                        const right = currentInput.slice(cursorPos);
                        currentInput = left + key + right;
                        term.write(key + right);
                        if (right.length > 0) {
                           term.write(`\x1b[${right.length}D`);
                        }
                        cursorPos++;
                    }
            }
        });
    </script>
</body>
</html>