<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
        #terminal-container { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="terminal-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet/lib/figlet.js"></script>

    <script>
        const terminalContainer = document.getElementById('terminal-container');
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#000000',
                foreground: '#00ff00',
                cursor: '#00ff00',
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(terminalContainer);
        fitAddon.fit();

        window.addEventListener('resize', () => fitAddon.fit());

        let vfs = {
            type: 'directory',
            content: {
                'home': {
                    type: 'directory',
                    content: {
                        'user': {
                            type: 'directory',
                            content: {
                                'readme.txt': {
                                    type: 'file',
                                    content: 'Welcome to Lorel Axun OS!'
                                }
                            }
                        }
                    }
                }
            }
        };

        let currentPath = '/home/user';
        let commandHistory = [];
        let historyIndex = -1;
        let currentCommand = '';
        let isEditing = false;
        let editFilePath = '';
        let editorBuffer = '';

        const prompt = () => `\x1b[1;32m${currentPath}\x1b[0m $ `;

        function resolvePath(path, cwd) {
            if (path.startsWith('/')) return path;
            const parts = cwd.split('/').filter(p => p);
            const pathParts = path.split('/').filter(p => p);

            for (const part of pathParts) {
                if (part === '..') {
                    if (parts.length > 0) parts.pop();
                } else if (part !== '.') {
                    parts.push(part);
                }
            }
            return '/' + parts.join('/');
        }

        function getPathObject(path, currentVfs) {
            const parts = path.split('/').filter(p => p);
            let current = currentVfs;
            for (const part of parts) {
                if (current && current.type === 'directory' && current.content[part]) {
                    current = current.content[part];
                } else {
                    return null;
                }
            }
            return current;
        }

        function saveState(context) {
            localStorage.setItem('lorel_axun_vfs', JSON.stringify(context.vfs));
            localStorage.setItem('lorel_axun_path', context.currentPath);
            localStorage.setItem('lorel_axun_history', JSON.stringify(context.commandHistory));
        }

        function loadState() {
            const savedVfs = localStorage.getItem('lorel_axun_vfs');
            const savedPath = localStorage.getItem('lorel_axun_path');
            const savedHistory = localStorage.getItem('lorel_axun_history');
            if (savedVfs) vfs = JSON.parse(savedVfs);
            if (savedPath) currentPath = savedPath;
            if (savedHistory) commandHistory = JSON.parse(savedHistory);
            historyIndex = commandHistory.length;
            return { vfs, currentPath, commandHistory };
        }

        const commands = {
            'help': {
                description: 'Show this help message.',
                usage: 'help',
                execute: async (args, term) => {
                    term.writeln('Lorel Axun OS - Available Commands:');
                    Object.keys(commands).sort().forEach(cmd => {
                        term.writeln(`  ${cmd.padEnd(20)} - ${commands[cmd].description}`);
                    });
                }
            },
            'ciao': {
                description: 'A friendly greeting.',
                usage: 'ciao',
                execute: async (args, term) => term.writeln('Ciao! Sono Lorel Axun. Come posso aiutarti?')
            },
            'chi sei': {
                description: 'Get information about Lorel Axun.',
                usage: 'chi sei',
                execute: async (args, term) => term.writeln('Sono Lorel Axun, un sistema operativo web autonomo creato da AleXsjsju.')
            },
            'echo': {
                description: 'Print arguments to the terminal.',
                usage: 'echo [text]...',
                execute: async (args, term) => term.writeln(args.join(' '))
            },
            'clear': {
                description: 'Clear the terminal screen.',
                usage: 'clear',
                execute: async (args, term) => term.clear()
            },
            'ls': {
                description: 'List directory contents.',
                usage: 'ls [path]',
                execute: async (args, term, input, context) => {
                    const path = args[0] || '.';
                    const targetPath = resolvePath(path, context.currentPath);
                    const dir = getPathObject(targetPath, context.vfs);
                    if (dir && dir.type === 'directory') {
                        Object.keys(dir.content).forEach(item => {
                            const type = dir.content[item].type;
                            const color = type === 'directory' ? '\x1b[1;34m' : '\x1b[0m';
                            term.writeln(`${color}${item}${type === 'directory' ? '/' : ''}\x1b[0m`);
                        });
                    } else {
                        term.writeln(`ls: cannot access '${path}': No such file or directory`);
                    }
                }
            },
            'cd': {
                description: 'Change the current directory.',
                usage: 'cd [path]',
                execute: async (args, term, input, context) => {
                    const path = args[0] || '/home/user';
                    const targetPath = resolvePath(path, context.currentPath);
                    const dir = getPathObject(targetPath, context.vfs);
                    if (dir && dir.type === 'directory') {
                        context.currentPath = targetPath;
                    } else {
                        term.writeln(`cd: no such file or directory: ${path}`);
                    }
                }
            },
            'cat': {
                description: 'Concatenate and display files.',
                usage: 'cat [file]',
                execute: async (args, term, input, context) => {
                    const path = args[0];
                    if (!path && !input) {
                        term.writeln('cat: missing operand');
                        return;
                    }
                    if (input) {
                        term.writeln(input);
                        return;
                    }
                    const targetPath = resolvePath(path, context.currentPath);
                    const file = getPathObject(targetPath, context.vfs);
                    if (file && file.type === 'file') {
                        term.writeln(file.content);
                    } else {
                        term.writeln(`cat: ${path}: No such file or directory`);
                    }
                }
            },
            'mkdir': {
                description: 'Create a directory.',
                usage: 'mkdir [directory_name]',
                execute: async (args, term, input, context) => {
                    const path = args[0];
                    if (!path) {
                        term.writeln('mkdir: missing operand');
                        return;
                    }
                    const targetPath = resolvePath(path, context.currentPath);
                    const parts = targetPath.split('/').filter(p => p);
                    const newDirName = parts.pop();
                    const parentPath = '/' + parts.join('/');
                    const parentDir = getPathObject(parentPath, context.vfs);

                    if (parentDir && parentDir.type === 'directory') {
                        if (parentDir.content[newDirName]) {
                            term.writeln(`mkdir: cannot create directory '${path}': File exists`);
                        } else {
                            parentDir.content[newDirName] = { type: 'directory', content: {} };
                        }
                    } else {
                        term.writeln(`mkdir: cannot create directory '${path}': No such file or directory`);
                    }
                }
            },
            'touch': {
                description: 'Create an empty file.',
                usage: 'touch [file_name]',
                execute: async (args, term, input, context) => {
                    const path = args[0];
                    if (!path) {
                        term.writeln('touch: missing operand');
                        return;
                    }
                    const targetPath = resolvePath(path, context.currentPath);
                    const parts = targetPath.split('/').filter(p => p);
                    const newFileName = parts.pop();
                    const parentPath = '/' + parts.join('/');
                    const parentDir = getPathObject(parentPath, context.vfs);

                    if (parentDir && parentDir.type === 'directory') {
                        if (!parentDir.content[newFileName]) {
                            parentDir.content[newFileName] = { type: 'file', content: '' };
                        }
                    } else {
                        term.writeln(`touch: cannot touch '${path}': No such file or directory`);
                    }
                }
            },
            'rm': {
                description: 'Remove files or directories.',
                usage: 'rm [file_or_directory]',
                execute: async (args, term, input, context) => {
                    const path = args[0];
                    if (!path) {
                        term.writeln('rm: missing operand');
                        return;
                    }
                    const targetPath = resolvePath(path, context.currentPath);
                    const parts = targetPath.split('/').filter(p => p);
                    const targetName = parts.pop();
                    const parentPath = '/' + parts.join('/');
                    const parentDir = getPathObject(parentPath, context.vfs);

                    if (parentDir && parentDir.type === 'directory' && parentDir.content[targetName]) {
                        delete parentDir.content[targetName];
                    } else {
                        term.writeln(`rm: cannot remove '${path}': No such file or directory`);
                    }
                }
            },
            'fetch': {
                description: 'Fetch a URL and display its content.',
                usage: 'fetch [url]',
                execute: async (args, term) => {
                    const url = args[0];
                    if (!url) {
                        term.writeln('Usage: fetch <url>');
                        return;
                    }
                    term.writeln(`Fetching ${url}...`);
                    try {
                        // Using a CORS proxy for cross-origin requests
                        const response = await fetch(`https://cors-anywhere.herokuapp.com/${url}`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.text();
                        term.writeln(data);
                    } catch (e) {
                        term.writeln(`\x1b[31mError: ${e.message}\x1b[0m`);
                    }
                }
            },
            'edit': {
                description: 'Edit a file.',
                usage: 'edit [file]',
                execute: async (args, term, input, context) => {
                    const path = args[0];
                    if (!path) {
                        term.writeln('Usage: edit <file>');
                        return;
                    }
                    const targetPath = resolvePath(path, context.currentPath);
                    const file = getPathObject(targetPath, context.vfs);
                    if (!file || file.type !== 'file') {
                        term.writeln(`edit: file not found: ${path}`);
                        return;
                    }
                    isEditing = true;
                    editFilePath = targetPath;
                    editorBuffer = file.content;
                    term.clear();
                    term.write(editorBuffer);
                    term.writeln('\r\n\x1b[7m-- Press Ctrl+S to Save, Ctrl+X to Exit --\x1b[0m');
                }
            },
            'js': {
                description: 'Execute JavaScript code in a secure sandbox.',
                usage: 'js <code>',
                execute: async (args, term, input, context) => {
                    const code = args.join(' ');
                    if (!code) {
                        term.writeln('Usage: js <code>');
                        term.writeln('The sandbox provides the following API:');
                        term.writeln('  log(...args)             - Prints arguments to the terminal.');
                        term.writeln('  readFile(path)           - Reads a file from the VFS.');
                        term.writeln('  writeFile(path, content) - Writes content to a file in the VFS.');
                        term.writeln('  fileExists(path)         - Checks if a file or directory exists.');
                        term.writeln('  listDir(path)            - Lists the contents of a directory.');
                        return;
                    }

                    const sandbox = {
                        log: (...args) => {
                            const output = args.map(arg => {
                                if (typeof arg === 'object' && arg !== null) {
                                    try { return JSON.stringify(arg, null, 2); } catch (e) { return String(arg); }
                                }
                                return String(arg);
                            }).join(' ');
                            term.writeln(output);
                        },
                        readFile: (path) => {
                            const absolutePath = resolvePath(path, context.currentPath);
                            const file = getPathObject(absolutePath, context.vfs);
                            if (file && file.type === 'file') return file.content;
                            throw new Error(`readFile: File not found at ${path}`);
                        },
                        writeFile: (path, content) => {
                            const absolutePath = resolvePath(path, context.currentPath);
                            const parts = absolutePath.split('/').filter(p => p);
                            const fileName = parts.pop();
                            const parentPath = '/' + parts.join('/');
                            const parentDir = getPathObject(parentPath, context.vfs);

                            if (!parentDir || parentDir.type !== 'directory') throw new Error(`writeFile: Directory not found for ${path}`);
                            if (typeof content !== 'string') throw new Error('writeFile: content must be a string.');
                            parentDir.content[fileName] = { type: 'file', content: content };
                            saveState(context);
                        },
                        fileExists: (path) => {
                            const absolutePath = resolvePath(path, context.currentPath);
                            return !!getPathObject(absolutePath, context.vfs);
                        },
                        listDir: (path) => {
                            const absolutePath = resolvePath(path, context.currentPath);
                            const dir = getPathObject(absolutePath, context.vfs);
                            if (dir && dir.type === 'directory') return Object.keys(dir.content);
                            throw new Error(`listDir: Directory not found at ${path}`);
                        }
                    };

                    try {
                        const func = new Function('sandbox', `with(sandbox) { ${code} }`);
                        const result = func(sandbox);
                        if (result !== undefined) {
                            term.writeln(String(result));
                        }
                    } catch (e) {
                        term.writeln(`\x1b[31mError: ${e.message}\x1b[0m`);
                    }
                }
            },
            'type': {
                description: 'Types out a message with a typewriter effect.',
                usage: 'type [text]...',
                execute: (args, term) => {
                    return new Promise(resolve => {
                        const text = args.join(' ');
                        let i = 0;
                        const interval = setInterval(() => {
                            if (i < text.length) {
                                term.write(text.charAt(i));
                                i++;
                            } else {
                                clearInterval(interval);
                                term.writeln('');
                                resolve();
                            }
                        }, 50);
                    });
                }
            }
        };

        async function executeCommand(commandLine) {
            const context = { vfs, currentPath, commandHistory };
            const pipelines = commandLine.split('|').map(s => s.trim());
            let input = undefined;

            for (const part of pipelines) {
                const [cmd, ...args] = part.split(' ').filter(s => s);
                if (!cmd) continue;

                let output = '';
                const originalWrite = term.write.bind(term);
                const originalWriteln = term.writeln.bind(term);
                const captureOutput = (data) => { output += data + '\n'; };

                term.writeln = captureOutput;
                term.write = (data) => { output += data; };

                try {
                    if (commands[cmd]) {
                        await commands[cmd].execute(args, term, input, context);
                    } else {
                        output = `Command not found: ${cmd}\n`;
                    }
                } catch (e) {
                    output = `Error: ${e.message}\n`;
                }

                term.write = originalWrite;
                term.writeln = originalWriteln;
                input = output.trimEnd();
            }

            const redirectionMatch = input.match(/^(.*?)>>?\s*([^\s]+)$/s);
            if (redirectionMatch) {
                const content = redirectionMatch[1].trimEnd();
                const filePath = redirectionMatch[2];
                const append = redirectionMatch[0].includes('>>');
                const targetPath = resolvePath(filePath, context.currentPath);
                const parts = targetPath.split('/').filter(p => p);
                const fileName = parts.pop();
                const parentPath = '/' + parts.join('/');
                const parentDir = getPathObject(parentPath, context.vfs);

                if (parentDir && parentDir.type === 'directory') {
                    const existingFile = parentDir.content[fileName];
                    if (existingFile && existingFile.type === 'file') {
                        existingFile.content = append ? existingFile.content + '\n' + content : content;
                    } else {
                        parentDir.content[fileName] = { type: 'file', content: content };
                    }
                } else {
                    term.writeln(`bash: ${filePath}: No such file or directory`);
                }
            } else if (input !== undefined) {
                term.writeln(input);
            }

            saveState(context);
        }

        term.onKey(({ key, domEvent }) => {
            if (isEditing) {
                if (domEvent.ctrlKey && domEvent.key === 's') {
                    domEvent.preventDefault();
                    const targetPath = editFilePath;
                    const parts = targetPath.split('/').filter(p => p);
                    const fileName = parts.pop();
                    const parentPath = '/' + parts.join('/');
                    const parentDir = getPathObject(parentPath, vfs);
                    if (parentDir && parentDir.content[fileName]) {
                        parentDir.content[fileName].content = editorBuffer;
                        saveState({ vfs, currentPath, commandHistory });
                    }
                    isEditing = false;
                    term.clear();
                    term.writeln(`File saved: ${editFilePath}`);
                    term.write(prompt());
                } else if (domEvent.ctrlKey && domEvent.key === 'x') {
                    domEvent.preventDefault();
                    isEditing = false;
                    term.clear();
                    term.write(prompt());
                } else {
                    switch (domEvent.key) {
                        case 'Enter':
                            editorBuffer += '\n';
                            term.writeln('');
                            break;
                        case 'Backspace':
                            if (term.buffer.active.cursorX > 0) {
                                editorBuffer = editorBuffer.slice(0, -1);
                                term.write('\b \b');
                            }
                            break;
                        default:
                            if (!domEvent.ctrlKey && !domEvent.altKey && !domEvent.metaKey) {
                                editorBuffer += key;
                                term.write(key);
                            }
                    }
                }
                return;
            }

            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            switch (domEvent.key) {
                case 'Enter':
                    if (currentCommand.trim()) {
                        term.writeln('');
                        commandHistory.push(currentCommand);
                        if (commandHistory.length > 50) commandHistory.shift();
                        historyIndex = commandHistory.length;
                        executeCommand(currentCommand).then(() => {
                            term.write(prompt());
                        });
                    }
                    currentCommand = '';
                    break;
                case 'Backspace':
                    if (currentCommand.length > 0) {
                        term.write('\b \b');
                        currentCommand = currentCommand.slice(0, -1);
                    }
                    break;
                case 'ArrowUp':
                    if (historyIndex > 0) {
                        historyIndex--;
                        term.write('\x1b[2K\r' + prompt());
                        currentCommand = commandHistory[historyIndex];
                        term.write(currentCommand);
                    }
                    break;
                case 'ArrowDown':
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        term.write('\x1b[2K\r' + prompt());
                        currentCommand = commandHistory[historyIndex];
                        term.write(currentCommand);
                    } else {
                        historyIndex = commandHistory.length;
                        term.write('\x1b[2K\r' + prompt());
                        currentCommand = '';
                    }
                    break;
                case 'Tab':
                    domEvent.preventDefault();
                    const matchingCommands = Object.keys(commands).filter(c => c.startsWith(currentCommand));
                    if (matchingCommands.length === 1) {
                        term.write('\x1b[2K\r' + prompt());
                        currentCommand = matchingCommands[0] + ' ';
                        term.write(currentCommand);
                    }
                    break;
                default:
                    if (printable && key.length === 1) {
                        currentCommand += key;
                        term.write(key);
                    }
            }
        });

        function start() {
            const context = loadState();
            figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {
                if (err) {
                    term.writeln('Lorel Axun');
                } else {
                    term.writeln(data);
                }
                commands.type.execute(['Welcome. Type `help` to see available commands.'], term).then(() => {
                    term.write(prompt());
                });
            });
        }

        start();
    </script>
</body>
</html>