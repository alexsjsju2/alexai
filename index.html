<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
    <style>
        body, html { margin: 0; padding: 0; height: 100%; background-color: #000; }
        #terminal-container { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="terminal-container"></div>

    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script src="https://unpkg.com/figlet/lib/figlet.js"></script>

    <script>
        const terminalContainer = document.getElementById('terminal-container');

        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#000000',
                foreground: '#00ff00',
                cursor: '#00ff00',
            }
        });

        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(terminalContainer);
        fitAddon.fit();

        window.addEventListener('resize', () => fitAddon.fit());

        // --- VIRTUAL FILE SYSTEM (VFS) & PERSISTENCE ---
        let vfs = {
            '/': {
                type: 'directory',
                children: {
                    'home': {
                        type: 'directory',
                        children: {
                            'user': {
                                type: 'directory',
                                children: {
                                    'readme.txt': {
                                        type: 'file',
                                        content: 'Benvenuto in Lorel Axun. Digita `help` per iniziare.'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        let currentPath = '/home/user';

        function saveState() {
            const state = { vfs, currentPath, history: commandHistory };
            localStorage.setItem('lorel_axun_state', JSON.stringify(state));
        }

        function loadState() {
            const savedState = localStorage.getItem('lorel_axun_state');
            if (savedState) {
                const state = JSON.parse(savedState);
                vfs = state.vfs;
                currentPath = state.currentPath;
                commandHistory = state.history || [];
                historyIndex = commandHistory.length;
            } else {
                // Initialize if no state is saved
                saveState();
            }
        }

        function resolvePath(path) {
            const segments = (path.startsWith('/') ? path : (currentPath === '/' ? '' : currentPath) + '/' + path).split('/').filter(Boolean);
            let current = vfs['/'];
            for (const segment of segments) {
                if (segment === '..') {
                    // This is a simplified '..' that needs a proper implementation by tracking parent pointers or recalculating path
                    const parentPath = segments.slice(0, -2).join('/') || '/';
                    return resolvePath(parentPath); // Re-resolve from parent
                }
                if (!current || current.type !== 'directory' || !current.children[segment]) {
                    return null;
                }
                current = current.children[segment];
            }
            return current;
        }

        function getParentNode(path) {
            const segments = (path.startsWith('/') ? path : (currentPath === '/' ? '' : currentPath) + '/' + path).split('/').filter(Boolean);
            const parentPath = '/' + segments.slice(0, -1).join('/');
            return resolvePath(parentPath);
        }

        // --- COMMANDS ---
        const commands = {
            'help': {
                description: 'Mostra questo messaggio di aiuto.',
                execute: (args, term) => {
                    term.writeln('Comandi disponibili:');
                    Object.keys(commands).sort().forEach(cmd => {
                        term.writeln(`  ${cmd.padEnd(15)} ${commands[cmd].description}`);
                    });
                }
            },
            'ciao': {
                description: 'Un saluto amichevole.',
                execute: (args, term) => term.writeln('Ciao! Come posso aiutarti?')
            },
            'chi sei': {
                description: 'Scopri chi sono.',
                execute: (args, term) => term.writeln('Sono Lorel Axun, un\'IA in continua evoluzione.')
            },
            'cosa sai fare': {
                description: 'Elenca le mie capacità.',
                execute: (args, term) => term.writeln('Posso eseguire comandi, navigare un file system virtuale, accedere al web con `fetch` e molto altro. Digita `help` per la lista completa.')
            },
            'echo': {
                description: 'Stampa a schermo il testo fornito.',
                execute: (args, term) => term.writeln(args.join(' '))
            },
            'clear': {
                description: 'Pulisce la schermata del terminale.',
                execute: (args, term) => term.clear()
            },
            'ls': {
                description: 'Elenca i file e le directory.',
                execute: (args, term) => {
                    const node = resolvePath(args[0] || '.');
                    if (node && node.type === 'directory') {
                        Object.keys(node.children).forEach(name => {
                            const child = node.children[name];
                            term.writeln(child.type === 'directory' ? `${name}/` : name);
                        });
                    } else {
                        term.writeln(`ls: cannot access '${args[0] || '.'}': No such file or directory`);
                    }
                }
            },
            'cd': {
                description: 'Cambia la directory corrente.',
                execute: (args, term) => {
                    const newPath = args[0] || '/home/user';
                    let targetPath;
                    if (newPath.startsWith('/')) {
                        targetPath = newPath;
                    } else {
                        targetPath = (currentPath === '/' ? '' : currentPath) + '/' + newPath;
                    }

                    const segments = targetPath.split('/').reduce((acc, part) => {
                        if (part === '..') {
                            acc.pop();
                        } else if (part && part !== '.') {
                            acc.push(part);
                        }
                        return acc;
                    }, []);

                    const finalPath = '/' + segments.join('/');
                    const node = resolvePath(finalPath);

                    if (node && node.type === 'directory') {
                        currentPath = finalPath;
                    } else {
                        term.writeln(`cd: no such file or directory: ${newPath}`);
                    }
                }
            },
            'cat': {
                description: 'Mostra il contenuto di un file.',
                execute: (args, term, input) => {
                    if (input) {
                        term.writeln(input);
                        return;
                    }
                    const node = resolvePath(args[0]);
                    if (node && node.type === 'file') {
                        term.writeln(node.content);
                    } else {
                        term.writeln(`cat: ${args[0]}: No such file or directory`);
                    }
                }
            },
            'mkdir': {
                description: 'Crea una nuova directory.',
                execute: (args, term) => {
                    const dirName = args[0];
                    if (!dirName) {
                        term.writeln('mkdir: missing operand');
                        return;
                    }
                    const parent = resolvePath('.');
                    if (parent.children[dirName]) {
                        term.writeln(`mkdir: cannot create directory ‘${dirName}’: File exists`);
                    } else {
                        parent.children[dirName] = { type: 'directory', children: {} };
                    }
                }
            },
            'touch': {
                description: 'Crea un nuovo file vuoto.',
                execute: (args, term) => {
                    const fileName = args[0];
                    if (!fileName) {
                        term.writeln('touch: missing file operand');
                        return;
                    }
                    const parent = resolvePath('.');
                    if (!parent.children[fileName]) {
                        parent.children[fileName] = { type: 'file', content: '' };
                    }
                }
            },
            'rm': {
                description: 'Rimuove un file o una directory.',
                execute: (args, term) => {
                    const targetName = args[0];
                    if (!targetName) {
                        term.writeln('rm: missing operand');
                        return;
                    }
                    const parent = resolvePath('.');
                    if (parent.children[targetName]) {
                        delete parent.children[targetName];
                    } else {
                        term.writeln(`rm: cannot remove '${targetName}': No such file or directory`);
                    }
                }
            },
            'fetch': {
                description: 'Recupera il contenuto da un URL. Uso: fetch <url>',
                execute: async (args, term) => {
                    const url = args[0];
                    if (!url) {
                        term.writeln('Uso: fetch <url>');
                        return;
                    }
                    // Using a CORS proxy
                    const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
                    try {
                        const response = await fetch(proxyUrl);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.text();
                        term.writeln(data);
                    } catch (error) {
                        term.writeln(`Errore nel fetch: ${error.message}`);
                    }
                }
            },
            'type': {
                description: 'Scrive il testo con un effetto macchina da scrivere.',
                execute: async (args, term) => {
                    if (args.length === 0) {
                        term.writeln('Uso: type <testo da scrivere>');
                        return;
                    }
                    const text = args.join(' ');
                    await typewriter(text, term);
                    term.writeln(''); // Add a final newline
                }
            }
        };

        // --- INPUT HANDLING & EXECUTION ---
        let command = '';
        let commandHistory = [];
        let historyIndex = 0;

        term.prompt = () => {
            term.write(`\r\n[lorel@axun ${currentPath}]$ `);
        };

        function typewriter(text, term) {
            return new Promise(resolve => {
                let i = 0;
                function type() {
                    if (i < text.length) {
                        term.write(text.charAt(i));
                        i++;
                        setTimeout(type, 30);
                    } else {
                        resolve();
                    }
                }
                type();
            });
        }

        async function executeCommand(line) {
            const pipelines = line.split('|').map(p => p.trim());
            let lastOutput = null;

            for (let i = 0; i < pipelines.length; i++) {
                let part = pipelines[i];
                let redirect = null;
                let append = false;
                let targetFile = '';

                if (part.includes('>>')) {
                    [part, targetFile] = part.split('>>').map(s => s.trim());
                    redirect = true;
                    append = true;
                } else if (part.includes('>')) {
                    [part, targetFile] = part.split('>').map(s => s.trim());
                    redirect = true;
                }

                const [cmd, ...args] = part.split(' ').filter(Boolean);

                if (commands[cmd]) {
                    const outputBuffer = [];
                    const originalWrite = term.write.bind(term);
                    const originalWriteln = term.writeln.bind(term);

                    // Override term.write to capture output
                    term.write = (text) => outputBuffer.push(text);
                    term.writeln = (text) => outputBuffer.push(text + '\r\n');

                    try {
                        await commands[cmd].execute(args, term, lastOutput);
                    } catch (e) {
                        originalWriteln(`Errore nell'esecuzione di ${cmd}: ${e.message}`);
                    }

                    // Restore original write functions
                    term.write = originalWrite;
                    term.writeln = originalWriteln;

                    lastOutput = outputBuffer.join('');

                    if (redirect && targetFile) {
                        const parentNode = getParentNode(targetFile) || resolvePath('.');
                        const fileName = targetFile.split('/').pop();
                        const existingFile = parentNode.children[fileName];

                        if (existingFile && existingFile.type === 'file') {
                            existingFile.content = append ? existingFile.content + lastOutput : lastOutput;
                        } else {
                            parentNode.children[fileName] = { type: 'file', content: lastOutput };
                        }
                        lastOutput = null; // Consume output
                    } else if (i === pipelines.length - 1 && lastOutput) {
                        term.write(lastOutput);
                    }
                }
                 else if (cmd) {
                    term.writeln(`Comando non trovato: ${cmd}`);
                    break; // Stop pipeline on error
                }
            }
        }

        term.onKey(async ({ key, domEvent }) => {
            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            if (domEvent.keyCode === 13) { // Enter
                if (command.trim()) {
                    term.writeln('');
                    await executeCommand(command.trim());
                    if (commandHistory[commandHistory.length - 1] !== command) {
                        commandHistory.push(command);
                    }
                    historyIndex = commandHistory.length;
                    saveState();
                }
                command = '';
                term.prompt();
            } else if (domEvent.keyCode === 8) { // Backspace
                if (command.length > 0) {
                    term.write('\b \b');
                    command = command.slice(0, -1);
                }
            } else if (domEvent.keyCode === 9) { // Tab
                domEvent.preventDefault();
                const matchingCommands = Object.keys(commands).filter(c => c.startsWith(command));
                if (matchingCommands.length === 1) {
                    const completion = matchingCommands[0].substring(command.length);
                    term.write(completion);
                    command += completion;
                }
            } else if (domEvent.keyCode === 38) { // Arrow Up
                if (historyIndex > 0) {
                    historyIndex--;
                    term.write('\x1b[2K\r'); // Clear line
                    term.prompt();
                    command = commandHistory[historyIndex];
                    term.write(command);
                }
            } else if (domEvent.keyCode === 40) { // Arrow Down
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    term.write('\x1b[2K\r');
                    term.prompt();
                    command = commandHistory[historyIndex];
                    term.write(command);
                } else {
                    historyIndex = commandHistory.length;
                    term.write('\x1b[2K\r');
                    term.prompt();
                    command = '';
                }
            } else if (printable) {
                command += key;
                term.write(key);
            }
        });

        // --- STARTUP SEQUENCE ---
        async function start() {
            loadState();
            figlet.text('Lorel Axun', {
                font: 'Standard',
                horizontalLayout: 'default',
                verticalLayout: 'default'
            }, function(err, data) {
                if (err) {
                    console.log('Something went wrong...');
                    console.dir(err);
                    return;
                }
                term.writeln(data);
                const welcomeMessage = `Benvenuto. Sono Lorel Axun. Digita 'help' per iniziare.\r\n`;
                typewriter(welcomeMessage, term).then(() => {
                    term.prompt();
                    term.focus();
                });
            });
        }

        start();

    </script>
</body>
</html>