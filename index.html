<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://unpkg.com/xterm@5.3.0/css/xterm.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #0f0;
            font-family: 'monospace', monospace;
            overflow: hidden;
        }

        #terminal-container {
            width: 100%;
            height: 100%;
            padding: 10px;
            box-sizing: border-box;
        }

        #desktop {
            width: 100%;
            height: 100%;
            background: url('https://i.imgur.com/xIIiL5d.jpg') no-repeat center center fixed;
            background-size: cover;
            position: relative;
            overflow: hidden;
        }

        .window {
            position: absolute;
            border: 1px solid #555;
            background-color: rgba(20, 20, 20, 0.8);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            min-width: 300px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .title-bar {
            background-color: #333;
            color: #fff;
            padding: 5px;
            cursor: move;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
        }
        
        .title-bar .title { 
            font-weight: bold;
            padding-left: 5px;
        }

        .close-btn {
            background: #ff5f56;
            border: 1px solid #e0443e;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            cursor: pointer;
            padding: 0;
        }

        .window-body {
            flex-grow: 1;
            padding: 5px;
            box-sizing: border-box;
            overflow: auto;
        }
        
        #terminal-window-body {
            padding: 0 10px;
        }

        #editor {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #0d0d0d;
            z-index: 1000;
            display: none;
            flex-direction: column;
        }
        #editor-textarea {
            flex-grow: 1;
            background: #0d0d0d;
            color: #0f0;
            border: none;
            outline: none;
            font-family: 'monospace', monospace;
            font-size: 14px;
            padding: 10px;
        }
        #editor-status {
            padding: 5px;
            background: #333;
            font-size: 12px;
        }

        #dock {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(50, 50, 50, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 5px;
            display: flex;
            gap: 10px;
            align-items: flex-end;
            z-index: 100;
        }

        .dock-item {
            width: 50px;
            height: 50px;
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.1s ease-out, margin-bottom 0.1s ease-out;
            position: relative;
        }

        .dock-item .tooltip {
            visibility: hidden;
            background-color: #222;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        .dock-item:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        #explorer-body {
            padding: 5px;
            height: calc(100% - 35px);
            overflow-y: auto;
            background: #111;
            color: #eee;
        }
        #explorer-path {
            padding: 2px 5px;
            background: #222;
            border-bottom: 1px solid #444;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow-x: auto;
        }
        .explorer-item {
            padding: 3px 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 3px;
        }
        .explorer-item:hover {
            background-color: #333;
        }
        .explorer-item .icon::before {
            font-family: monospace;
            display: inline-block;
            width: 1em;
            text-align: center;
        }
        .explorer-item.directory .icon::before {
            content: 'üìÅ';
        }
        .explorer-item.file .icon::before {
            content: 'üìÑ';
        }

    </style>
</head>
<body>
    <div id="terminal-container"></div>
    <div id="desktop" style="display: none;">
        <div id="terminal-window" class="window" style="width: 600px; height: 400px; top: 50px; left: 50px;">
            <div class="title-bar">
                <span class="title">Terminal</span>
                <button class="close-btn" data-window="terminal-window">√ó</button>
            </div>
            <div class="window-body" id="terminal-window-body"></div>
        </div>

        <div id="explorer-window" class="window" style="display: none; width: 400px; height: 300px; top: 150px; left: 150px;">
            <div class="title-bar">
                <span class="title">Explorer</span>
                <button class="close-btn" data-window="explorer-window">√ó</button>
            </div>
            <div class="window-body" id="explorer-body">
                <div id="explorer-path">/home/user</div>
                <div id="explorer-content"></div>
            </div>
        </div>

        <div id="dock"></div>
    </div>
    <div id="editor">
        <textarea id="editor-textarea"></textarea>
        <div id="editor-status">File: | Press Ctrl+S to Save, Ctrl+Q to Quit</div>
    </div>

    <script src="https://unpkg.com/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet/lib/figlet.js"></script>

    <script>
        const termContainer = document.getElementById('terminal-container');
        const term = new Xterm.Terminal({ cursorBlink: true, theme: { background: '#000', foreground: '#0f0' } });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(termContainer);
        fitAddon.fit();
        window.addEventListener('resize', () => fitAddon.fit());

        let state = {
            vfs: {
                '/': {
                    type: 'directory',
                    content: {
                        'home': {
                            type: 'directory',
                            content: {
                                'user': {
                                    type: 'directory',
                                    content: {
                                        '.axunrc': {
                                            type: 'file',
                                            content: 'echo "Welcome to Lorel Axun OS"\nalias ll="ls -l"'
                                        }
                                    }
                                }
                            }
                        },
                        'bin': { type: 'directory', content: {} },
                        'etc': { type: 'directory', content: {} },
                    }
                }
            },
            env: {
                'USER': 'user',
                'HOME': '/home/user',
                'PS1': 'guest@axun:[~]$ '
            },
            cwd: '/home/user',
            history: [],
            aliases: {}
        };

        function saveState() {
            localStorage.setItem('lorel_axun_state', JSON.stringify(state));
        }

        function loadState() {
            const savedState = localStorage.getItem('lorel_axun_state');
            if (savedState) {
                state = JSON.parse(savedState);
            }
        }

        function resolvePath(path) {
            if (!path.startsWith('/')) {
                path = state.cwd === '/' ? `/${path}` : `${state.cwd}/${path}`;
            }
            const parts = path.split('/').filter(p => p);
            const resolved = [];
            for (const part of parts) {
                if (part === '.') continue;
                if (part === '..') {
                    resolved.pop();
                } else {
                    resolved.push(part);
                }
            }
            return '/' + resolved.join('/');
        }

        function getNode(path) {
            const resolvedPath = resolvePath(path);
            let current = state.vfs['/'];
            if (resolvedPath === '/') return current;
            const parts = resolvedPath.split('/').filter(p => p);
            for (const part of parts) {
                if (current && current.type === 'directory' && current.content[part]) {
                    current = current.content[part];
                } else {
                    return null;
                }
            }
            return current;
        }

        function getParentNode(path) {
            const resolvedPath = resolvePath(path);
            const parentPath = resolvedPath.substring(0, resolvedPath.lastIndexOf('/')) || '/';
            return getNode(parentPath);
        }

        function getEnv(key) {
            return state.env[key] || '';
        }

        let command = '';
        let historyIndex = -1;

        function printPrompt() {
            const ps1 = getEnv('PS1').replace('~', getEnv('HOME'));
            term.write(`\r\n${ps1}`);
        }

        async function runCommand(fullCommand) {
            state.history.push(fullCommand);
            historyIndex = state.history.length;

            const pipelines = fullCommand.split('|').map(s => s.trim());
            let input = '';

            for (let i = 0; i < pipelines.length; i++) {
                let cmdPart = pipelines[i];
                let output = '';
                let error = '';

                const redirectionMatch = cmdPart.match(/(.*?)(\s*(>>?)\s*(.*))$/);
                let redirectOp = null;
                let redirectFile = null;

                if (redirectionMatch) {
                    cmdPart = redirectionMatch[1].trim();
                    redirectOp = redirectionMatch[3];
                    redirectFile = redirectionMatch[4].trim();
                }

                const [cmd, ...args] = cmdPart.split(' ').filter(Boolean);
                const aliasedCmd = state.aliases[cmd] || cmd;
                const [finalCmd, ...finalArgs] = [...aliasedCmd.split(' '), ...args];

                if (commands[finalCmd]) {
                    try {
                        output = await commands[finalCmd](finalArgs, input);
                    } catch (e) {
                        error = e.message;
                    }
                } else {
                    error = `command not found: ${cmd}`;
                }

                if (error) {
                    term.write(`\r\n${error}`);
                    break;
                }

                if (redirectFile) {
                    const filePath = resolvePath(redirectFile);
                    const parent = getParentNode(filePath);
                    const fileName = filePath.split('/').pop();
                    if (!parent || parent.type !== 'directory') {
                        term.write(`\r\nError: Cannot write to ${redirectFile}: No such directory`);
                    } else {
                        const existingNode = parent.content[fileName];
                        if (redirectOp === '>') {
                            parent.content[fileName] = { type: 'file', content: output };
                        } else if (redirectOp === '>>') {
                            if (existingNode && existingNode.type === 'file') {
                                existingNode.content += output;
                            } else {
                                parent.content[fileName] = { type: 'file', content: output };
                            }
                        }
                    }
                } else if (i < pipelines.length - 1) {
                    input = output;
                } else if (output) {
                    term.write(`\r\n${output.replace(/\n/g, '\r\n')}`);
                }
            }
            printPrompt();
            saveState();
        }

        term.onKey(({ key, domEvent }) => {
            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            if (domEvent.keyCode === 13) { // Enter
                if (command.trim()) {
                    runCommand(command);
                }
                command = '';
                if (!command) printPrompt();
            } else if (domEvent.keyCode === 8) { // Backspace
                if (command.length > 0) {
                    term.write('\b \b');
                    command = command.slice(0, -1);
                }
            } else if (domEvent.keyCode === 38) { // Arrow Up
                if (historyIndex > 0) {
                    historyIndex--;
                    term.write(`\r${' '.repeat(getEnv('PS1').length + command.length)}`);
                    command = state.history[historyIndex];
                    printPrompt();
                    term.write(command);
                }
            } else if (domEvent.keyCode === 40) { // Arrow Down
                if (historyIndex < state.history.length - 1) {
                    historyIndex++;
                    term.write(`\r${' '.repeat(getEnv('PS1').length + command.length)}`);
                    command = state.history[historyIndex];
                    printPrompt();
                    term.write(command);
                } else {
                    historyIndex = state.history.length;
                    term.write(`\r${' '.repeat(getEnv('PS1').length + command.length)}`);
                    command = '';
                    printPrompt();
                }
            } else if (printable) {
                command += key;
                term.write(key);
            }
        });

        const commands = {
            help: () => 'Available commands: ls, cd, pwd, cat, mkdir, touch, rm, echo, clear, help, fetch, edit, js, startx, env, export, unset',
            ls: (args) => {
                const path = args[0] || state.cwd;
                const node = getNode(path);
                if (!node || node.type !== 'directory') return `ls: cannot access '${path}': No such file or directory`;
                return Object.keys(node.content).map(name => node.content[name].type === 'directory' ? `${name}/` : name).join('\n');
            },
            cd: (args) => {
                if (!args[0]) return '';
                const newPath = resolvePath(args[0]);
                const node = getNode(newPath);
                if (node && node.type === 'directory') {
                    state.cwd = newPath;
                } else {
                    return `cd: no such file or directory: ${args[0]}`;
                }
                return '';
            },
            pwd: () => state.cwd,
            cat: (args) => {
                const node = getNode(args[0]);
                if (!node) return `cat: ${args[0]}: No such file or directory`;
                if (node.type === 'directory') return `cat: ${args[0]}: Is a directory`;
                return node.content;
            },
            mkdir: (args) => {
                const newDirPath = resolvePath(args[0]);
                const parent = getParentNode(newDirPath);
                const dirName = newDirPath.split('/').pop();
                if (parent && parent.type === 'directory' && !parent.content[dirName]) {
                    parent.content[dirName] = { type: 'directory', content: {} };
                } else {
                    return `mkdir: cannot create directory ‚Äò${args[0]}‚Äô: File exists or invalid path`;
                }
                return '';
            },
            touch: (args) => {
                const newFilePath = resolvePath(args[0]);
                const parent = getParentNode(newFilePath);
                const fileName = newFilePath.split('/').pop();
                if (parent && parent.type === 'directory' && !parent.content[fileName]) {
                    parent.content[fileName] = { type: 'file', content: '' };
                } else if (!parent || parent.type !== 'directory') {
                     return `touch: cannot touch '${args[0]}': No such file or directory`;
                }
                return '';
            },
            rm: (args) => {
                const path = resolvePath(args[0]);
                const parent = getParentNode(path);
                const name = path.split('/').pop();
                if (parent && parent.content[name]) {
                    delete parent.content[name];
                } else {
                    return `rm: cannot remove '${args[0]}': No such file or directory`;
                }
                return '';
            },
            echo: (args, input) => input ? input : args.join(' '),
            clear: () => { term.clear(); return ''; },
            fetch: async (args) => {
                try {
                    const response = await fetch(args[0]);
                    if (!response.ok) return `HTTP error! status: ${response.status}`;
                    return await response.text();
                } catch (e) {
                    return `Fetch error: ${e.message}`;
                }
            },
            edit: (args) => {
                return new Promise(resolve => {
                    const filePath = resolvePath(args[0]);
                    const node = getNode(filePath);
                    if (!node || node.type !== 'file') {
                        resolve(`edit: cannot open ${args[0]}`);
                        return;
                    }
                    const editor = document.getElementById('editor');
                    const textarea = document.getElementById('editor-textarea');
                    const status = document.getElementById('editor-status');
                    textarea.value = node.content;
                    status.textContent = `File: ${filePath} | Press Ctrl+S to Save, Ctrl+Q to Quit`;
                    editor.style.display = 'flex';
                    textarea.focus();

                    const keydownHandler = (e) => {
                        if (e.ctrlKey && e.key === 's') {
                            e.preventDefault();
                            node.content = textarea.value;
                            saveState();
                            status.textContent = `File: ${filePath} | Saved! | Press Ctrl+Q to Quit`;
                        } else if (e.ctrlKey && e.key === 'q') {
                            e.preventDefault();
                            editor.style.display = 'none';
                            document.removeEventListener('keydown', keydownHandler);
                            term.focus();
                            resolve('');
                        }
                    };
                    document.addEventListener('keydown', keydownHandler);
                });
            },
            js: (args) => {
                const fileNode = getNode(args[0]);
                if (!fileNode || fileNode.type !== 'file') return `js: file not found: ${args[0]}`;
                let output = '';
                const sandbox = {
                    axun: {
                        log: (...args) => { output += args.map(String).join(' ') + '\n'; },
                        vfs: {
                            read: (path) => {
                                const node = getNode(path);
                                return (node && node.type === 'file') ? node.content : null;
                            },
                            write: (path, content) => {
                                const resolvedPath = resolvePath(path);
                                const parent = getParentNode(resolvedPath);
                                const name = resolvedPath.split('/').pop();
                                if (parent && parent.type === 'directory') {
                                    parent.content[name] = { type: 'file', content: String(content) };
                                    return true;
                                } return false;
                            },
                            list: (path) => {
                                const node = getNode(path);
                                return (node && node.type === 'directory') ? Object.keys(node.content) : null;
                            }
                        },
                        env: {
                            get: (key) => state.env[key],
                            set: (key, value) => { state.env[key] = value; }
                        }
                    }
                };
                try {
                    const func = new Function('axun', fileNode.content);
                    func(sandbox.axun);
                } catch (e) {
                    return `js error: ${e.message}`;
                }
                return output.trim();
            },
            startx: () => {
                document.getElementById('terminal-container').style.display = 'none';
                const desktop = document.getElementById('desktop');
                desktop.style.display = 'block';
                const termWindowBody = document.getElementById('terminal-window-body');
                termWindowBody.appendChild(term.element);
                fitAddon.fit();
                initDock();
                return 'Starting graphical environment...';
            },
            env: () => Object.entries(state.env).map(([k, v]) => `${k}=${v}`).join('\n'),
            export: (args) => {
                args.forEach(arg => {
                    const [key, ...valueParts] = arg.split('=');
                    if (key) state.env[key] = valueParts.join('=');
                });
                return '';
            },
            unset: (args) => {
                args.forEach(key => delete state.env[key]);
                return '';
            }
        };

        function processAliases(rcContent) {
            state.aliases = {};
            rcContent.split('\n').forEach(line => {
                const match = line.match(/^alias\s+([^=]+)='([^']*)'$/);
                if (match) {
                    state.aliases[match[1]] = match[2];
                }
            });
        }

        async function runStartupScript() {
            const rcPath = resolvePath('~/.axunrc');
            const rcNode = getNode(rcPath);
            if (rcNode && rcNode.type === 'file') {
                processAliases(rcNode.content);
                const commandsToRun = rcNode.content.split('\n').filter(line => !line.trim().startsWith('alias') && line.trim() !== '');
                for (const cmd of commandsToRun) {
                    await runCommand(cmd);
                }
            }
        }
        
        // --- GUI Logic ---
        function makeDraggable(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const titleBar = elmnt.querySelector(".title-bar");
            
            const dragMouseDown = (e) => {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                bringToFront(elmnt);
            }

            if (titleBar) {
                titleBar.onmousedown = dragMouseDown;
            } else {
                elmnt.onmousedown = dragMouseDown;
            }

            const elementDrag = (e) => {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
            }

            const closeDragElement = () => {
                document.onmouseup = null;
                document.onmousemove = null;
            }
            
            elmnt.addEventListener('mousedown', () => bringToFront(elmnt));
        }

        let zIndexCounter = 10;
        function bringToFront(elmnt) {
            elmnt.style.zIndex = ++zIndexCounter;
        }

        function openTerminal() {
            const termWindow = document.getElementById('terminal-window');
            termWindow.style.display = 'block';
            bringToFront(termWindow);
        }

        const explorerWindow = document.getElementById('explorer-window');
        const explorerContent = document.getElementById('explorer-content');
        const explorerPath = document.getElementById('explorer-path');
        let currentExplorerPath = getEnv('HOME');

        function openExplorer() {
            explorerWindow.style.display = 'block';
            bringToFront(explorerWindow);
            renderExplorer(currentExplorerPath);
        }

        function renderExplorer(path) {
            currentExplorerPath = resolvePath(path);
            explorerPath.textContent = currentExplorerPath;
            explorerContent.innerHTML = '';

            const node = getNode(currentExplorerPath);
            if (!node || node.type !== 'directory') {
                explorerContent.textContent = 'Error: Path not found or not a directory.';
                return;
            }

            if (currentExplorerPath !== '/') {
                const parentPath = currentExplorerPath.substring(0, currentExplorerPath.lastIndexOf('/')) || '/';
                const parentDiv = document.createElement('div');
                parentDiv.className = 'explorer-item directory';
                parentDiv.innerHTML = `<span class="icon"></span><span>..</span>`;
                parentDiv.onclick = () => renderExplorer(parentPath);
                explorerContent.appendChild(parentDiv);
            }

            const entries = Object.keys(node.content).sort();
            for (const entry of entries) {
                const childNode = node.content[entry];
                const div = document.createElement('div');
                div.className = `explorer-item ${childNode.type}`;
                div.innerHTML = `<span class="icon"></span><span>${entry}</span>`;
                if (childNode.type === 'directory') {
                    const newPath = currentExplorerPath === '/' ? `/${entry}` : `${currentExplorerPath}/${entry}`;
                    div.onclick = () => renderExplorer(newPath);
                }
                explorerContent.appendChild(div);
            }
        }

        const dockApps = [
            { name: 'Terminal', icon: '‚ùØ_', action: openTerminal },
            { name: 'Explorer', icon: 'üìÅ', action: openExplorer }
        ];

        function initDock() {
            const dock = document.getElementById('dock');
            dock.innerHTML = '';
            dockApps.forEach(app => {
                const item = document.createElement('div');
                item.className = 'dock-item';
                item.innerHTML = `${app.icon}<span class="tooltip">${app.name}</span>`;
                item.onclick = app.action;
                dock.appendChild(item);
            });

            const dockItems = dock.querySelectorAll('.dock-item');
            dock.addEventListener('mousemove', (e) => {
                const dockRect = dock.getBoundingClientRect();
                dockItems.forEach(item => {
                    const itemRect = item.getBoundingClientRect();
                    const offset = Math.abs(e.clientX - (itemRect.left + itemRect.width / 2));
                    const scale = Math.max(1, 1.8 - offset / 100);
                    item.style.transform = `scale(${scale})`;
                    item.style.marginBottom = `${(scale - 1) * 20}px`;
                });
            });

            dock.addEventListener('mouseleave', () => {
                dockItems.forEach(item => {
                    item.style.transform = 'scale(1)';
                    item.style.marginBottom = '0px';
                });
            });
        }

        // --- Init --- 
        figlet.parseFont('Standard', figlet.fonts.Standard);
        figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {
            if (data) term.write(data.replace(/\n/g, '\r\n'));
            term.write('\r\nType "help" for a list of commands.');
            loadState();
            runStartupScript().then(printPrompt);
        });
        
        makeDraggable(document.getElementById('terminal-window'));
        makeDraggable(document.getElementById('explorer-window'));

        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const windowId = e.target.dataset.window;
                if (windowId) {
                    document.getElementById(windowId).style.display = 'none';
                }
            });
        });

    </script>
</body>
</html>