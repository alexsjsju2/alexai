<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        :root {
            --background: #1a1b26;
            --foreground: #c0caf5;
            --black: #15161e;
            --red: #f7768e;
            --green: #9ece6a;
            --yellow: #e0af68;
            --blue: #7aa2f7;
            --magenta: #bb9af7;
            --cyan: #7dcfff;
            --white: #a9b1d6;
            --comment: #565f89;
        }

        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: var(--background);
            color: var(--foreground);
            font-family: 'Menlo', 'Consolas', 'monospace';
            overflow: hidden;
        }

        #terminal-container {
            width: 100%;
            height: 100%;
            padding: 10px;
            box-sizing: border-box;
        }

        #desktop {
            display: none;
            width: 100%;
            height: 100%;
            background: var(--background) url('https://source.unsplash.com/random/1920x1080?technology,abstract') no-repeat center center;
            background-size: cover;
            position: relative;
        }

        .window {
            position: absolute;
            background-color: rgba(26, 27, 38, 0.9);
            border: 1px solid var(--comment);
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            min-width: 300px;
            min-height: 200px;
        }

        .window-header {
            background-color: var(--black);
            color: var(--foreground);
            padding: 5px 10px;
            cursor: move;
            border-bottom: 1px solid var(--comment);
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .window-title { font-weight: bold; }

        .window-controls button {
            background: none;
            border: none;
            color: var(--foreground);
            font-weight: bold;
            cursor: pointer;
            padding: 2px 5px;
        }
        .window-controls button:hover { background-color: var(--red); color: var(--black); }

        .window-body {
            padding: 10px;
            flex-grow: 1;
            overflow: auto;
        }

        #dock {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 42, 54, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px;
            display: flex;
            gap: 10px;
        }

        .dock-icon {
            width: 50px;
            height: 50px;
            background-color: var(--comment);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .dock-icon:hover { transform: scale(1.2) translateY(-5px); }

        #editor {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--background);
            z-index: 1000;
            flex-direction: column;
        }
        #editor-textarea {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--foreground);
            font-family: 'Menlo', 'Consolas', 'monospace';
            font-size: 14px;
            padding: 10px;
            resize: none;
            outline: none;
        }
        #editor-status {
            background-color: var(--comment);
            color: var(--background);
            padding: 5px 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>

    <div id="terminal-container"></div>
    <div id="desktop">
        <div id="dock">
            <div class="dock-icon" id="dock-terminal" title="Terminal">&#x1F4BB;</div>
            <div class="dock-icon" id="dock-files" title="File Explorer">&#x1F4C1;</div>
        </div>
    </div>
    <div id="editor">
        <textarea id="editor-textarea"></textarea>
        <div id="editor-status"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.js"></script>

    <script>
        // --- VIRTUAL FILE SYSTEM --- //
        class VFS {
            constructor() {
                this.fs = {};
                this.load();
                if (!this.fs['/']) {
                    this.fs['/'] = { type: 'dir', content: {} };
                    this.mkdir('/home');
                    this.mkdir('/home/user');
                    this.mkdir('/bin');
                    this.writeFile('/bin/test.js', 'console.log("Hello from JS file!");');
                }
                this.cwd = '/home/user';
            }

            save() {
                localStorage.setItem('axun_vfs', JSON.stringify(this.fs));
            }

            load() {
                const savedFs = localStorage.getItem('axun_vfs');
                if (savedFs) {
                    this.fs = JSON.parse(savedFs);
                } else {
                    this.fs = {};
                }
            }

            _getNode(path) {
                const parts = path.split('/').filter(p => p);
                let current = this.fs['/'];
                if (path === '/') return current;

                for (const part of parts) {
                    if (!current || current.type !== 'dir' || !current.content[part]) {
                        return null;
                    }
                    current = current.content[part];
                }
                return current;
            }

            _getParentNode(path) {
                const parts = path.split('/').filter(p => p);
                const parentPath = '/' + parts.slice(0, -1).join('/');
                return this._getNode(parentPath);
            }

            resolvePath(path) {
                if (path.startsWith('/')) {
                    return path;
                }
                const newPath = this.cwd.split('/').filter(p => p);
                path.split('/').filter(p => p).forEach(part => {
                    if (part === '..') {
                        newPath.pop();
                    } else if (part !== '.') {
                        newPath.push(part);
                    }
                });
                return '/' + newPath.join('/');
            }

            async list(path) {
                const resolvedPath = this.resolvePath(path);
                const node = this._getNode(resolvedPath);
                if (!node || node.type !== 'dir') {
                    throw new Error(`ls: cannot access '${path}': No such file or directory`);
                }
                return Object.keys(node.content).map(name => {
                    return node.content[name].type === 'dir' ? `${name}/` : name;
                });
            }

            async mkdir(path) {
                const resolvedPath = this.resolvePath(path);
                if (this._getNode(resolvedPath)) {
                    throw new Error(`mkdir: cannot create directory '${path}': File exists`);
                }
                const parent = this._getParentNode(resolvedPath);
                const newDirName = resolvedPath.split('/').pop();
                if (!parent || parent.type !== 'dir') {
                    throw new Error(`mkdir: cannot create directory '${path}': No such file or directory`);
                }
                parent.content[newDirName] = { type: 'dir', content: {} };
                this.save();
            }

            async writeFile(path, content) {
                const resolvedPath = this.resolvePath(path);
                const parent = this._getParentNode(resolvedPath);
                const fileName = resolvedPath.split('/').pop();
                if (!parent || parent.type !== 'dir') {
                    throw new Error(`writeFile: cannot write to '${path}': No such file or directory`);
                }
                parent.content[fileName] = { type: 'file', content: content };
                this.save();
            }

            async readFile(path) {
                const resolvedPath = this.resolvePath(path);
                const node = this._getNode(resolvedPath);
                if (!node) {
                    throw new Error(`cat: ${path}: No such file or directory`);
                }
                if (node.type === 'dir') {
                    throw new Error(`cat: ${path}: Is a directory`);
                }
                return node.content;
            }

            async exists(path) {
                const resolvedPath = this.resolvePath(path);
                return !!this._getNode(resolvedPath);
            }

            async rm(path) {
                const resolvedPath = this.resolvePath(path);
                const node = this._getNode(resolvedPath);
                if (!node) {
                    throw new Error(`rm: cannot remove '${path}': No such file or directory`);
                }
                if (node.type === 'dir' && Object.keys(node.content).length > 0) {
                    throw new Error(`rm: cannot remove '${path}': Directory not empty`);
                }
                const parent = this._getParentNode(resolvedPath);
                const fileName = resolvedPath.split('/').pop();
                delete parent.content[fileName];
                this.save();
            }
        }

        const vfs = new VFS();

        // --- TERMINAL SETUP & SHELL LOGIC --- //
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: 'var(--background)',
                foreground: 'var(--foreground)',
                black: 'var(--black)',
                red: 'var(--red)',
                green: 'var(--green)',
                yellow: 'var(--yellow)',
                blue: 'var(--blue)',
                magenta: 'var(--magenta)',
                cyan: 'var(--cyan)',
                white: 'var(--white)',
            }
        });
        term.open(document.getElementById('terminal-container'));

        let commandHistory = [];
        let historyIndex = -1;
        let currentCommand = '';
        let env = JSON.parse(localStorage.getItem('axun_env')) || { USER: 'user', HOST: 'axun.os' };

        function saveEnv() {
            localStorage.setItem('axun_env', JSON.stringify(env));
        }

        function prompt() {
            const user = env.USER || 'user';
            const host = env.HOST || 'axun.os';
            const path = vfs.cwd.replace('/home/user', '~');
            term.write(`\x1b[32m${user}@${host}\x1b[0m:\x1b[34m${path}\x1b[0m$ `);
        }

        async function executeCommand(line) {
            const parts = line.trim().split(/\s+/);
            const command = parts[0];
            const args = parts.slice(1);

            if (!command) return '';

            const commands = {
                'help': async () => 'Available commands: ls, cd, cat, mkdir, rm, pwd, echo, clear, help, fetch, js, edit, startx, env, export, unset',
                'ls': async (args) => (await vfs.list(args[0] || '.')).join('\n'),
                'cd': async (args) => {
                    if (!args[0]) { vfs.cwd = '/home/user'; return ''; }
                    const newPath = vfs.resolvePath(args[0]);
                    const node = vfs._getNode(newPath);
                    if (node && node.type === 'dir') {
                        vfs.cwd = newPath;
                        return '';
                    } else {
                        throw new Error(`cd: ${args[0]}: No such file or directory`);
                    }
                },
                'cat': async (args) => vfs.readFile(args[0]),
                'mkdir': async (args) => { await vfs.mkdir(args[0]); return ''; },
                'rm': async (args) => { await vfs.rm(args[0]); return ''; },
                'pwd': async () => vfs.cwd,
                'echo': async (args) => args.join(' '),
                'clear': async () => { term.clear(); return ''; },
                'startx': async () => { 
                    document.getElementById('terminal-container').style.display = 'none';
                    document.getElementById('desktop').style.display = 'block';
                    return 'Starting graphical environment...';
                },
                'edit': async (args) => {
                    if (!args[0]) throw new Error('edit: filename required');
                    await openEditor(args[0]);
                    return '';
                },
                'fetch': async (args) => {
                    try {
                        const response = await fetch(args[0]);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        return await response.text();
                    } catch (e) {
                        throw new Error(`fetch: failed to fetch ${args[0]}: ${e.message}`);
                    }
                },
                'js': async (args) => {
                    const path = args[0];
                    if (!path) throw new Error('js: file path required');
                    const code = await vfs.readFile(path);
                    let output = '';
                    const sandbox = {
                        console: {
                            log: (...args) => { output += args.map(String).join(' ') + '\n'; }
                        }
                    };
                    try {
                        const func = new Function(...Object.keys(sandbox), code);
                        func(...Object.values(sandbox));
                        return output.trim();
                    } catch (e) {
                        throw new Error(`js: error executing ${path}: ${e.message}`);
                    }
                },
                'env': async () => Object.entries(env).map(([k, v]) => `${k}=${v}`).join('\n'),
                'export': async (args) => {
                    args.forEach(arg => {
                        const [key, ...value] = arg.split('=');
                        if (key) env[key] = value.join('=');
                    });
                    saveEnv();
                    return '';
                },
                'unset': async (args) => {
                    args.forEach(key => delete env[key]);
                    saveEnv();
                    return '';
                }
            };

            if (commands[command]) {
                return await commands[command](args);
            } else {
                throw new Error(`${command}: command not found`);
            }
        }

        async function handleLine(line) {
            if (line.trim()) {
                commandHistory.unshift(line);
                if (commandHistory.length > 50) commandHistory.pop();
            }
            historyIndex = -1;

            try {
                // Handle pipelines and redirections
                let input = '';
                const pipelineParts = line.split('|').map(p => p.trim());

                for (let i = 0; i < pipelineParts.length; i++) {
                    let part = pipelineParts[i];
                    let outputToFile = null;
                    let appendToFile = null;

                    if (part.includes('>>')) {
                        [part, appendToFile] = part.split('>>').map(p => p.trim());
                    } else if (part.includes('>')) {
                        [part, outputToFile] = part.split('>').map(p => p.trim());
                    }

                    // Inject input from previous command
                    if (input) {
                        part += ` ${input}`;
                    }

                    const result = await executeCommand(part);

                    if (outputToFile) {
                        await vfs.writeFile(outputToFile, result);
                        input = ''; // Redirection consumes output
                    } else if (appendToFile) {
                        let content = '';
                        try { content = await vfs.readFile(appendToFile); } catch (e) {}
                        await vfs.writeFile(appendToFile, content + result);
                        input = '';
                    } else {
                        input = result; // Pass to next command in pipeline
                    }
                }

                if (input) {
                    term.writeln(input);
                }
            } catch (e) {
                term.writeln(`\x1b[31mError: ${e.message}\x1b[0m`);
            }
        }

        term.onKey(({ key, domEvent }) => {
            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            if (domEvent.keyCode === 13) { // Enter
                term.writeln('');
                handleLine(currentCommand).then(() => {
                    currentCommand = '';
                    prompt();
                });
            } else if (domEvent.keyCode === 8) { // Backspace
                if (currentCommand.length > 0) {
                    term.write('\b \b');
                    currentCommand = currentCommand.slice(0, -1);
                }
            } else if (domEvent.keyCode === 38) { // Arrow Up
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    term.write('\x1b[2K\r'); // Clear line
                    prompt();
                    currentCommand = commandHistory[historyIndex];
                    term.write(currentCommand);
                }
            } else if (domEvent.keyCode === 40) { // Arrow Down
                if (historyIndex > 0) {
                    historyIndex--;
                    term.write('\x1b[2K\r');
                    prompt();
                    currentCommand = commandHistory[historyIndex];
                    term.write(currentCommand);
                } else {
                    historyIndex = -1;
                    term.write('\x1b[2K\r');
                    prompt();
                    currentCommand = '';
                }
            } else if (printable) {
                currentCommand += key;
                term.write(key);
            }
        });
        
        function typewriter(text, terminal, callback) {
            let i = 0;
            const speed = 25; // milliseconds
            function type() {
                if (i < text.length) {
                    const char = text.charAt(i);
                    if (char === '\n') {
                        terminal.writeln('');
                    } else {
                        terminal.write(char);
                    }
                    i++;
                    setTimeout(type, speed);
                } else if (callback) {
                    callback();
                }
            }
            type();
        }

        figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {
            if (err) {
                term.writeln('Something went wrong...');
                console.dir(err);
                prompt();
                return;
            }
            const welcomeMessage = data + '\n\nWelcome to Axun.OS. Type "help" for a list of commands.\n';
            
            typewriter(welcomeMessage, term, () => {
                vfs.exists('/home/user/.axunrc').then(exists => {
                    if (exists) {
                        handleLine('source /home/user/.axunrc').then(prompt);
                    } else {
                        prompt();
                    }
                });
            });
        });

        // --- EDITOR LOGIC --- //
        const editorElement = document.getElementById('editor');
        const editorTextarea = document.getElementById('editor-textarea');
        const editorStatus = document.getElementById('editor-status');
        let editorFilePath = '';

        async function openEditor(filePath) {
            editorFilePath = vfs.resolvePath(filePath);
            let content = '';
            try {
                content = await vfs.readFile(editorFilePath);
            } catch (e) {
                // File doesn't exist, which is fine
            }
            editorTextarea.value = content;
            editorStatus.textContent = `File: ${editorFilePath} | Press Ctrl+S to Save, Ctrl+Q to Quit`;
            editorElement.style.display = 'flex';
            editorTextarea.focus();
        }

        function closeEditor() {
            editorElement.style.display = 'none';
            term.focus();
        }

        editorTextarea.addEventListener('keydown', async (e) => {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                await vfs.writeFile(editorFilePath, editorTextarea.value);
                editorStatus.textContent = `Saved ${editorFilePath} | Press Ctrl+S to Save, Ctrl+Q to Quit`;
            }
            if (e.ctrlKey && e.key === 'q') {
                e.preventDefault();
                closeEditor();
            }
        });

        // --- DESKTOP ENVIRONMENT --- //
        document.getElementById('dock-terminal').addEventListener('click', () => {
            document.getElementById('desktop').style.display = 'none';
            document.getElementById('terminal-container').style.display = 'block';
            term.focus();
        });

    </script>
</body>
</html>