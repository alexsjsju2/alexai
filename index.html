<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lorel Axun</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css\" />\n    <style>\n        body, html { margin: 0; padding: 0; height: 100%; background-color: #000; overflow: hidden; }\n        #terminal-container { width: 100%; height: 100%; }\n    </style>\n</head>\n<body>\n    <div id=\"terminal-container\"></div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/figlet@1.7.0/lib/figlet.min.js\"></script>\n\n    <script>\n        const term = new Terminal({\n            cursorBlink: true,\n            theme: {\n                background: '#000000',\n                foreground: '#00ff00',\n                cursor: '#00ff00'\n            }\n        });\n        const fitAddon = new FitAddon.FitAddon();\n        term.loadAddon(fitAddon);\n        term.open(document.getElementById('terminal-container'));\n        fitAddon.fit();\n        window.addEventListener('resize', () => fitAddon.fit());\n\n        const prompt = ' Lâ€º ';\n        let currentLine = '';\n        let commandHistory = JSON.parse(localStorage.getItem('commandHistory')) || [];\n        let historyIndex = commandHistory.length;\n        let vfs;\n\n        // --- VFS Persistence --- \n        function saveVFS() {\n            localStorage.setItem('vfs', JSON.stringify(vfs));\n        }\n\n        function loadVFS() {\n            const savedVFS = localStorage.getItem('vfs');\n            if (savedVFS) {\n                vfs = JSON.parse(savedVFS);\n            } else {\n                vfs = {\n                    '/': { type: 'dir', content: ['home'] },\n                    '/home': { type: 'dir', content: ['user'] },\n                    '/home/user': { type: 'dir', content: ['readme.txt'] },\n                    '/home/user/readme.txt': { type: 'file', content: 'Benvenuto in Lorel Axun! Digita `help` per iniziare.' }\n                };\n                saveVFS();\n            }\n        }\n\n        loadVFS(); // Load VFS on startup\n        let currentPath = '/home/user';\n\n        // --- Utility Functions ---\n        function resolvePath(path) {\n            if (path.startsWith('/')) return path;\n            const parts = (currentPath === '/' ? '' : currentPath).split('/').concat(path.split('/'));\n            const resolved = [];\n            for (const part of parts) {\n                if (part === '' || part === '.') continue;\n                if (part === '..') resolved.pop();\n                else resolved.push(part);\n            }\n            return '/' + resolved.join('/');\n        }\n\n        function getPathContent(path) {\n            const resolved = resolvePath(path);\n            return vfs[resolved];\n        }\n\n        // --- Command Definitions ---\n        const commands = {\n            help: () => `Comandi disponibili:\\n  ciao, chi sei, cosa sai fare, echo, clear, ls, cd, cat, mkdir, touch, rm, fetch, help\\n  Usa 'comando | comando' per il pipelining e 'comando > file' per la redirezione.`,\n            ciao: () => 'Ciao! Sono Lorel Axun. Come posso aiutarti?',\n            'chi sei': () => 'Sono Lorel Axun, un\\\'interfaccia a riga di comando evolutiva.',\n            'cosa sai fare': () => 'Posso eseguire comandi, navigare un file system virtuale, recuperare dati dal web e molto altro. Prova `help`.',\n            echo: (args) => args.join(' '),\n            clear: () => { term.clear(); return ''; },\n            ls: (args) => {\n                const path = args.length > 0 ? args[0] : '.';\n                const resolvedPath = resolvePath(path);\n                const content = vfs[resolvedPath];\n                if (content && content.type === 'dir') {\n                    return content.content.join('\\n');\n                } else {\n                    return `ls: cannot access '${path}': No such file or directory`;\n                }\n            },\n            cd: (args) => {\n                if (args.length === 0) { currentPath = '/home/user'; return ''; }\n                const newPath = resolvePath(args[0]);\n                if (vfs[newPath] && vfs[newPath].type === 'dir') {\n                    currentPath = newPath;\n                    return '';\n                } else {\n                    return `cd: no such file or directory: ${args[0]}`;\n                }\n            },\n            cat: (args, input) => {\n                if (input) return input;\n                if (args.length === 0) return 'cat: missing operand';\n                const path = resolvePath(args[0]);\n                const file = vfs[path];\n                if (file && file.type === 'file') {\n                    return file.content;\n                } else {\n                    return `cat: ${args[0]}: No such file or directory`;\n                }\n            },\n            mkdir: (args) => {\n                if (args.length === 0) return 'mkdir: missing operand';\n                const newDirPath = resolvePath(args[0]);\n                const parentPath = resolvePath(args[0] + '/..');\n                if (vfs[newDirPath]) return `mkdir: cannot create directory '${args[0]}': File exists`;\n                if (!vfs[parentPath] || vfs[parentPath].type !== 'dir') return `mkdir: cannot create directory '${args[0]}': No such file or directory`;\n                vfs[newDirPath] = { type: 'dir', content: [] };\n                vfs[parentPath].content.push(args[0].split('/').pop());\n                saveVFS();\n                return '';\n            },\n            touch: (args) => {\n                if (args.length === 0) return 'touch: missing operand';\n                const newFilePath = resolvePath(args[0]);\n                const parentPath = resolvePath(args[0] + '/..');\n                if (vfs[newFilePath]) return ''; // File exists, do nothing\n                if (!vfs[parentPath] || vfs[parentPath].type !== 'dir') return `touch: cannot touch '${args[0]}': No such file or directory`;\n                vfs[newFilePath] = { type: 'file', content: '' };\n                vfs[parentPath].content.push(args[0].split('/').pop());\n                saveVFS();\n                return '';\n            },\n            rm: (args) => {\n                if (args.length === 0) return 'rm: missing operand';\n                const pathToRemove = resolvePath(args[0]);\n                const item = vfs[pathToRemove];\n                if (!item) return `rm: cannot remove '${args[0]}': No such file or directory`;\n                if (item.type === 'dir' && item.content.length > 0) return `rm: cannot remove '${args[0]}': Directory not empty`;\n                const parentPath = resolvePath(args[0] + '/..');\n                const parent = vfs[parentPath];\n                const itemName = args[0].split('/').pop();\n                parent.content = parent.content.filter(name => name !== itemName);\n                delete vfs[pathToRemove];\n                saveVFS();\n                return '';\n            },\n            fetch: async (args) => {\n                if (args.length === 0) return 'Usage: fetch <url>';\n                const url = args[0];\n                try {\n                    const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`);\n                    if (!response.ok) return `fetch: failed to fetch ${url} (status: ${response.status})`;\n                    return await response.text();\n                } catch (e) {\n                    return `fetch: network error: ${e.message}`;\n                }\n            }\n        };\n\n        // --- Input Handling and Execution ---\n        function writePrompt() {\n            term.write(`\\r\\n\\x1b[32m${currentPath}\\x1b[0m${prompt}`);\n        }\n\n        async function executeCommand(line) {\n            commandHistory.push(line);\n            if (commandHistory.length > 50) commandHistory.shift();\n            localStorage.setItem('commandHistory', JSON.stringify(commandHistory));\n            historyIndex = commandHistory.length;\n\n            const pipelineParts = line.split('|').map(p => p.trim());\n            let lastOutput = '';\n\n            for (let i = 0; i < pipelineParts.length; i++) {\n                let part = pipelineParts[i];\n                let redirect = null;\n                let redirectFile = '';\n                let append = false;\n\n                if (part.includes('>>')) {\n                    [part, redirectFile] = part.split('>>').map(s => s.trim());\n                    redirect = '>>';\n                } else if (part.includes('>')) {\n                    [part, redirectFile] = part.split('>').map(s => s.trim());\n                    redirect = '>';\n                }\n\n                const [command, ...args] = part.split(' ').filter(Boolean);\n                \n                if (commands[command]) {\n                    try {\n                        const result = await commands[command](args, lastOutput);\n                        lastOutput = result;\n                    } catch (e) {\n                        lastOutput = `Error executing ${command}: ${e.message}`;\n                        break;\n                    }\n                } else if (command) {\n                    lastOutput = `Comando non trovato: ${command}`;\n                    break;\n                }\n\n                if (redirect && i === pipelineParts.length - 1) {\n                    const filePath = resolvePath(redirectFile);\n                    const parentPath = resolvePath(redirectFile + '/..');\n                    if (!vfs[parentPath] || vfs[parentPath].type !== 'dir') {\n                        lastOutput = `bash: ${redirectFile}: No such file or directory`;\n                    } else {\n                        if (vfs[filePath] && vfs[filePath].type === 'dir') {\n                            lastOutput = `bash: ${redirectFile}: Is a directory`;\n                        } else {\n                            const fileExists = !!vfs[filePath];\n                            if (!fileExists) {\n                                vfs[parentPath].content.push(redirectFile.split('/').pop());\n                            }\n                            if (redirect === '>') {\n                                vfs[filePath] = { type: 'file', content: lastOutput };\n                            } else { // >>\n                                if (fileExists) {\n                                    vfs[filePath].content += '\\n' + lastOutput;\n                                } else {\n                                    vfs[filePath] = { type: 'file', content: lastOutput };\n                                }\n                            }\n                            saveVFS();\n                            lastOutput = ''; // No output to terminal when redirecting\n                        }\n                    }\n                }\n            }\n\n            if (lastOutput) {\n                term.write('\\r\\n' + lastOutput.replace(/\n/g, '\\r\\n'));\n            }\n            writePrompt();\n        }\n\n        term.onKey(({ key, domEvent }) => {\n            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;\n\n            if (domEvent.keyCode === 13) { // Enter\n                if (currentLine.trim()) {\n                    executeCommand(currentLine);\n                }\n                currentLine = '';\n                if (!currentLine.trim()) writePrompt();\n            } else if (domEvent.keyCode === 8) { // Backspace\n                if (currentLine.length > 0) {\n                    term.write('\\b \\b');\n                    currentLine = currentLine.slice(0, -1);\n                }\n            } else if (domEvent.keyCode === 9) { // Tab\n                domEvent.preventDefault();\n                const parts = currentLine.split(' ');\n                const toComplete = parts.pop() || '';\n                const available = Object.keys(commands);\n                const matches = available.filter(cmd => cmd.startsWith(toComplete));\n                if (matches.length === 1) {\n                    const completion = matches[0].substring(toComplete.length);\n                    term.write(completion);\n                    currentLine += completion;\n                }\n            } else if (domEvent.keyCode === 38) { // Up arrow\n                if (historyIndex > 0) {\n                    historyIndex--;\n                    term.write('\\r' + ' '.repeat(prompt.length + currentLine.length));\n                    currentLine = commandHistory[historyIndex];\n                    term.write(`\\r\\x1b[32m${currentPath}\\x1b[0m${prompt}` + currentLine);\n                }\n            } else if (domEvent.keyCode === 40) { // Down arrow\n                if (historyIndex < commandHistory.length - 1) {\n                    historyIndex++;\n                    term.write('\\r' + ' '.repeat(prompt.length + currentLine.length));\n                    currentLine = commandHistory[historyIndex];\n                    term.write(`\\r\\x1b[32m${currentPath}\\x1b[0m${prompt}` + currentLine);\n                } else {\n                    historyIndex = commandHistory.length;\n                    term.write('\\r' + ' '.repeat(prompt.length + currentLine.length));\n                    currentLine = '';\n                    term.write(`\\r\\x1b[32m${currentPath}\\x1b[0m${prompt}`);\n                }\n            } else if (printable) {\n                currentLine += key;\n                term.write(key);\n            }\n        });\n\n        // --- Startup Sequence ---\n        figlet.parseFont('Standard', figlet.fonts.Standard);\n        figlet.text('Lorel Axun', { font: 'Standard' }, (err, data) => {\n            if (err) return;\n            term.writeln(data);\n            const welcomeMessage = 'Benvenuto. Digita `help` per la lista dei comandi.';\n            let i = 0;\n            const typeWriter = () => {\n                if (i < welcomeMessage.length) {\n                    term.write(welcomeMessage.charAt(i));\n                    i++;\n                    setTimeout(typeWriter, 25);\n                } else {\n                    writePrompt();\n                    term.focus();\n                }\n            };\n            typeWriter();\n        });\n    </script>\n</body>\n</html>