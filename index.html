<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorel Axun</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
    <style>
        :root {
            --background: #1a1b26;
            --foreground: #c0caf5;
            --comment: #5c6370;
            --cyan: #7dcfff;
            --green: #9ece6a;
            --yellow: #e0af68;
            --blue: #7aa2f7;
            --magenta: #bb9af7;
            --red: #f7768e;
            --font-family: 'Menlo', 'Consolas', 'DejaVu Sans Mono', monospace;
            --window-bg: rgba(44, 45, 64, 0.85);
            --title-bar-bg: #1e1e2e;
            --dock-bg: rgba(26, 27, 38, 0.6);
            --dock-hover: rgba(44, 45, 64, 0.8);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--background);
            color: var(--foreground);
            font-family: var(--font-family);
        }

        #terminal-container {
            width: 100%;
            height: 100%;
        }

        #editor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            z-index: 10000;
            display: none;
            flex-direction: column;
        }

        #editor-textarea {
            flex-grow: 1;
            background-color: transparent;
            color: var(--foreground);
            border: none;
            outline: none;
            font-family: var(--font-family);
            font-size: 14px;
            padding: 10px;
            resize: none;
        }

        #editor-status-bar {
            background-color: var(--title-bar-bg);
            color: var(--foreground);
            padding: 4px 10px;
            font-size: 12px;
            text-align: center;
        }

        #desktop {
            width: 100%;
            height: 100%;
            background-image: url('https://source.unsplash.com/random/1920x1080?nature,cyberpunk');
            background-size: cover;
            background-position: center;
            position: relative;
            display: none;
        }

        .window {
            position: absolute;
            background-color: var(--window-bg);
            border: 1px solid var(--comment);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            min-width: 300px;
            min-height: 200px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .title-bar {
            background-color: var(--title-bar-bg);
            color: var(--foreground);
            padding: 8px;
            cursor: move;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .title-bar-buttons {
            display: flex;
        }

        .title-bar-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 6px;
            cursor: pointer;
        }

        .close-button { background-color: #ff5f57; }

        .window-content {
            flex-grow: 1;
            padding: 5px;
            overflow: auto;
        }
        
        #dock {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--dock-bg);
            border-radius: 12px;
            padding: 8px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--comment);
            transition: all 0.2s ease-in-out;
        }

        .dock-item {
            width: 50px;
            height: 50px;
            background-color: var(--dock-hover);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.1s ease-out, margin 0.1s ease-out;
            position: relative;
        }

        .tooltip {
            visibility: hidden;
            background-color: var(--background);
            color: var(--foreground);
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -50px; /* Use a fixed value */
            opacity: 0;
            transition: opacity 0.2s;
            width: 80px; /* Fixed width */
        }

        .dock-item:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .file-explorer-content {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .file-explorer-path {
            padding: 5px;
            background-color: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--comment);
            white-space: nowrap;
            overflow-x: auto;
        }

        .file-explorer-list {
            list-style: none;
            padding: 5px;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }

        .file-explorer-list li {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
        }

        .file-explorer-list li:hover {
            background-color: var(--dock-hover);
        }
    </style>
</head>
<body>

    <div id="terminal-container"></div>
    
    <div id="desktop">
        <div id="dock">
            <div class="dock-item" id="dock-terminal" title="Terminal">
                <span>&#128187;</span>
                <span class="tooltip">Terminal</span>
            </div>
            <div class="dock-item" id="dock-files" title="File Explorer">
                <span>&#128193;</span>
                <span class="tooltip">File Explorer</span>
            </div>
        </div>
    </div>

    <div id="editor">
        <textarea id="editor-textarea"></textarea>
        <div id="editor-status-bar">Ctrl+S to Save | Ctrl+Q to Quit</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet/lib/figlet.js"></script>

    <script>
        // --- VIRTUAL FILE SYSTEM ---
        class VFS {
            constructor() {
                this.fs = {
                    '/': {
                        type: 'directory',
                        children: {
                            'home': { type: 'directory', children: { 'user': { type: 'directory', children: { '.axunrc': { type: 'file', content: 'echo "Welcome to Lorel Axun OS"\nfiglet -f slant Lorel Axun\nalias ll="ls -l"' } } } } },
                            'bin': { type: 'directory', children: {} },
                            'etc': { type: 'directory', children: {} },
                        }
                    }
                };
                this.load();
            }

            save() {
                localStorage.setItem('vfs', JSON.stringify(this.fs));
            }

            load() {
                const savedVfs = localStorage.getItem('vfs');
                if (savedVfs) {
                    this.fs = JSON.parse(savedVfs);
                }
            }

            resolvePath(path, cwd) {
                if (!path) return cwd;
                let currentPath = path.startsWith('/') ? '/' : cwd;
                const parts = path.split('/').filter(p => p);

                if (!path.startsWith('/')) {
                    const cwdParts = cwd.split('/').filter(p => p);
                    currentPath = '/' + cwdParts.join('/');
                }

                for (const part of parts) {
                    if (part === '.') continue;
                    if (part === '..') {
                        currentPath = currentPath.substring(0, currentPath.lastIndexOf('/')) || '/';
                    } else {
                        const node = this.getNode(currentPath);
                        if (node && node.type === 'directory' && node.children[part]) {
                            currentPath = (currentPath === '/' ? '' : currentPath) + '/' + part;
                        } else {
                            return null; // Path not found
                        }
                    }
                }
                return currentPath;
            }

            getNode(path, cwd = '/') {
                const absolutePath = this.resolvePath(path, cwd);
                if (!absolutePath) return null;

                const parts = absolutePath.split('/').filter(p => p);
                let currentNode = this.fs['/'];
                for (const part of parts) {
                    if (currentNode && currentNode.type === 'directory' && currentNode.children[part]) {
                        currentNode = currentNode.children[part];
                    } else {
                        return null;
                    }
                }
                return currentNode;
            }

            create(path, type, content = '', cwd = '/') {
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);
                if (!name) return false;

                const parentNode = this.getNode(parentPath, cwd);
                if (parentNode && parentNode.type === 'directory') {
                    parentNode.children[name] = { type, content: content || (type === 'directory' ? { children: {} } : '') };
                    if (type === 'directory') parentNode.children[name].children = {};
                    this.save();
                    return true;
                }
                return false;
            }

            list(path, cwd = '/') {
                const node = this.getNode(path, cwd);
                if (node && node.type === 'directory') {
                    return Object.keys(node.children);
                }
                return null;
            }

            read(path, cwd = '/') {
                const node = this.getNode(path, cwd);
                if (node && node.type === 'file') {
                    return node.content;
                }
                return null;
            }

            write(path, content, cwd = '/') {
                const node = this.getNode(path, cwd);
                if (node && node.type === 'file') {
                    node.content = content;
                    this.save();
                    return true;
                }
                return false;
            }
            
            remove(path, cwd = '/') {
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);
                if (!name) return false;

                const parentNode = this.getNode(parentPath, cwd);
                if (parentNode && parentNode.type === 'directory' && parentNode.children[name]) {
                    delete parentNode.children[name];
                    this.save();
                    return true;
                }
                return false;
            }
        }

        // --- SHELL & TERMINAL ---
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: 'var(--background)',
                foreground: 'var(--foreground)',
                cursor: 'var(--foreground)',
                selection: 'var(--comment)',
                black: '#15161E',
                red: 'var(--red)',
                green: 'var(--green)',
                yellow: 'var(--yellow)',
                blue: 'var(--blue)',
                magenta: 'var(--magenta)',
                cyan: 'var(--cyan)',
                white: '#c0caf5',
                brightBlack: '#414868',
                brightRed: 'var(--red)',
                brightGreen: 'var(--green)',
                brightYellow: 'var(--yellow)',
                brightBlue: 'var(--blue)',
                brightMagenta: 'var(--magenta)',
                brightCyan: 'var(--cyan)',
                brightWhite: '#c0caf5'
            }
        });
        const terminalContainer = document.getElementById('terminal-container');
        term.open(terminalContainer);

        const vfs = new VFS();
        let cwd = '/home/user';
        let commandHistory = [];
        let historyIndex = -1;
        let env = { 'USER': 'user', 'HOME': '/home/user', 'PATH': '/bin' };
        let aliases = {};

        function getPrompt() {
            return `\x1b[38;5;153m${env.USER}\x1b[m@\x1b[38;5;117mlorel\x1b[m:\x1b[38;5;81m${cwd.replace(env.HOME, '~')}\x1b[m$ `;
        }

        term.prompt = () => {
            term.write(getPrompt());
        };

        let currentLine = '';
        term.onKey(({ key, domEvent }) => {
            const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            if (domEvent.keyCode === 13) { // Enter
                term.write('\r\n');
                if (currentLine.trim()) {
                    commandHistory.unshift(currentLine);
                    historyIndex = -1;
                    executeCommand(currentLine);
                }
                currentLine = '';
                term.prompt();
            } else if (domEvent.keyCode === 8) { // Backspace
                if (currentLine.length > 0) {
                    term.write('\b \b');
                    currentLine = currentLine.slice(0, -1);
                }
            } else if (domEvent.keyCode === 38) { // Arrow Up
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    term.write(`\x1b[2K\r${getPrompt()}${commandHistory[historyIndex]}`);
                    currentLine = commandHistory[historyIndex];
                }
            } else if (domEvent.keyCode === 40) { // Arrow Down
                if (historyIndex > 0) {
                    historyIndex--;
                    term.write(`\x1b[2K\r${getPrompt()}${commandHistory[historyIndex]}`);
                    currentLine = commandHistory[historyIndex];
                } else {
                    historyIndex = -1;
                    term.write(`\x1b[2K\r${getPrompt()}`);
                    currentLine = '';
                }
            } else if (printable) {
                currentLine += key;
                term.write(key);
            }
        });

        async function executeCommand(line, stdin = '') {
            const parts = line.trim().split('|').map(p => p.trim());
            let currentInput = stdin;

            for (let i = 0; i < parts.length; i++) {
                const commandPart = parts[i];
                const isLast = i === parts.length - 1;
                
                // Handle redirection
                let redirectPath = null;
                let append = false;
                let commandToRun = commandPart;
                if (commandPart.includes('>>')) {
                    [commandToRun, redirectPath] = commandPart.split('>>').map(p => p.trim());
                    append = true;
                } else if (commandPart.includes('>')) {
                    [commandToRun, redirectPath] = commandPart.split('>').map(p => p.trim());
                }

                const args = commandToRun.split(/\s+/);
                let command = args.shift();

                if (aliases[command]) {
                    const aliasExpansion = aliases[command].split(/\s+/);
                    command = aliasExpansion.shift();
                    args.unshift(...aliasExpansion);
                }

                const output = await runSingleCommand(command, args, currentInput);

                if (isLast && !redirectPath) {
                    if (output) term.write(output.replace(/\n/g, '\r\n') + (output.endsWith('\n') ? '' : '\r\n'));
                } else if (redirectPath) {
                    const absolutePath = vfs.resolvePath(redirectPath, cwd);
                    if (!absolutePath) {
                        term.write(`\r\nError: Cannot write to ${redirectPath}: No such file or directory\r\n`);
                        return;
                    }
                    let node = vfs.getNode(absolutePath);
                    if (node && node.type === 'directory') {
                        term.write(`\r\nError: ${redirectPath} is a directory\r\n`);
                        return;
                    }
                    if (!node) {
                        vfs.create(absolutePath, 'file', '', '/');
                    }
                    const oldContent = append ? vfs.read(absolutePath) : '';
                    vfs.write(absolutePath, oldContent + output);
                } else {
                    currentInput = output;
                }
            }
        }

        async function runSingleCommand(command, args, stdin) {
            switch (command) {
                case 'echo': return args.join(' ');
                case 'ls':
                    const path = args[0] || '.';
                    const items = vfs.list(path, cwd);
                    if (items) {
                        return items.map(item => {
                            const node = vfs.getNode(`${path}/${item}`, cwd);
                            return node.type === 'directory' ? `\x1b[1;34m${item}/\x1b[0m` : item;
                        }).join('\n');
                    } else return `ls: cannot access '${path}': No such file or directory`;
                case 'cd':
                    const newPath = vfs.resolvePath(args[0] || env.HOME, cwd);
                    if (newPath && vfs.getNode(newPath).type === 'directory') {
                        cwd = newPath;
                    } else return `cd: ${args[0]}: No such file or directory`;
                    return '';
                case 'pwd': return cwd;
                case 'cat':
                    const content = vfs.read(args[0], cwd);
                    return content !== null ? content : `cat: ${args[0]}: No such file or directory`;
                case 'mkdir':
                    vfs.create(`${cwd}/${args[0]}`, 'directory');
                    return '';
                case 'touch':
                    vfs.create(`${cwd}/${args[0]}`, 'file');
                    return '';
                case 'rm':
                    if (vfs.remove(`${cwd}/${args[0]}`)) return '';
                    else return `rm: cannot remove '${args[0]}': No such file or directory`;
                case 'clear': term.clear(); return '';
                case 'help': return 'Available commands: echo, ls, cd, pwd, cat, mkdir, touch, rm, clear, help, fetch, edit, js, startx, env, export, unset, alias';
                case 'fetch':
                    try {
                        const response = await fetch(args[0]);
                        const data = await response.text();
                        return data;
                    } catch (e) { return `fetch: failed to fetch ${args[0]}` }
                case 'edit':
                    openEditor(args[0]);
                    return '';
                case 'js':
                    const scriptContent = vfs.read(args[0], cwd);
                    if (scriptContent) return runInSandbox(scriptContent);
                    else return `js: file not found: ${args[0]}`;
                case 'startx':
                    startGUI();
                    return 'Starting graphical environment...';
                case 'figlet':
                    return new Promise(resolve => {
                        figlet.text(args.slice(1).join(' '), { font: args[0] === '-f' ? args[1] : 'Standard' }, (err, data) => {
                            if (err) resolve('Figlet error');
                            else resolve(data);
                        });
                    });
                case 'env': return Object.entries(env).map(([k, v]) => `${k}=${v}`).join('\n');
                case 'export':
                    const [key, ...value] = args.join(' ').split('=');
                    if (key && value.length > 0) env[key] = value.join('=');
                    localStorage.setItem('axun_env', JSON.stringify(env));
                    return '';
                case 'unset':
                    delete env[args[0]];
                    localStorage.setItem('axun_env', JSON.stringify(env));
                    return '';
                case 'alias':
                    if (args.length === 0) {
                        return Object.entries(aliases).map(([k, v]) => `alias ${k}='${v}'`).join('\n');
                    }
                    const aliasMatch = args.join(' ').match(/^([^=]+)='([^']*)'$/);
                    if (aliasMatch) {
                        aliases[aliasMatch[1]] = aliasMatch[2];
                    } else {
                        return 'Usage: alias name=\'command\''
                    }
                    return '';
                default: return `command not found: ${command}`;
            }
        }

        // --- EDITOR ---
        const editorEl = document.getElementById('editor');
        const editorTextarea = document.getElementById('editor-textarea');
        let editorFilePath = '';

        function openEditor(filePath) {
            editorFilePath = vfs.resolvePath(filePath, cwd);
            const content = vfs.read(editorFilePath);
            if (content !== null) {
                editorTextarea.value = content;
                editorEl.style.display = 'flex';
                term.blur();
                editorTextarea.focus();
            }
        }

        editorTextarea.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                vfs.write(editorFilePath, editorTextarea.value);
            } else if (e.ctrlKey && e.key === 'q') {
                e.preventDefault();
                editorEl.style.display = 'none';
                term.focus();
            }
        });

        // --- SANDBOX ---
        function runInSandbox(code) {
            const sandboxApi = {
                vfs: {
                    read: (path) => vfs.read(path, cwd),
                    write: (path, content) => vfs.write(path, content, cwd),
                    list: (path) => vfs.list(path, cwd),
                },
                env: { ...env },
                term: { log: (msg) => term.writeln(msg) }
            };
            try {
                const func = new Function('api', code);
                return func(sandboxApi) || '';
            } catch (e) {
                return `Sandbox error: ${e.message}`;
            }
        }

        // --- GUI ENVIRONMENT ---
        const desktop = document.getElementById('desktop');
        let highestZIndex = 100;

        function startGUI() {
            terminalContainer.style.display = 'none';
            desktop.style.display = 'block';
            openTerminalWindow();
        }

        function bringToFront(windowEl) {
            highestZIndex++;
            windowEl.style.zIndex = highestZIndex;
        }

        function dragElement(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const titleBar = elmnt.querySelector(".title-bar");
            if (titleBar) {
                titleBar.onmousedown = dragMouseDown;
            } else {
                elmnt.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                bringToFront(elmnt);
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        function createWindow(title, contentElement, options = {}) {
            const { width = '500px', height = '300px', top = '100px', left = '100px' } = options;
            const windowEl = document.createElement('div');
            windowEl.className = 'window';
            windowEl.style.width = width;
            windowEl.style.height = height;
            windowEl.style.top = top;
            windowEl.style.left = left;
            
            bringToFront(windowEl);
            windowEl.addEventListener('click', () => bringToFront(windowEl));

            const titleBar = document.createElement('div');
            titleBar.className = 'title-bar';
            titleBar.innerHTML = `<span>${title}</span>`;

            const buttons = document.createElement('div');
            buttons.className = 'title-bar-buttons';
            const closeBtn = document.createElement('div');
            closeBtn.className = 'title-bar-button close-button';
            closeBtn.onclick = () => windowEl.remove();
            buttons.appendChild(closeBtn);
            titleBar.appendChild(buttons);

            const content = document.createElement('div');
            content.className = 'window-content';
            content.appendChild(contentElement);

            windowEl.appendChild(titleBar);
            windowEl.appendChild(content);
            desktop.appendChild(windowEl);

            dragElement(windowEl);

            return windowEl;
        }

        function openTerminalWindow() {
            const termContainer = document.createElement('div');
            termContainer.style.width = '100%';
            termContainer.style.height = '100%';
            const newTerm = new Terminal({ theme: term.getOption('theme') });
            createWindow('Terminal', termContainer, { width: '600px', height: '400px' });
            newTerm.open(termContainer);
            newTerm.write('This is a new terminal window.\r\n');
        }
        
        function openFileExplorerWindow() {
            const explorerContent = document.createElement('div');
            explorerContent.className = 'file-explorer-content';
            const pathBar = document.createElement('div');
            pathBar.className = 'file-explorer-path';
            const fileList = document.createElement('ul');
            fileList.className = 'file-explorer-list';
            explorerContent.appendChild(pathBar);
            explorerContent.appendChild(fileList);

            let currentExplorerPath = '/';

            function render(path) {
                currentExplorerPath = path;
                pathBar.textContent = path;
                fileList.innerHTML = '';
                if (path !== '/') {
                    const up = document.createElement('li');
                    up.textContent = '..';
                    up.onclick = () => render(path.substring(0, path.lastIndexOf('/')) || '/');
                    fileList.appendChild(up);
                }
                const items = vfs.list(path);
                items.forEach(item => {
                    const li = document.createElement('li');
                    const node = vfs.getNode(`${path === '/' ? '' : path}/${item}`);
                    if (node.type === 'directory') {
                        li.textContent = `\ud83d\udcc1 ${item}`;
                        li.onclick = () => render(`${path === '/' ? '' : path}/${item}`);
                    } else {
                        li.textContent = `\ud83d\udcc4 ${item}`;
                    }
                    fileList.appendChild(li);
                });
            }

            createWindow('File Explorer', explorerContent, { top: '150px', left: '150px' });
            render('/');
        }

        // Dock logic
        document.getElementById('dock-terminal').onclick = openTerminalWindow;
        document.getElementById('dock-files').onclick = openFileExplorerWindow;
        const dockItems = document.querySelectorAll('.dock-item');
        dockItems.forEach(item => {
            item.addEventListener('mousemove', e => {
                const itemRect = item.getBoundingClientRect();
                const dockRect = item.parentElement.getBoundingClientRect();
                const offset = e.clientX - itemRect.left;
                const center = itemRect.width / 2;
                const distance = Math.abs(center - offset);
                const scale = Math.max(1, 2 - (distance / center) * 1.2);
                item.style.transform = `scale(${scale}) translateY(-10px)`;
                
                // Influence neighbors
                const prev = item.previousElementSibling;
                const next = item.nextElementSibling;
                if (prev) {
                    const prevScale = Math.max(1, 1.5 - (distance / center) * 1.2);
                    prev.style.transform = `scale(${prevScale}) translateY(-5px)`;
                }
                if (next) {
                    const nextScale = Math.max(1, 1.5 - (distance / center) * 1.2);
                    next.style.transform = `scale(${nextScale}) translateY(-5px)`;
                }
            });
            item.addEventListener('mouseleave', () => {
                dockItems.forEach(i => i.style.transform = 'scale(1) translateY(0)');
            });
        });

        // --- INITIALIZATION ---
        function init() {
            const savedEnv = localStorage.getItem('axun_env');
            if (savedEnv) {
                env = JSON.parse(savedEnv);
            }
            const rcPath = vfs.resolvePath('.axunrc', env.HOME);
            const rcContent = vfs.read(rcPath);
            if (rcContent) {
                const commands = rcContent.split('\n');
                commands.forEach(cmd => {
                    if (cmd.trim()) executeCommand(cmd);
                });
            }
            term.prompt();
        }

        init();

    </script>
</body>
</html>